README.org part 2/3
--------------------

*** core/custom.el
:PROPERTIES:
:CUSTOM_ID: custom-file
:header-args:emacs-lisp: :tangle lisp/core/custom.el
:END:

#+begin_src emacs-lisp
  ;;; core/custom.el --- custom-file helpers -*- lexical-binding: t; -*-
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; - Route customize output to .etc/custom.el
  ;; - Provide helpers to open and (optionally) dump current values/faces.

  (eval-when-compile (require 'subr-x))

  (defconst my:f:custom
    (or (bound-and-true-p my:f:custom)
        (expand-file-name "custom.el" (or (bound-and-true-p my:d:etc)
  					(expand-file-name ".etc" user-emacs-directory))))
    "Path to the custom-file (Customize output).")

  (defun my/custom--ensure-file ()
    "Ensure `custom-file` exists and has a small header."
    (let* ((dir (file-name-directory my:f:custom)))
      (unless (file-directory-p dir)
        (condition-case err
            (make-directory dir t)
          (error (warn "[custom] failed to create %s: %s" dir (error-message-string err)))))
      (unless (file-exists-p my:f:custom)
        (with-temp-file my:f:custom
          (insert ";;; custom.el --- Customize output -*- lexical-binding: t; -*-\n"
                  ";; This file is generated by Customize. Edit with care.\n\n")))))

  ;; 1) Route Customize output to .etc/custom.el (idempotent)
  (setq custom-file my:f:custom)
  (my/custom--ensure-file)
  (when (file-readable-p custom-file)
    (ignore-errors (load custom-file nil 'nomessage)))

  ;;;###autoload
  (defun my/custom-open ()
    "Open the `custom-file`."
    (interactive)
    (my/custom--ensure-file)
    (find-file my:f:custom))

  ;;;###autoload
  (defun my/custom-dump-current ()
    "Persist a curated set of current settings/faces into `custom-file`.
  This is a one-shot snapshot; it won't run automatically."
    (interactive)
    (my/custom--ensure-file)

    ;; ---- Variables you want to persist (add/remove as you like) ----
    (dolist (pair
             `(
               ;; Core UI
               (inhibit-startup-screen             . ,inhibit-startup-screen)
               (frame-resize-pixelwise             . ,(bound-and-true-p frame-resize-pixelwise))
               (display-line-numbers-type          . ,(and (boundp 'display-line-numbers-type) display-line-numbers-type))
               ;; Completion
               (completion-styles                  . ,(and (boundp 'completion-styles) completion-styles))
               (completion-category-overrides      . ,(and (boundp 'completion-category-overrides) completion-category-overrides))
               ;; Org (selected)
               (org-startup-indented               . ,(and (boundp 'org-startup-indented) org-startup-indented))
               (org-hide-leading-stars             . ,(and (boundp 'org-hide-leading-stars) org-hide-leading-stars))
               (org-tags-column                    . ,(and (boundp 'org-tags-column) org-tags-column))
               (org-agenda-tags-column             . ,(and (boundp 'org-agenda-tags-column) org-agenda-tags-column))
               ;; org-modern (selected)
               (org-modern-list                    . ,(and (boundp 'org-modern-list) org-modern-list))
               (org-modern-checkbox                . ,(and (boundp 'org-modern-checkbox) org-modern-checkbox))
               (org-modern-priority                . ,(and (boundp 'org-modern-priority) org-modern-priority))
               (org-modern-replace-stars           . ,(and (boundp 'org-modern-replace-stars) org-modern-replace-stars))
               (org-modern-todo-faces              . ,(and (boundp 'org-modern-todo-faces) org-modern-todo-faces))
               ))
      ;; Only save bound values; skip nil/unbound
      (when (car (last pair))
        (customize-save-variable (car pair) (cdr pair))))

    ;; ---- Faces you want to persist (add/remove as you like) ----
    (let ((faces
           '(
             (org-modern-date-active   ((t (:background "#373844" :foreground "#f8f8f2" :height 0.75 :weight light :width condensed))))
             (org-modern-time-active   ((t (:background "#44475a" :foreground "#f8f8f2" :height 0.75 :weight light :width condensed))))
             (org-modern-date-inactive ((t (:background "#373844" :foreground "#b0b8d1" :height 0.75 :weight light :width condensed))))
             (org-modern-time-inactive ((t (:background "#44475a" :foreground "#b0b8d1" :height 0.75 :weight light :width condensed))))
             (org-modern-tag           ((t (:background "#44475a" :foreground "#b0b8d1" :height 0.75 :weight light :width condensed))))
             (org-modern-statistics    ((t (:foreground "violet" :weight light))))
             )))
      (dolist (f faces)
        (let ((face (nth 0 f)) (spec (nth 1 f)))
          (custom-set-faces `(,face ,spec)))))
    ;; Actually write
    (custom-save-all)
    (message "[custom] Wrote current snapshot to %s" my:f:custom))

  (provide 'core/custom)
  ;;; core/custom.el ends here
#+end_src

**** Wiring
- If your *early-init.el* / *init.el* already points `custom-file` to `.etc/custom.el`, you‚Äôre good.
- Ensure `core/custom` is in the module list (e.g. `lisp/modules.el` ‚Üí add `core/custom` to `my:modules`).

**** Usage
- `M-x my/custom-open` ‚Äî open `.etc/custom.el`
- `M-x my/custom-dump-current` ‚Äî write a one-time snapshot of selected settings/faces to `.etc/custom.el` (it does *not* run at startup)

*** core/custom-ui-extras.el (Enable new UI extras via my:modules-extra)
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/core/custom-ui-extras.el
:END:
#+begin_src emacs-lisp
  ;;; core/custom-ui-extras.el --- user extras -*- lexical-binding: t; -*-
  ;; Append without touching your default module list.
  (setq my:modules-extra
        (delete-dups
         (append my:modules-extra
                 '(ui/ui-visual-aids
                   orgx/org-typography
                   ui/ui-macos))))
  (provide 'core/custom-ui-extras)
#+end_src

*** ui/ui-font.el
:PROPERTIES:
:CUSTOM_ID: ui-font
:header-args:emacs-lisp: :tangle lisp/ui/ui-font.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-font.el --- Font configuration -*- lexical-binding: t; -*-

  ;; Ensure the leaf macro is available at compile time here too.
  (eval-when-compile (require 'leaf))

  (defun my/system-default-font ()
    "Return a default monospace font family depending on OS."
    (cond ((eq system-type 'darwin) "Menlo")
          ((eq system-type 'gnu/linux) "Monospace")
          ((eq system-type 'windows-nt) "Consolas")
          (t "Monospace")))

  (defun my/system-emoji-font ()
    "Return a default emoji font family depending on OS."
    (cond ((eq system-type 'darwin) "Apple Color Emoji")
          ((eq system-type 'gnu/linux) "Noto Color Emoji")
          ((eq system-type 'windows-nt) "Segoe UI Emoji")
          (t "Noto Color Emoji")))

  (defun my/font-setup ()
    "Apply font settings, respecting overrides, and report applied fonts."
    (when (display-graphic-p)
      (set-face-attribute 'default nil
                          :family (or my:font-default (my/system-default-font))
                          :height (* 10 (or my:font-size 18)))
      (message "[font] default: %s, %.1f pt"
               (face-attribute 'default :family)
               (/ (float (face-attribute 'default :height)) 18))
      (set-face-attribute 'variable-pitch nil
                          :family (or my:font-alt (my/system-default-font)))
      (message "[font] variable-pitch: %s"
               (face-attribute 'variable-pitch :family))
      (set-fontset-font t 'emoji
                        (font-spec :family (or my:emoji-font (my/system-emoji-font))))
      (message "[font] emoji: %s"
               (or my:emoji-font (my/system-emoji-font)))))

  (defun my/show-current-font () (interactive)
    "Echo the current default font family and point size."
    (let* ((family (face-attribute 'default :family))
           (height (face-attribute 'default :height))
           (pt (/ height 10.0)))
      (message "Current font: %s, %.1f pt" family pt)))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame) (with-selected-frame frame (my/font-setup))))
    (add-hook 'after-init-hook #'my/font-setup))

  ;; OPTIONAL ligatures ‚Äî install & enable only when available/GUI.
  (leaf ligature
    :straight (ligature :type git :host github :repo "mickeynp/ligature.el")
    :when (display-graphic-p)
    :require t
    :config
    (when (fboundp 'ligature-set-ligatures)
      (ligature-set-ligatures 'prog-mode '("->" "=>" "::" "===" "!=" "&&" "||"))
      (global-ligature-mode 1)))

  (provide 'ui/ui-font)
  ;;; ui/ui-font.el ends here
#+end_src

*** ui/ui-nano-palette.el
:PROPERTIES:
:CUSTOM_ID: ui-theme
:header-args:emacs-lisp: :tangle lisp/ui/ui-nano-palette.el
:END:

#+begin_src emacs-lisp
  ;;; ui-nano-palette.el --- Nano-style palette -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;; Commentary:
  ;; One source of truth:
  ;; - Define the palette once (defcustom ‚Üí easy to tweak via M-x customize)
  ;; - Apply all faces from a single function
  ;; - No duplicated literal colors scattered around
  ;;
  ;;; Code:

  (defgroup my:nano nil
    "Minimal nano-style light palette."
    :group 'faces)

  (defcustom nano-color-background "#fafafa" ; near-white / gray-50
    "UI background for buffers/panels."
    :type 'string :group 'my:nano)

  (defcustom nano-color-foreground "#374151" ; slate-700
    "Default body text color."
    :type 'string :group 'my:nano)

  (defcustom nano-color-salient "#2563eb" ; blue-600
    "Accent for links/keywords/standout choices."
    :type 'string :group 'my:nano)

  (defcustom nano-color-popout "#6b7280" ; slate-500 (muted notice)
    "Neutral notice / muted highlight."
    :type 'string :group 'my:nano)

  (defcustom nano-color-critical "#dc2626" ; red-600
    "Critical error / danger color."
    :type 'string :group 'my:nano)

  (defcustom nano-color-strong "#111827" ; slate-900
    "Strong emphasis (headings, key mode-line parts)."
    :type 'string :group 'my:nano)

  (defcustom nano-color-faded "#9ca3af" ; slate-400
    "De-emphasized info (comments/secondary/disabled)."
    :type 'string :group 'my:nano)

  (defcustom nano-color-subtle "#e5e7eb" ; gray-200
    "Subtle backgrounds (mode/header lines, gentle selections)."
    :type 'string :group 'my:nano)

  (defun my/nano-apply-faces ()
    "Apply faces based on the nano-style palette defined above.
  Call this *after* your theme is enabled if the theme overrides faces."
    ;; Core text
    (set-face-attribute 'default nil
                        :background nano-color-background
                        :foreground nano-color-foreground)
    (set-face-attribute 'bold   nil :foreground nano-color-strong :weight 'bold)
    (set-face-attribute 'italic nil :slant 'italic)

    ;; Syntax (tune to taste)
    (set-face-attribute 'font-lock-comment-face nil :foreground nano-color-faded)
    (set-face-attribute 'font-lock-keyword-face nil :foreground nano-color-salient :weight 'semi-bold)
    (set-face-attribute 'font-lock-string-face  nil :foreground nano-color-popout)
    (set-face-attribute 'font-lock-warning-face nil :foreground nano-color-popout :weight 'bold)

    ;; Links / buttons
    (set-face-attribute 'link   nil :foreground nano-color-salient :underline t)
    (set-face-attribute 'button nil :foreground nano-color-salient :underline t)

    ;; Status faces
    (set-face-attribute 'error   nil :foreground nano-color-critical :weight 'bold)
    (set-face-attribute 'warning nil :foreground nano-color-popout  :weight 'bold)
    (set-face-attribute 'success nil :foreground "#10b981") ; emerald-500

    ;; Selection
    (set-face-attribute 'region nil :background nano-color-subtle)

    ;; Mode line
    (let ((ml-bg nano-color-subtle)
          (ml-fg nano-color-strong))
      (set-face-attribute 'mode-line nil
                          :background ml-bg :foreground ml-fg
                          :box `(:line-width 1 :color ,ml-bg))
      (set-face-attribute 'mode-line-inactive nil
                          :background nano-color-background :foreground nano-color-faded
                          :box `(:line-width 1 :color ,nano-color-background)))

    ;; Minibuffer prompt
    (set-face-attribute 'minibuffer-prompt nil
                        :foreground nano-color-salient :weight 'semi-bold))

  ;; Optional: a convenience API to override a subset, then apply.
  (defun my/nano-set-palette-and-apply (&rest plist)
    "Override any palette entries via PLIST and apply faces.
  Keys: :background :foreground :salient :popout :critical :strong :faded :subtle"
    (when plist
      (let ((map '((:background . nano-color-background)
                   (:foreground . nano-color-foreground)
                   (:salient    . nano-color-salient)
                   (:popout     . nano-color-popout)
                   (:critical   . nano-color-critical)
                   (:strong     . nano-color-strong)
                   (:faded      . nano-color-faded)
                   (:subtle     . nano-color-subtle))))
        (while plist
          (let* ((k (pop plist)) (v (pop plist))
                 (sym (cdr (assq k map))))
            (when sym (set sym v))))))
    (my/nano-apply-faces))

  ;; Usage examples:
  ;; (my/nano-apply-faces) ; apply as-is
  ;; (my/nano-set-palette-and-apply :popout "#f59e0b") ; switch to amber popout, then apply

  (provide 'ui/ui-nano-palette)
  ;;; ui/ui-nano-palette.el ends here
#+end_src

*** ui/ui-theme.el
:PROPERTIES:
:CUSTOM_ID: ui-theme
:header-args:emacs-lisp: :tangle lisp/ui/ui-theme.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-theme.el --- Theme configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Commentary:
  ;;; ui/ui-theme.el --- Theme configuration -*- lexical-binding: t; -*-
  ;;
  ;; Category: ui
  ;; Uses nano-emacs + nano-theme + spacious-padding
  ;; Palette & face normalization are centralized in my-nano-palette.el
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; Load the palette (one source of truth for colors)
  (require 'ui/ui-nano-palette) ;; provides: my/nano-apply-faces, my/nano-set-palette-and-apply, defcustoms

  ;; Compact line height (tweak to taste)
  (setq-default line-spacing 0.24)

  ;; Helper: re-apply our face normalization after any theme is enabled
  (defun my/nano--reapply-after-theme (&rest _)
    "Re-apply nano-style face normalization after a theme change."
    (when (fboundp 'my/nano-apply-faces)
      (my/nano-apply-faces)))

  ;; Emacs 29+ offers `enable-theme-functions`; if unavailable, use advice
  (with-eval-after-load 'cus-theme
    (if (boundp 'enable-theme-functions)
        (add-hook 'enable-theme-functions #'my/nano--reapply-after-theme)
      (advice-add 'enable-theme :after #'my/nano--reapply-after-theme)))

  ;; nano: faces/base ‚Üí theme ‚Üí modeline
  (leaf nano-emacs
    :straight (nano-emacs :type git :host github :repo "rougier/nano-emacs")
    :init
    (when (fboundp 'my-nano-setup-colors) (my/nano-setup-colors))
    :config
    (require 'nano-layout)
    (require 'nano-faces)
    (nano-faces)

    ;; Make nano's strong face actually "strong"
    (set-face-attribute 'nano-face-strong nil
                        :foreground (face-foreground 'nano-face-default)
                        :weight 'bold)

    (leaf nano-theme
      :straight (nano-theme :type git :host github :repo "rougier/nano-theme")
      :config
      ;; Enable nano theme, then normalize faces from our palette
      (load-theme 'nano t)
      (my/nano-apply-faces)

      ;; Keep basic emphasis consistent regardless of theme internals
      (set-face-attribute 'bold nil   :weight 'bold)
      (set-face-attribute 'italic nil :slant 'italic)
      (with-eval-after-load 'elec-pair
        (custom-set-faces
         '(electric-pair-overlay-face ((t (:background "#e5e7eb"))))
         '(show-paren-match ((t (:background "#e5e7eb" :foreground "#111827" :weight bold))))
         '(show-paren-mismatch ((t (:background "#dc2626" :foreground "white" :weight bold))))))))

  ;; Subtle padding on GUI
  (leaf spacious-padding :straight t
    :if (display-graphic-p)
    :custom
    ((spacious-padding-widths . '((left . 15) (right . 15)))
     (spacious-padding-subtle-mode-line . t))
    :config
    (spacious-padding-mode 1)
    ;; Re-apply faces once padding tweaks modeline metrics
    (my/nano-apply-faces))

  (provide 'ui/ui-theme)
  ;;; ui/ui-theme.el ends here
#+end_src

*** ui/ui-doom-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-doom-modeline
:header-args:emacs-lisp: :tangle lisp/ui/ui-doom-modeline.el
:END:

#+begin_src emacs-lisp
  ;;; ui-doom-modeline.el --- Doom UI bundle entry -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;;; Commentary:
  ;; Enable doom-modeline (with nerd-icons) as a compact UI bundle.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))
  (declare-function doom-modeline-mode "doom-modeline")

  (leaf nerd-icons :straight t)

  (leaf doom-modeline
    :straight t
    :custom ((doom-modeline-height . 28)
             (doom-modeline-buffer-file-name-style . 'truncate-with-project)
             (doom-modeline-minor-modes . nil)
             (doom-modeline-enable-word-count . t))
    :config
    (doom-modeline-mode 1))

  ;;;###autoload
  (defun my/ui-enable-doom ()
    "Enable Doom UI modeline bundle."
    (interactive)
    (unless (bound-and-true-p doom-modeline-mode)
      (doom-modeline-mode 1))
    (message "[ui] Doom modeline enabled."))

  (provide 'ui/ui-doom-modeline)
  ;;; ui/ui-doom-modeline.el ends here
#+end_src

*** ui/ui-nano-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-nano-modeline
:header-args:emacs-lisp: :tangle lisp/ui/ui-nano-modeline.el
:END:

#+begin_src emacs-lisp
  ;;; ui-nano-modeline.el --- Nano UI bundle entry -*- lexical-binding: t; -*-
  ;;
  ;; Category: ui
  ;;
  ;;; Commentary:
  ;; Robust loader that tries to require `nano-modeline` and wires all mode hooks.
  ;; Safe even if the package is not available at build time.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (declare-function nano-modeline-mode              "nano-modeline")
  (declare-function nano-modeline-prog-mode         "nano-modeline")
  (declare-function nano-modeline-text-mode         "nano-modeline")
  (declare-function nano-modeline-org-mode          "nano-modeline")
  (declare-function nano-modeline-pdf-mode          "nano-modeline")
  (declare-function nano-modeline-mu4e-headers-mode "nano-modeline")
  (declare-function nano-modeline-mu4e-message-mode "nano-modeline")
  (declare-function nano-modeline-elfeed-entry-mode "nano-modeline")
  (declare-function nano-modeline-elfeed-search-mode "nano-modeline")
  (declare-function nano-modeline-term-mode         "nano-modeline")
  (declare-function nano-modeline-xwidget-mode      "nano-modeline")
  (declare-function nano-modeline-message-mode      "nano-modeline")
  (declare-function nano-modeline-org-capture-mode  "nano-modeline")
  (declare-function nano-modeline-org-agenda-mode   "nano-modeline")

  (defvar ui--nano-modeline-initialized nil
    "Non-nil once nano-modeline hooks have been installed.")

  (defun my/ui--nano-available-p ()
    "Return non-nil if `nano-modeline` can be required."
    (require 'nano-modeline nil 'noerror))

  (defun my/ui--nano-setup ()
    "Install nano-modeline hooks once (idempotent)."
    (when (and (not ui--nano-modeline-initialized)
               (my/ui--nano-available-p))
      (setopt nano-modeline-padding '(0.20 . 0.25))

      (when (fboundp 'nano-modeline-text-mode)
        (nano-modeline-text-mode t))

      (when (fboundp 'nano-modeline-prog-mode)
        (add-hook 'prog-mode-hook            #'nano-modeline-prog-mode))
      (when (fboundp 'nano-modeline-text-mode)
        (add-hook 'text-mode-hook            #'nano-modeline-text-mode))
      (when (fboundp 'nano-modeline-org-mode)
        (add-hook 'org-mode-hook             #'nano-modeline-org-mode))
      (when (fboundp 'nano-modeline-pdf-mode)
        (add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode))
      (when (fboundp 'nano-modeline-mu4e-headers-mode)
        (add-hook 'mu4e-headers-mode-hook    #'nano-modeline-mu4e-headers-mode))
      (when (fboundp 'nano-modeline-mu4e-message-mode)
        (add-hook 'mu4e-view-mode-hook       #'nano-modeline-mu4e-message-mode))
      (when (fboundp 'nano-modeline-elfeed-entry-mode)
        (add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode))
      (when (fboundp 'nano-modeline-elfeed-search-mode)
        (add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode))
      (when (fboundp 'nano-modeline-term-mode)
        (add-hook 'term-mode-hook            #'nano-modeline-term-mode))
      (when (fboundp 'nano-modeline-xwidget-mode)
        (add-hook 'xwidget-webkit-mode-hook  #'nano-modeline-xwidget-mode))
      (when (fboundp 'nano-modeline-message-mode)
        (add-hook 'messages-buffer-mode-hook #'nano-modeline-message-mode))
      (when (fboundp 'nano-modeline-org-capture-mode)
        (add-hook 'org-capture-mode-hook     #'nano-modeline-org-capture-mode))
      (when (fboundp 'nano-modeline-org-agenda-mode)
        (add-hook 'org-agenda-mode-hook      #'nano-modeline-org-agenda-mode))

      (setq ui--nano-modeline-initialized t)
      (message "[ui] nano-modeline initialized.")))

  (leaf nano-modeline
    :straight (nano-modeline :type git :host github :repo "rougier/nano-modeline")
    :after nano-emacs
    :require nil
    :init
    (add-hook 'after-init-hook #'my/ui--nano-setup)
    :hook
    (prog-mode-hook . nano-modeline-prog-mode)
    (text-mode-hook . nano-modeline-text-mode))

  ;;;###autoload
  (defun my/ui-enable-nano ()
    "Enable Nano UI modeline bundle (guarded)."
    (interactive)
    (if (my/ui--nano-available-p)
        (progn
          (my/ui--nano-setup)
          (message "[ui] nano-modeline enabled."))
      (message "[ui] nano-modeline not available; will enable after it is installed.")))

  (provide 'ui/ui-nano-modeline)
  ;;; ui/ui-nano-modeline.el ends here
#+end_src

*** ui/ui-health-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-health-modeline
:header-args:emacs-lisp: :tangle lisp/ui/ui-health-modeline.el
:END:

Purpose:
Provide lightweight, non-intrusive visibility into Emacs session health.

What it does:
- Displays buffer and process counts in the global mode-line
- Optionally shows Eglot workspace count
- Reacts to buffer and process lifecycle events

Notes:
- This module is read-only with respect to session state.
- It must not trigger GC, cleanup, or lifecycle actions.
- All policy decisions live in core/session.el.

#+begin_src emacs-lisp
  ;;; ui-health-modeline.el --- Session health indicators -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;;; Commentary:
  ;; Mode-line indicators for Emacs session health.
  ;;
  ;; This module provides a small, low-cost visualization of:
  ;; - Number of live buffers
  ;; - Number of live processes
  ;; - (Optionally) active Eglot workspaces
  ;;
  ;; This module is UI-only and does not manage session lifecycle.
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x))

  ;; ---------------------------------------------------------------------------
  ;; Customization
  ;; ---------------------------------------------------------------------------

  (defgroup ui-health-modeline nil
    "Mode-line indicators for session health."
    :group 'mode-line)

  (defcustom ui-health-show-buffers-p t
    "Show buffer count in the mode-line."
    :type 'boolean
    :group 'ui-health-modeline)

  (defcustom ui-health-show-processes-p t
    "Show process count in the mode-line."
    :type 'boolean
    :group 'ui-health-modeline)

  (defcustom ui-health-show-eglot-p t
    "Show Eglot workspace count in the mode-line when available."
    :type 'boolean
    :group 'ui-health-modeline)

  ;; ---------------------------------------------------------------------------
  ;; Internal state
  ;; ---------------------------------------------------------------------------

  (defvar ui-health--mode-line-string ""
    "Mode-line string representing current session health.")

  ;; ---------------------------------------------------------------------------
  ;; Data collectors (read-only)
  ;; ---------------------------------------------------------------------------

  (defun ui-health--buffers-count ()
    "Return the number of live buffers."
    (length (buffer-list)))

  (defun ui-health--processes-count ()
    "Return the number of live processes."
    (length (process-list)))

  (defun ui-health--eglot-count ()
    "Return the number of active Eglot workspaces, or nil.

  This function avoids touching Eglot internals and only reports
  when information is safely available."
    (when (and ui-health-show-eglot-p
               (featurep 'eglot)
               (boundp 'eglot--managed-buffers))
      (length eglot--managed-buffers)))

  ;; ---------------------------------------------------------------------------
  ;; Mode-line update
  ;; ---------------------------------------------------------------------------

  (defun ui-health--update ()
    "Update `ui-health--mode-line-string`."
    (setq ui-health--mode-line-string
          (concat
           (when ui-health-show-buffers-p
             (format " B:%d" (ui-health--buffers-count)))
           (when ui-health-show-processes-p
             (format " P:%d" (ui-health--processes-count)))
           (when-let* ((n (ui-health--eglot-count)))
             (format " LSP:%d" n))))
    (force-mode-line-update))

  ;; ---------------------------------------------------------------------------
  ;; Hooks
  ;; ---------------------------------------------------------------------------

  (add-hook 'buffer-list-update-hook #'ui-health--update)
  (add-hook 'process-status-change-hook #'ui-health--update)

  (with-eval-after-load 'eglot
    (add-hook 'eglot-managed-mode-hook #'ui-health--update)
    (add-hook 'eglot-server-stopped-hook #'ui-health--update))

  ;; ---------------------------------------------------------------------------
  ;; Activation
  ;; ---------------------------------------------------------------------------

  (unless (member 'ui-health--mode-line-string global-mode-string)
    (setq global-mode-string
          (append global-mode-string '(ui-health--mode-line-string))))

  (ui-health--update)

  (provide 'ui/ui-health-modeline)
  ;;; ui/ui-health-modeline.el ends here
#+end_src

*** ui/ui-window.el
:PROPERTIES:
:CUSTOM_ID: ui-window
:header-args:emacs-lisp: :tangle lisp/ui/ui-window.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-window.el --- Window management -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;;; Code:

  (leaf zoom :straight t
    :hook (after-init-hook . zoom-mode)
    :custom ((zoom-size . '(0.62 . 0.62))
             (zoom-ignored-major-modes . '(dired-mode treemacs-mode))
             (zoom-ignored-buffer-names . '("*Messages*" "*Help*"))))

  (leaf desktop
    :straight nil
    :config
    (let* ((dir (concat no-littering-var-directory "desktop/")))
      (setq desktop-dirname            dir
            desktop-path               (list dir)
            desktop-base-file-name     "desktop"
            desktop-base-lock-name     "lock"
            desktop-restore-eager      10
            desktop-save               t
            desktop-load-locked-desktop nil
            desktop-auto-save-timeout  300)
      (my/ensure-directory-exists dir)
      (desktop-save-mode 1)))

  (leaf winner
    :straight nil
    :global-minor-mode t)

  (defvar my:saved-window-config nil)

  (defun my/save-window-layout () (interactive)
    (setq my:saved-window-config (window-state-get nil t))
    (message "Window configuration saved."))

  (defun my/restore-window-layout () (interactive)
    (if my:saved-window-config
        (window-state-put my:saved-window-config)
      (message "No saved window configuration found.")))

  (provide 'ui/ui-window)
  ;;; ui/ui-window.el ends here
#+end_src

*** ui/ui-utils.el
:PROPERTIES:
:CUSTOM_ID: ui-utils
:header-args:emacs-lisp: :tangle lisp/ui/ui-utils.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-utils.el --- Treemacs configuration & UI utils -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;;; Code:

  (leaf minions :straight t
    :custom ((minions-mode-line-lighter . "‚öô"))
    :hook (after-init-hook . minions-mode))

  (setq display-time-interval 30
        display-time-day-and-date t
        display-time-24hr-format t)
  (display-time-mode 1)
  (when (fboundp 'display-battery-mode) (display-battery-mode 1))

  (leaf treemacs :straight t
    :if (display-graphic-p)
    :custom ((treemacs-filewatch-mode . t)
             (treemacs-follow-mode . t)
             (treemacs-indentation . 2)
             (treemacs-missing-project-action . 'remove)))

  (leaf nerd-icons-dired :straight t
    :hook (dired-mode . nerd-icons-dired-mode))

  (leaf pbcopy
    :if (memq window-system '(mac ns))
    :straight t
    :config (turn-on-pbcopy))

  (provide 'ui/ui-utils)
  ;;; ui/ui-utils.el ends here
#+end_src

*** ui/ui-visual-aids.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/ui/ui-visual-aids.el
:END:
#+begin_src emacs-lisp
  ;;; ui/ui-visual-aids.el --- Subtle visual helpers -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Add gentle, non-overlapping visual aids. Avoids features already present in your config.

  (eval-when-compile (require 'leaf))

  ;; 1) Cursor/Movement trail
  (leaf pulsar
    :straight t
    :init (setq pulsar-delay 0.04
                pulsar-pulse t
                pulsar-face 'pulsar-generic)
    :config
    (pulsar-global-mode 1)
    ;; add some common jumps without touching your existing keymaps
    (dolist (cmd '(recenter-top-bottom other-window next-buffer previous-buffer))
      (add-to-list 'pulsar-pulse-functions cmd)))

  ;; 2) highlighting in code/text
  (leaf hl-todo
    :straight t
    :hook ((prog-mode-hook text-mode-hook) . hl-todo-mode)
    :init (setq hl-todo-keyword-faces
                '(("TODO" . "#d97706") ("FIXME" . "#dc2626")
                  ("NOTE" . "#2563eb") ("HACK" . "#9333ea"))))

  ;; 3) Rainbow delimiters (programming only)
  (leaf rainbow-delimiters
    :straight t
    :hook (prog-mode-hook . rainbow-delimiters-mode))

  ;; 4) Lightweight indent guides (no tree sitter dependency)
  (leaf indent-bars
    :straight t
    :hook (prog-mode-hook . indent-bars-mode)
    :init (setq indent-bars-prefer-character t
                indent-bars-spacing-override 2))

  (provide 'ui/ui-visual-aids)
  ;;; ui/ui-visual-aids.el ends here
#+end_src

*** ui/ui-macos.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/ui/ui-macos.el
:END:
#+begin_src emacs-lisp
  ;;; ui/ui-macos.el --- macOS niceties -*- lexical-binding: t; -*-
  (eval-when-compile (require 'leaf))

  (when (eq system-type 'darwin)
    ;; transparent titlebar & light/dark follows theme (your ef-themes will override ns-appearance)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist '(use-title-bar . t)))

  (provide 'ui/ui-macos)
  ;;; ui/ui-macos.el ends here
#+end_src

*** completion/completion-core.el
:PROPERTIES:
:CUSTOM_ID: completion-core
:header-args:emacs-lisp: :tangle lisp/completion/completion-core.el
:END:

#+begin_src emacs-lisp
  ;;; completion-core.el --- Completion core settings -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf orderless
    :straight t
    :custom
    ((completion-styles . '(orderless basic))
     (completion-category-overrides
      . '((file (styles . (partial-completion)))
          (symbol (styles . (orderless)))
          (command (styles . (orderless)))))))

  (provide 'completion/completion-core)
#+end_src

*** completion/completion-vertico.el
:PROPERTIES:
:CUSTOM_ID: completion-vertico
:header-args:emacs-lisp: :tangle lisp/completion/completion-vertico.el
:END:

#+begin_src emacs-lisp
  ;;; completion-vertico.el --- Vertico minibuffer UI -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf vertico :straight t
    :global-minor-mode vertico-mode
    :custom ((vertico-count . 15)))

  (leaf vertico-posframe :straight t
    :if (display-graphic-p)
    :after vertico
    :custom ((vertico-posframe-border-width . 2))
    :config (vertico-posframe-mode 1))

  (leaf marginalia :straight t
    :global-minor-mode marginalia-mode)

  (provide 'completion/completion-vertico)
#+end_src

*** completion/completion-consult.el
:PROPERTIES:
:CUSTOM_ID: completion-consult
:header-args:emacs-lisp: :tangle lisp/completion/completion-consult.el
:END:

#+begin_src emacs-lisp
  ;;; completion-consult.el --- Consult search/navigation -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf consult :straight t
    :custom
    ((xref-show-xrefs-function . #'consult-xref)
     (xref-show-definitions-function . #'consult-xref)))

  (provide 'completion/completion-consult)
#+end_src

*** completion/completion-embark.el
:PROPERTIES:
:CUSTOM_ID: completion-embark
:header-args:emacs-lisp: :tangle lisp/completion/completion-embark.el
:END:

#+begin_src emacs-lisp
  ;;; completion-embark.el --- Embark actions -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf embark :straight t
    :custom ((prefix-help-command . #'embark-prefix-help-command)))

  (leaf embark-consult :straight t
    :after (embark consult)
    :hook (embark-collect-mode . consult-preview-at-point-mode))

  (provide 'completion/completion-embark)
#+end_src

*** completion/completion-corfu.el
:PROPERTIES:
:CUSTOM_ID: completion-corfu
:header-args:emacs-lisp: :tangle lisp/completion/completion-corfu.el
:END:

#+begin_src emacs-lisp
  ;;; completion/completion-corfu.el --- Corfu popup completion module -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: completion
  ;;
  ;;; Commentary:
  ;; Corfu-based in-buffer completion with sensible defaults.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf corfu
    :straight t
    :init
     (setq tab-always-indent 'complete)
    (global-corfu-mode)
    :custom ((corfu-auto . t)
             (corfu-cycle . t)))

  (leaf kind-icon :straight t
    :after corfu
    :require t
    :custom ((kind-icon-default-face . 'corfu-default))
    :config (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (leaf cape
    :straight t
    :init
    (require 'cape)
    :config
    (add-to-list 'completion-at-point-functions #'cape-symbol)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev))

  (provide 'completion/completion-corfu)
  ;;; completion/completion-corfu.el ends here
#+end_src

*** completion/completion-icons.el
:PROPERTIES:
:CUSTOM_ID: completion-corfu
:header-args:emacs-lisp: :tangle lisp/completion/completion-icons.el
:END:

#+begin_src emacs-lisp
  ;;; completion-icons.el --- Nerd icons for completion -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf nerd-icons-ibuffer :straight t
    :hook (ibuffer-mode-hook . nerd-icons-ibuffer-mode))

  (leaf nerd-icons-completion :straight t
    :hook (marginalia-mode-hook . nerd-icons-completion-marginalia-setup)
    :config (nerd-icons-completion-mode))

  (setq marginalia-align 'right)

  (provide 'completion/completion-icons)
#+end_src

*** orgx/org-core.el
:PROPERTIES:
:CUSTOM_ID: orgx-core
:header-args:emacs-lisp: :tangle lisp/orgx/org-core.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-core.el --- Org Mode core configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'cl-lib))

  (defvar my:d:org (expand-file-name "org" my:d:var))
  (defvar my:d:org-journal (expand-file-name "journal" my:d:org))
  (defvar my:d:org-roam (expand-file-name "org-roam" my:d:org))
  (defvar my:d:org-pictures (expand-file-name "pictures" my:d:org))
  (defvar my:f:capture-blog-file (expand-file-name "blog.org" my:d:org))

  (my/ensure-directory-exists my:d:org)
  (my/ensure-directory-exists my:d:org-journal)
  (my/ensure-directory-exists my:d:org-roam)
  (my/ensure-directory-exists my:d:org-pictures)

  (defun my/org-buffer-files ()
    "Return a list of *.org files currently visited in live buffers."
    (cl-loop for buf in (buffer-list)
             for file = (buffer-file-name buf)
             when (and file (string-match-p "\\.org\\'" file))
             collect file))

  (leaf org
    :straight nil
    :custom
    ((org-directory . my:d:org)
     (org-default-notes-file . "notes.org")
     (org-log-done . 'time)
     (org-support-shift-select . t)
     (org-return-follows-link . t))
    :config
    ;; NOTE: my:d:org/notes/ is intentionally excluded from org-agenda-files (prose-only Markdown domain).
    (setq org-agenda-files
          (seq-filter (lambda (file)
                        (and (string-match-p "\\.org$" file)
                             (not (string-match-p "archives" file))))
                      (directory-files-recursively org-directory "\\.org$")))
    (unless org-agenda-files
      (setq org-agenda-files (list (expand-file-name "inbox.org" org-directory))))
    (setq org-todo-keywords
          '((sequence "TODO(t)" "SOMEDAY(s)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c@)")))
    (setq org-refile-targets
          '((nil :maxlevel . 3)
            (my/org-buffer-files :maxlevel . 1)
            (org-agenda-files :maxlevel . 3)))
    (setq org-capture-templates
          `(("t" "Todo" entry (file+headline ,(expand-file-name "gtd.org" org-directory) "Inbox")
             "* TODO %?\n %i\n %a")
            ("n" "Note" entry (file+headline ,(expand-file-name "notes.org" org-directory) "Notes")
             "* %?\nEntered on %U\n %i\n %a")
            ("j" "Journal" entry (function org-journal-find-location)
             "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
            ("m" "Meeting" entry (file ,(expand-file-name "meetings.org" org-directory))
             "* MEETING with %? :meeting:\n  %U\n  %a"))))

  (with-eval-after-load 'org
    (let* ((central (expand-file-name "archive.org" (or (bound-and-true-p org-directory)
                                                       (expand-file-name "~/org")))))
      (setopt org-archive-location (concat central "::"))))

  (provide 'orgx/org-core)
  ;;; orgx/org-core.el ends here
#+end_src

*** orgx/org-visual.el
:PROPERTIES:
:CUSTOM_ID: orgx-visual
:header-args:emacs-lisp: :tangle lisp/orgx/org-visual.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-visual.el --- Org Mode visual enhancements -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf org-modern
    :straight t
    :hook (org-mode . org-modern-mode)
    :custom
    ((org-startup-indented . t)
     (org-hide-leading-stars . t)
     (org-auto-align-tags . nil)
     (org-tags-column . 0)
     (org-catch-invisible-edits . 'show-and-error)
     (org-special-ctrl-a/e . t)
     (org-insert-heading-respect-content . t)
     (org-hide-emphasis-markers . t)
     (org-pretty-entities . t)
     ;; TODO faces (variable, not face)
     (org-modern-todo-faces
      . '(("TODO"    :background "#673AB7" :foreground "#f8f8f2")
  	("SOMEDAY" :background "#6b7280" :foreground "#f8f8f2")
  	("WAITING" :background "#6272a4" :foreground "#f8f8f2")
  	("DONE"    :background "#373844" :foreground "#b0b8d1")
  	("CANCELED":background "#4b5563" :foreground "#e5e7eb")))
     ;; Nerd Font icons
     (org-modern-list          . '((?+ . "‚ó¶") (?- . "‚Äì") (?* . "‚Ä¢")))
     (org-modern-checkbox      . '((?X . "Ôò´") (?- . "ÔÑÅ") (?\s . "Ôò∞")))
     (org-modern-priority      . '((?A . "Ôö§") (?B . "ÔÑÇ") (?C . "ÔÑÜ")))
     (org-modern-replace-stars . "ÔàôÔ¢§Ô¢ßÔ¢™Ô¢≠Ô¢∞Ô¢≥Ô¢∂Ô¢πÔ¢º")
     ;; Agenda
     (org-agenda-tags-column . 0)
     (org-agenda-block-separator . ?‚îÄ)
     (org-agenda-time-grid
      . '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ " " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ "))
     (org-agenda-current-time-string
      . "‚≠† now ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")))

  (provide 'orgx/org-visual)
  ;;; org-visual.el ends here
#+end_src

*** orgx/org-extensions.el
:PROPERTIES:
:CUSTOM_ID: orgx-extensions
:header-args:emacs-lisp: :tangle lisp/orgx/org-extensions.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-extensions.el --- Org Mode extensions -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf org-journal :straight t
    :custom ((org-journal-dir . my:d:org-journal)))

  (leaf org-roam :straight t
    :custom ((org-roam-directory . my:d:org-roam))
    ;; NOTE: do NOT start autosync immediately at after-init; it can race with
    ;; iCloud/network FS and cause read timeouts on large/remote files.
    :config
    (setq org-roam-db-location (expand-file-name "org-roam.db" my:d:org-roam))

    ;; 1) Guard: never crash on file read timeout during hashing
    (defun orgx--org-roam-file-hash-guard (orig file)
      "Guard `org-roam-db--file-hash' against file read timeouts.
  Return nil on failure to skip the problematic file."
      (condition-case err
          (funcall orig file)
        (file-error
         (message "[org-roam] skip hash (file-error): %s (%s)"
                  file (error-message-string err))
         nil)
        (error
         (message "[org-roam] skip hash (error): %s (%s)"
                  file (error-message-string err))
         nil)))

    (with-eval-after-load 'org-roam
      ;; internal function, but advice is narrow and defensive
      (when (fboundp 'org-roam-db--file-hash)
        (advice-add 'org-roam-db--file-hash :around #'orgx--org-roam-file-hash-guard)))

    ;; 2) Delay autosync: start after Emacs becomes idle
    (run-with-idle-timer
     5 nil
     (lambda ()
       (when (fboundp 'org-roam-db-autosync-mode)
         (org-roam-db-autosync-mode 1)
         (message "[org-roam] autosync enabled (delayed)")))))

  (leaf org-download :straight t
    :custom ((org-download-enableorg-download-image-dir . my:d:org-pictures)))

  (leaf toc-org :straight t
    :hook ((org-mode . toc-org-enable)
           (markdown-mode . toc-org-mode)))

  (leaf org-cliplink :straight t)

  (provide 'orgx/org-extensions)
  ;;; orgx/org-extensions.el ends here
#+end_src

*** orgx/org-export.el
:PROPERTIES:
:CUSTOM_ID: orgx-export
:header-args:emacs-lisp: :tangle lisp/orgx/org-export.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-export.el --- Org export configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;; Commentary:
  ;; Org export configuration: LaTeX, Hugo, Markdown.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf ox-hugo :straight t
    :after ox
    :custom ((org-hugo-front-matter-format . "toml")))

  (leaf *ox-hugo--capture
    :require (org-capture org-id)   ;; ensure both are available
    :preface
    ;; Pure Emacs Lisp, newline-free, portable
    (defun my/ox-hugo-generate-safe-filename ()
      "Return a safe Hugo filename like \"YYYYMMDD-xxxxxxxx\".
  It uses `org-id-uuid' and trims to 8 hex chars for stability."
      (let ((date (format-time-string "%Y%m%d"))
            (short (substring (org-id-uuid) 0 8))) ; no newline, pure Elisp
        (format "%s-%s" date short)))

    ;; Optional: where to capture (declare your path elsewhere if you prefer)
    ;; (defvar my:f:capture-blog-file "~/notes/blog.org")

    :config
    (defvar org-capture-templates) ; silence byte-compiler if needed

    ;; Insert (or replace) the "b" template
    (add-to-list
     'org-capture-templates
     `("b" "Blog (Hugo) - new post" entry
       (file+olp ,(or (bound-and-true-p my:f:capture-blog-file)
                      (user-error "Set `my:f:capture-blog-file' to your blog Org file"))
                 "blog")
       ,(concat
         "** TODO %^{Title}\n"
         ":PROPERTIES:\n"
         "  :EXPORT_FILE_NAME: %(my/ox-hugo-generate-safe-filename)\n"
         "  :EXPORT_DATE: %(format-time-string \"%Y-%m-%dT%T%z\")\n"
         "  :EXPORT_HUGO_TAGS: %^{Tags|emacs}\n"
         "  :EXPORT_HUGO_CATEGORIES: %^{Category|blog}\n"
         "  :EXPORT_HUGO_LASTMOD: %(format-time-string \"%Y-%m-%dT%T%z\")\n"
         "  :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pin false\n"
         "  :END:\n\n"
         "%?\n")
       :empty-lines 1 :prepend t)))

  (leaf markdown-mode :straight t)
  (leaf markdown-preview-mode :straight t)
  (leaf edit-indirect :straight t)

  ;; Mermaid
  (leaf ob-mermaid
    :straight t
    :after org
    :config
    ;; Explicitly set the mmdc path (unnecessary if it's already on PATH).
    (when (executable-find "mmdc")
      (setq ob-mermaid-cli-path (executable-find "mmdc")))
    ;; Register Mermaid with Org Babel.
    (org-babel-do-load-languages
     'org-babel-load-languages
     (append org-babel-load-languages '((mermaid . t)))))

  ;; Graphviz (dot) is built into Org.
  (leaf ob-dot
    :straight nil
    :after org
    :config
    ;; Register Graphviz (dot) with Org Babel.
    (org-babel-do-load-languages
     'org-babel-load-languages
     (append org-babel-load-languages '((dot . t)))))

  (defun my/f:capture-blog-file-open ()
    "Open blog capture Org file."
    (interactive)
    (find-file my:f:capture-blog-file))

  (defun my/org-hugo-draft-entries ()
    "Return list of draft Hugo entries.
  Each element is (title file position)."
    (let (results)
      (dolist (file my:f:capture-blog-file)
        (with-current-buffer (find-file-noselect file)
          (org-map-entries
           (lambda ()
             (let ((draft (org-entry-get nil "EXPORT_HUGO_DRAFT")))
               (when (string= draft "true")
                 (push (list
                        (nth 4 (org-heading-components))
                        file
                        (point))
                       results))))
           nil 'file)))
      (nreverse results)))

  (defun my/hugo-weekly-review ()
    "Show weekly review buffer for draft Hugo posts."
    (interactive)
    (let ((drafts (my/org-hugo-draft-entries)))
      (with-current-buffer (get-buffer-create "*Hugo Weekly Review*")
        (read-only-mode -1)
        (erase-buffer)
        (insert (format "# Hugo Weekly Review (%s)\n\n"
                        (format-time-string "%Y-%m-%d")))
        (if drafts
            (dolist (entry drafts)
              (pcase-let ((`(,title ,file ,pos) entry))
                (insert (format "- [[file:%s::%d][%s]]\n"
                                file pos title))))
          (insert "No draft posts. üéâ\n"))
        (org-mode)
        (goto-char (point-min))
        (read-only-mode 1)
        (pop-to-buffer (current-buffer)))))


  (provide 'orgx/org-export)
  ;;; org-export.el ends here
#+end_src

*** orgx/org-typography.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/orgx/org-typography.el
:END:
#+begin_src emacs-lisp
  ;;; orgx/org-typography.el --- Org modern typography extras -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Complements your existing orgx/org-visual.el (org-modern) without overlap.

  (eval-when-compile (require 'leaf))

  ;; ;; Use variable-pitch for prose buffers (keeps code blocks monospaced)
  ;; (leaf org :straight nil
  ;;   :hook (org-mode-hook . variable-pitch-mode))

  ;; Align tables & inline images nicely
  (leaf valign
    :straight t
    :hook (org-mode-hook . valign-mode))

  ;; Smoothly reveal emphasis markers, links, etc.
  (leaf org-appear
    :straight t
    :hook (org-mode-hook . org-appear-mode)
    :init (setq org-appear-autoemphasis t
                org-appear-autolinks t
                org-appear-autosubmarkers t))

  (provide 'orgx/org-typography)
  ;;; orgx/org-typography.el ends here
#+end_src

*** vcs/vcs-magit.el
:PROPERTIES:
:CUSTOM_ID: vcs-magit
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-magit.el
:END:

#+begin_src emacs-lisp
  ;;; vcs/vcs-magit.el --- Git integration with Magit -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: vcs
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf magit
    :straight t
    ;; Lazy-load: bind entry points only
    :commands (magit-status magit-dispatch)
    :init
    ;; Keep Magit's auto-revert behavior opt-in; avoid eager side effects at load time
    (setq magit-auto-revert-mode nil)
    :config
    ;; Small quality-of-life tweaks (safe defaults)
    (setq magit-refresh-status-buffer nil     ; avoid extra refresh churn
          magit-diff-refine-hunk 'all))      ; inline word-diff for clarity

  (provide 'vcs/vcs-magit)
  ;;; vcs/vcs-magit.el ends here
#+end_src

*** vcs/vcs-gutter.el
:PROPERTIES:
:CUSTOM_ID: vcs-gutter
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-gutter.el
:END:

#+begin_src emacs-lisp
  ;;; vcs/vcs-gutter.el --- Show Git changes in fringe -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: vcs
  ;;
  ;;; Commentary:
  ;; Use `diff-hl` as the sole fringe indicator. Integrates with Magit refresh.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf diff-hl
    :straight t
    :commands (diff-hl-mode diff-hl-dired-mode diff-hl-magit-post-refresh)
    :hook
    ;; Enable indicators only when entering relevant modes
    ((prog-mode . diff-hl-mode)
     (text-mode . diff-hl-mode)
     (dired-mode . diff-hl-dired-mode))
    :config
    ;; Integrate with Magit after it's available (no hard require)
    (with-eval-after-load 'magit
      (add-hook 'magit-post-refresh #'diff-hl-magit-post-refresh))
    (customize-set-variable 'diff-hl-draw-borders nil))

  (provide 'vcs/vcs-gutter)
  ;;; vcs/vcs-gutter.el ends here
#+end_src

*** vcs/vcs-forge.el
:PROPERTIES:
:CUSTOM_ID: vcs-forge
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-forge.el
:END:

#+begin_src emacs-lisp
  ;;; vcs/vcs-forge.el --- GitHub/GitLab integration via Forge -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: vcs
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; Fallbacks when no-littering/utility helpers are not present
  (defvar no-littering-var-directory
    (expand-file-name ".var/" user-emacs-directory)
    "Fallback var directory used when no-littering is not loaded.")
  (unless (file-directory-p no-littering-var-directory)
    (make-directory no-littering-var-directory t))

  (unless (fboundp 'my/ensure-directory-exists)
    (defun my/ensure-directory-exists (dir)
      "Create DIR recursively if it does not exist."
      (unless (file-directory-p dir) (make-directory dir t))))

  (leaf forge
    :straight t
    :after magit
    :init
    ;; Prefer built-in SQLite in Emacs 29+ to avoid external deps
    (with-eval-after-load 'emacsql
      (when (boundp 'emacsql-sqlite3-executable)
        (setq emacsql-sqlite3-executable nil))) ; force builtin backend when available
    :config
    ;; Place Forge DB under var dir; ensure parent exists
    (let* ((db-dir (expand-file-name "forge" no-littering-var-directory))
           (db     (expand-file-name "forge-database.sqlite" db-dir)))
      (my/ensure-directory-exists db-dir)
      (setq forge-database-file db)))

  (provide 'vcs/vcs-forge)
  ;;; vcs/vcs-forge.el ends here
#+end_src

*** dev/dev-lsp-eglot.el
:PROPERTIES:
:CUSTOM_ID: dev-lsp-eglot
:header-args:emacs-lisp: :tangle lisp/dev/dev-lsp-eglot.el
:END:

#+begin_src emacs-lisp
  ;;; dev-lsp-eglot.el --- Eglot setup -*- lexical-binding: t; -*-
  ;;
  ;; Category: dev
  ;;
  ;;; Commentary:
  ;; Eglot baseline with safe auto-enable. Tries to detect a contact *if the
  ;; installed Eglot exposes the helper*, but does not hard-depend on
  ;; private/internal symbols.

  (eval-when-compile (require 'leaf))

  (defun my/eglot-guessable-p ()
    "Return non-nil if current buffer seems to have an LSP server we can start.
  This does **not** error even if Eglot changed its private API."
    (cond
     ;; When the current/older Eglot exposes the internal helper.
     ((fboundp 'eglot--guess-contact)
      (ignore-errors (eglot--guess-contact)))
     ;; When a future Eglot exposes a public \"guess\" helper.
     ((fboundp 'eglot-guess-contact)
      (ignore-errors (eglot-guess-contact)))
     ;; Otherwise, let the caller decide whether to start Eglot anyway.
     (t nil)))

  (leaf eglot
    :straight t
    :commands (eglot eglot-ensure)
    :custom ((eglot-autoreconnect . t))
    :hook ((prog-mode . (lambda ()
                          (when (my/eglot-guessable-p)
                            (eglot-ensure))))))

  ;;;###autoload
  (defun my/lsp-enable-eglot ()
    "Enable Eglot-based LSP setup."
    (interactive)
    (add-hook 'prog-mode-hook
              (lambda ()
                (when (my/eglot-guessable-p)
                  (eglot-ensure))))
    (message "[lsp] Eglot enabled."))

  (provide 'dev/dev-lsp-eglot)
  ;;; dev-lsp-eglot.el ends here
#+end_src

*** dev/dev-lsp-mode.el
:PROPERTIES:
:CUSTOM_ID: dev-lsp-mode
:header-args:emacs-lisp: :tangle lisp/dev/dev-lsp-mode.el
:END:

#+begin_src emacs-lisp
;;; dev-lsp-mode.el --- lsp-mode setup -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2026
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;
;; Category: dev
;;
;;; Commentary:
;; lsp-mode baseline + lsp-ui. Completion is delegated to Corfu.
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf lsp-mode
  :straight t
  :commands (lsp lsp-deferred)
  :custom ((lsp-keymap-prefix . "C-c l")
           (lsp-enable-file-watchers . t)
           (lsp-file-watch-threshold . 5000)
           (lsp-response-timeout . 5)
           (lsp-diagnostics-provider . :auto)
           (lsp-completion-provider . :none))
  :hook ((prog-mode . lsp-deferred)))

(leaf lsp-ui
  :straight t
  :after lsp-mode
  :custom ((lsp-ui-doc-enable . t)
           (lsp-ui-doc-delay . 0.2)
           (lsp-ui-sideline-enable . t)))

;;;###autoload
(defun my/lsp-enable-lspmode ()
  "Enable lsp-mode-based LSP setup."
  (interactive)
  (add-hook 'prog-mode-hook #'lsp-deferred)
  (message "[lsp] lsp-mode enabled."))

(provide 'dev/dev-lsp-mode)
;;; dev-lsp-mode.el ends here
#+end_src

*** dev/dev-ai.el
:PROPERTIES:
:CUSTOM_ID: dev-ai
:header-args:emacs-lisp: :tangle lisp/dev/dev-ai.el
:END:

#+begin_src emacs-lisp
  ;;; dev/dev-ai.el --- AI-assisted development -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; AI-assisted coding via Aidermacs.
  ;;
  ;; Purpose: Centralize aider/Aidermacs runtime files into ~/.var/aideremacs
  ;; Notes:
  ;; - Uses official AIDER_* env vars so both CLI and Aidermacs obey.
  ;; - Safe to load early (e.g. in personal/user.el or core/general.el).
  ;; - pip3 install aider-ce
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf)
  		   (require 'subr-x))

  ;; 1) Decide base directory: ~/.var/aideremacs
  (defvar my:d:aider
    (expand-file-name "aideremacs/" (or (bound-and-true-p my:d:var)
                                        (expand-file-name "~/.var/")))
    "Base directory to store aider runtime files.")

  ;; 2) Ensure directory exists
  (my/ensure-directory-exists my:d:aider)

  ;; 3) Point aider history files to this directory via env vars
  ;;    (aider recognizes these officially)
  (setenv "AIDER_INPUT_HISTORY_FILE" (expand-file-name "input.history" my:d:aider))
  (setenv "AIDER_CHAT_HISTORY_FILE"  (expand-file-name "chat.history.md" my:d:aider))
  (setenv "AIDER_LLM_HISTORY_FILE"   (expand-file-name "llm.history" my:d:aider))
  ;; Optional: analytics log location if you enable analytics logging
  (setenv "AIDER_ANALYTICS_LOG"      (expand-file-name "analytics.log" my:d:aider))

  ;; 4) [Optional] Keep a per-user .env here and make aider load it.
  ;;    You can create ~/.var/aideremacs/.env and put API keys / options there.
  ;;    If you use Aidermacs, pass --env-file via its extra args.
  (with-eval-after-load 'aidermacs
    ;; Aidermacs exposes an extra-args variable in recent builds
    ;; (see NonGNU ELPA diffs mentioning `aidermacs-extra-args`).
    ;; If your installed version still uses `aidermacs-args`, switch the name.
    (defvar aidermacs-extra-args nil)
    (let ((env-file (expand-file-name ".env" my:d:aider)))
      (when (file-exists-p env-file)
        (setq aidermacs-extra-args
              (append aidermacs-extra-args
                      (list "--env-file" env-file)))))

    ;; Redundancy is harmless: also force the same files via CLI flags,
    ;; in case your shell environment overrides Emacs' setenv.
    (setq aidermacs-extra-args
          (append aidermacs-extra-args
                  (list "--input-history-file" (getenv "AIDER_INPUT_HISTORY_FILE")
                        "--chat-history-file"  (getenv "AIDER_CHAT_HISTORY_FILE")
                        "--llm-history-file"   (getenv "AIDER_LLM_HISTORY_FILE")))))

  (leaf aidermacs :straight t
    :init
    (cond
     ((getenv "OPENROUTER_API_KEY")
      (setenv "OPENAI_API_BASE" "https://openrouter.ai/api/v1")
      (setenv "OPENAI_API_KEY"  (getenv "OPENROUTER_API_KEY"))
      (setopt aidermacs-default-model "openrouter/anthropic/claude-3.5-sonnet"))
     ((getenv "OPENAI_API_KEY")
      (setenv "OPENAI_API_BASE" "https://api.openai.com/v1")
      (setopt aidermacs-default-model "gpt-4o-mini"))
     (t
      (display-warning 'aidermacs
                       "No API keys set. Set OPENROUTER_API_KEY or OPENAI_API_KEY.")))
    (setopt aidermacs-retry-attempts 3
            aidermacs-retry-delay   2.0
            aidermacs-backend       'vterm))

  (provide 'dev/dev-ai)
  ;;; dev/dev-ai.el ends here
#+end_src

*** dev/dev-term.el
:PROPERTIES:
:CUSTOM_ID: dev-term
:header-args:emacs-lisp: :tangle lisp/dev/dev-term.el
:END:

#+begin_src emacs-lisp
  ;;; dev/dev-term.el --- Terminal integration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Uses ui/ui-nano-palette as the single source of truth for colors.
  ;; Avoid :custom-face (can trigger ‚ÄúAttempt modify constant ‚Ä¶‚Äù with leaf).
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'cl-lib))

  ;; Palette is provided by the caller's load-path setup.
  (require 'ui/ui-nano-palette)

  (defun my/vterm-apply-palette ()
    "Apply nano-style palette to vterm faces safely and compatibly.
  Some vterm builds don't define `vterm-color-default`; use `vterm` face instead."
    ;; Fallbacks (in case palette wasn't set yet)
    (defvar nano-color-foreground "#374151")
    (defvar nano-color-background "#fafafa")
    (defvar nano-color-salient    "#2563eb")
    (defvar nano-color-popout     "#6b7280")
    (defvar nano-color-critical   "#dc2626")
    (defvar nano-color-strong     "#111827")
    (defvar nano-color-faded      "#9ca3af")
    (defvar nano-color-subtle     "#e5e7eb")

    (cl-labels
        ((safe-face-set (face &rest props)
           (when (facep face)
             (apply #'set-face-attribute face nil props))))

      ;; Default fg/bg: prefer vterm-color-default; fall back to vterm
      (if (facep 'vterm-color-default)
          (safe-face-set 'vterm-color-default
                         :foreground nano-color-foreground
                         :background nano-color-background)
        (safe-face-set 'vterm
                       :foreground nano-color-foreground
                       :background nano-color-background))

      ;; 8-color palette (keep backgrounds unobtrusive)
      (safe-face-set 'vterm-color-black   :foreground nano-color-strong   :background 'unspecified)
      (safe-face-set 'vterm-color-red     :foreground nano-color-critical :background 'unspecified)
      (safe-face-set 'vterm-color-green   :foreground "#10b981"           :background 'unspecified) ; emerald-500
      (safe-face-set 'vterm-color-yellow  :foreground nano-color-popout   :background 'unspecified)
      (safe-face-set 'vterm-color-blue    :foreground nano-color-salient  :background 'unspecified)
      (safe-face-set 'vterm-color-magenta :foreground "#a21caf"           :background 'unspecified) ; fuchsia-700
      (safe-face-set 'vterm-color-cyan    :foreground "#0891b2"           :background 'unspecified) ; cyan-600
      (safe-face-set 'vterm-color-white   :foreground nano-color-subtle   :background 'unspecified)))

  (defun my/vterm-buffer-p (buf)
    "Return non-nil if BUF is a vterm buffer."
    (with-current-buffer buf
      (or (eq major-mode 'vterm-mode)
          (string-prefix-p "*vterm" (buffer-name buf)))))

  (leaf vterm
    :doc  "Emacs libvterm integration"
    :url  "https://github.com/akermu/emacs-libvterm"
    :straight t
    :config
    ;; Apply once vterm is loaded
    (my/vterm-apply-palette)
    ;; Re-apply after theme activation to keep colors consistent
    (with-eval-after-load 'cus-theme
      (if (boundp 'enable-theme-functions)
          (add-hook 'enable-theme-functions #'my/vterm-apply-palette)
        (advice-add 'enable-theme :after (lambda (&rest _) (my/vterm-apply-palette))))))

  (leaf vterm-toggle
    :doc  "Toggle between vterm and the current buffer"
    :url  "https://github.com/jixiuf/vterm-toggle"
    :straight t
    :custom
    (vterm-toggle-cd-auto-create-buffer . t)
    (vterm-toggle-fullscreen-p          . nil)
    (vterm-toggle-scope                 . 'project))

  ;; Buffer display rule must be set after vterm is available
  (with-eval-after-load 'vterm
    (add-to-list 'display-buffer-alist
                 `(my/vterm-buffer-p
                   (display-buffer-reuse-window display-buffer-in-direction)
                   (direction       . bottom)
                   (dedicated       . t)
                   (reusable-frames . visible)
                   (window-height   . 0.3))))

  (provide 'dev/dev-term)
  ;;; dev/dev-term.el ends here
#+end_src

*** dev/dev-build.el
:PROPERTIES:
:CUSTOM_ID: dev-build
:header-args:emacs-lisp: :tangle lisp/dev/dev-build.el
:END:

#+begin_src emacs-lisp
  ;;; dev/dev-build.el --- Build & Makefile tools -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Build system integration.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf make-mode :straight nil
    :mode (("\\`Makefile\\'"    . makefile-gmake-mode)
           ("\\`GNUmakefile\\'" . makefile-gmake-mode)
           ("\\`makefile\\'"    . makefile-gmake-mode))
    :hook ((makefile-mode . (lambda ()
                              (setq-local indent-tabs-mode t
                                          tab-width 8
                                          show-trailing-whitespace t))))
    :config
    (leaf compile :straight nil
      :custom ((compilation-scroll-output . t)
               (compilation-skip-threshold . 2))
      :init
      (defun my/set-make-compile-command ()
        "Use `make -k` when Makefile is present."
        (when (or (derived-mode-p 'makefile-mode)
                  (locate-dominating-file default-directory "Makefile")
                  (locate-dominating-file default-directory "GNUmakefile"))
          (setq-local compile-command "make -k")))
      (add-hook 'after-change-major-mode-hook #'my/set-make-compile-command))
    (leaf ansi-color :straight nil
      :hook (compilation-filter . (lambda ()
                                    (let ((inhibit-read-only t))
                                      (ansi-color-apply-on-region compilation-filter-start (point-max)))))))

  (provide 'dev/dev-build)
  ;;; dev/dev-build.el ends here
#+end_src

*** dev/dev-docker.el
:PROPERTIES:
:CUSTOM_ID: dev-docker
:header-args:emacs-lisp: :tangle lisp/dev/dev-docker.el
:END:

#+begin_src emacs-lisp
  ;;; dev/dev-docker.el --- Docker integration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Docker development support.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf dockerfile-mode :straight t
    :mode (("Dockerfile\\(\\..*\\)?\\'" . dockerfile-mode)
           ("\\.dockerfile\\'"         . dockerfile-mode))
    :custom ((dockerfile-mode-command . "docker")))

  (leaf yaml-mode :straight t
    :mode (("\\`docker-compose.*\\.ya?ml\\'" . yaml-mode)
           ("\\.ya?ml\\'"                   . yaml-mode)))

  (leaf docker :straight t
    :commands (docker docker-containers docker-images docker-volumes docker-networks))

  (leaf tramp-container :straight nil
    :after tramp
    :init
    (setq tramp-container-method "docker"))

  (leaf tempel :straight t
    :commands (tempel-insert)
    :init
    (with-eval-after-load 'tempel
      (defvar my:tempel-docker-templates
        '((dockerfile "FROM " p n
                      "WORKDIR /app" n
                      "COPY . /app" n
                      "RUN " p n
                      "CMD [" p "]" n)))
      (add-to-list 'tempel-user-elements my:tempel-docker-templates)))

  (provide 'dev/dev-docker)
  ;;; dev/dev-docker.el ends here
#+end_src

*** dev/web-core.el
:PROPERTIES:
:CUSTOM_ID: dev-web-core
:header-args:emacs-lisp: :tangle lisp/dev/web-core.el
:END:

#+begin_src emacs-lisp
  ;;; web-core.el --- Treesit & project core -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Core configuration for project management and modern syntax highlighting.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf project :straight nil)
  (leaf files   :straight nil
    :custom ((require-final-newline . t)
             (delete-trailing-lines . t))
    :hook ((before-save-hook . delete-trailing-whitespace)))

  (leaf editorconfig
    :straight t
    :global-minor-mode t)

  (leaf treesit
    :straight nil
    :custom ((major-mode-remap-alist
              . '((typescript-mode . typescript-ts-mode)
                  (js-mode         . js-ts-mode)
                  (json-mode       . json-ts-mode)
                  (css-mode        . css-ts-mode)
                  (yaml-mode       . yaml-ts-mode)
                  (sh-mode         . bash-ts-mode)))))

  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'"  . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))

  (provide 'dev/web-core)
  ;;; web-core.el ends here
#+end_src

*** dev/format.el
:PROPERTIES:
:CUSTOM_ID: dev-format
:header-args:emacs-lisp: :tangle lisp/dev/format.el
:END:

#+begin_src emacs-lisp
  ;;; format.el --- Prettier/ESLint via Apheleia -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf apheleia
    :straight t
    :require t
    :config
    (setf (alist-get 'prettierd apheleia-formatters)
          '("prettierd" filepath))
    (setf (alist-get 'prettier apheleia-formatters)
          '("npx" "prettier" "--stdin-filepath" filepath))
    (dolist (pair '((typescript-ts-mode . prettierd)
                    (tsx-ts-mode        . prettierd)
                    (json-ts-mode       . prettierd)
                    (css-ts-mode        . prettierd)
                    (markdown-mode      . prettierd)))
      (add-to-list 'apheleia-mode-alist pair))
    (apheleia-global-mode +1))

  (provide 'dev/format)
  ;;; format.el ends here
#+end_src

*** dev/infra-modes.el
:PROPERTIES:
:CUSTOM_ID: dev-infra-modes
:header-args:emacs-lisp: :tangle lisp/dev/infra-modes.el
:END:

#+begin_src emacs-lisp
  ;;; infra-modes.el --- Infra modes (.env / Compose / TOML / Make) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Syntax support for infra files such as Docker Compose, .env, TOML, and Makefiles.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf docker-compose-mode :straight t :mode ("docker-compose\\.*ya?ml\\'"))
  (leaf dotenv-mode :straight t
    :mode (("\\.env\\..*\\'" . dotenv-mode)
           ("\\.env\\'"     . dotenv-mode)))
  (leaf toml-mode :straight t :mode ("\\.toml\\'" . toml-mode))

  (provide 'dev/infra-modes)
  ;;; infra-modes.el ends here
#+end_src

*** dev/sql.el
:PROPERTIES:
:CUSTOM_ID: dev-sql
:header-args:emacs-lisp: :tangle lisp/dev/sql.el
:END:

#+begin_src emacs-lisp
  ;;; lisp/dev/sql.el --- SQL/PostgreSQL helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  (eval-when-compile (require 'leaf))

  (leaf sql :straight nil
    :custom ((sql-product . 'postgres)))

  (leaf sql-indent :straight t
    :hook (sql-mode . sqlind-minor-mode))

  (leaf sqlformat
    :straight t
    :custom ((sqlformat-command . 'pgformatter)
             (sqlformat-args . '("--nostyle")))
    :hook (sql-mode . sqlformat-on-save-mode)
    :hook (sql-ts-mode . sqlformat-on-save-mode))

  (provide 'dev/sql)
  ;;; sql.el ends here
#+end_src

*** dev/rest.el
:PROPERTIES:
:CUSTOM_ID: dev-rest
:header-args:emacs-lisp: :tangle lisp/dev/rest.el
:END:

#+begin_src emacs-lisp
  ;;; rest.el --- REST client helpers (Next.js / Ollama / Qdrant) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; REST client integration for testing HTTP requests inside Emacs.
  ;; Supports JSON parsing with jq.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf restclient :straight t :mode ("\\.http\\'" . restclient-mode))
  (leaf restclient-jq :straight t :after restclient)

  (provide 'dev/rest)
  ;;; dev/rest.el ends here
#+end_src

*** utils/utils-functions.el
:PROPERTIES:
:CUSTOM_ID: utils-functions
:header-args:emacs-lisp: :tangle lisp/utils/utils-functions.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-functions.el --- General utility functions -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Small, safe utilities loaded across the configuration.
  ;; - Org helpers: indirect subtree view, quick sidebar (imenu-list)
  ;; - Editing helpers: smart buffer/window killing
  ;; Notes:
  ;; - Avoid compile warnings by declaring optional deps and vars.
  ;; - Prefer modern Org APIs when available.
  ;;
  ;;; Code:

  ;;;; Built-ins ------------------------------------------------------------------

  (require 'imenu) ;; built-in

  ;;;; Optional deps & vars (for byte-compiler) -----------------------------------

  (eval-when-compile
    (declare-function imenu-list-minor-mode  "imenu-list")
    (declare-function imenu-list-stop-timer  "imenu-list")
    (declare-function imenu-list-display-dwim "imenu-list")
    (declare-function nano-modeline-render   "nano-modeline"))

  ;; Define imenu-list variables to avoid "free variable" warnings when the
  ;; package is not loaded at compile time.
  (defvar imenu-list-after-jump-hook nil
    "Hook run in the source buffer after a jump from imenu-list.")
  (defvar imenu-list-position 'left
    "Window side for imenu-list. Either 'left or 'right.")
  (defvar imenu-list-size 30
    "Width of the imenu-list window.")
  (defvar imenu-list-focus-after-activation t
    "If non-nil, focus imenu-list window after it appears.")
  (defvar imenu-list--displayed-buffer nil
    "The buffer currently displayed by imenu-list.")

  ;;;; Editing helpers -------------------------------------------------------------

  (defun my/kill-buffer-smart ()
    "Kill buffer and window when there are multiple windows; otherwise kill buffer."
    (interactive)
    (if (one-window-p)
        (kill-buffer)
      (kill-buffer-and-window)))

  ;; Backward-compatible alias used elsewhere in the config.
  (defalias 'my/smart-kill-buffer #'my/kill-buffer-smart)

  ;;;; Nano/Modeline helper --------------------------------------------------------

  (defun my/nano-headerline (buf subtitle)
    "Return a header-line string; prefer nano-modeline when available.
  BUF is the buffer whose name to show. SUBTITLE is a short label."
    (let* ((name (if (and buf (buffer-live-p buf))
                     (buffer-name buf)
                   (buffer-name)))
           (extra ""))
      (if (fboundp 'nano-modeline-render)
          (nano-modeline-render nil name subtitle extra)
        (concat "  "
                (propertize name 'face 'mode-line-buffer-id)
                "  " subtitle))))

  ;;;; Org helpers ----------------------------------------------------------------

  (defun my/org-tree-to-indirect-buffer ()
    "Show current Org subtree in an indirect buffer and reveal its content."
    (interactive)
    (when (derived-mode-p 'org-mode)
      (cond
       ((fboundp 'org-fold-show-all) (org-fold-show-all)) ;; Org ‚â• 9.6
       ((fboundp 'org-show-all)      (org-show-all))))    ;; older Org (obsolete)
    (org-tree-to-indirect-buffer))

  (defun my/org-sidebar ()
    "Open an imenu-list sidebar with safe fallbacks and a minimal header-line."
    (interactive)
    (unless (locate-library "imenu-list")
      (user-error
       "imenu-list is not installed. Use M-x package-install RET imenu-list RET"))
    ;; Autoload key entry points to keep startup light.
    (autoload 'imenu-list-minor-mode  "imenu-list" nil t)
    (autoload 'imenu-list-stop-timer  "imenu-list" nil t)
    (autoload 'imenu-list-display-dwim "imenu-list" nil t)

    ;; Reasonable defaults; set the jump hook to something useful.
    (setq imenu-list-after-jump-hook #'recenter
          imenu-list-position 'left
          imenu-list-size 36
          imenu-list-focus-after-activation t)

    ;; If called from an indirect buffer, go back to the base buffer.
    (when (buffer-base-buffer)
      (switch-to-buffer (buffer-base-buffer)))

    ;; Start sidebar and tame timers to avoid unnecessary refresh churn.
    (imenu-list-minor-mode 1)
    (when (fboundp 'imenu-list-stop-timer) (imenu-list-stop-timer))

    ;; Subtle highlight line if a nano face exists.
    (hl-line-mode 1)
    (when (facep 'nano-subtle)
      (face-remap-add-relative 'hl-line :inherit 'nano-subtle))

    ;; Render a safe header-line; avoid calling nano function directly in hl format.
    (setq header-line-format
          `(:eval
            (my/nano-headerline
             ,(when (boundp 'imenu-list--displayed-buffer)
                'imenu-list--displayed-buffer)
             "(outline)")))
    (setq-local cursor-type nil)

    ;; Best-effort display of items.
    (when (fboundp 'imenu-list-display-dwim)
      (imenu-list-display-dwim)))

  (defun my/org-sidebar-toggle ()
    "Toggle the imenu-list sidebar."
    (interactive)
    (let ((win (get-buffer-window "*Ilist*")))
      (if win
          (progn
            (quit-window nil win)
            (when (buffer-base-buffer)
              (switch-to-buffer (buffer-base-buffer))))
        (my/org-sidebar))))

  (provide 'utils/utils-functions)
  ;;; utils/utils-functions.el ends here
#+end_src

*** utils/utils-scratch.el
:PROPERTIES:
:CUSTOM_ID: utils-scratch
:header-args:emacs-lisp: :tangle lisp/utils/utils-scratch.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-scratch.el --- Scratch buffer helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Automatically recreates *scratch* after it is killed.
  ;; The recreated buffer uses `lisp-interaction-mode` and starts with a small header.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf my:scratch-auto-recreate
    :straight nil
    :init
    (defun my/create-scratch-buffer ()
      "Create or reset a `*scratch*` buffer with `lisp-interaction-mode` and a header."
      (let ((buf (get-buffer-create "*scratch*")))
        (with-current-buffer buf
          (lisp-interaction-mode)
          (erase-buffer)
          (insert ";; This is a new *scratch* buffer\n\n"))
        buf))

    (defun my/kill-scratch-buffer-advice (buf)
      "If BUF is *scratch*, recreate it shortly after kill."
      (when (string= (buffer-name buf) "*scratch*")
        ;; Recreate asynchronously to avoid interfering with the kill flow.
        (run-at-time 0 nil #'my/create-scratch-buffer)))

    ;; When any buffer is killed, if it's *scratch*, recreate it.
    (add-hook 'kill-buffer-hook
              (lambda ()
                (my/kill-scratch-buffer-advice (current-buffer)))))

  (provide 'utils/utils-scratch)
  ;;; utils/utils-scratch.el ends here
#+end_src

*** utils/utils-backup.el
:PROPERTIES:
:CUSTOM_ID: utils-backup
:header-args:emacs-lisp: :tangle lisp/utils/utils-backup.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-backup.el --- Backup and auto-save helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Code:

  (defun my/delete-old-backups ()
    "Delete backup files older than 7 days."
    (interactive)
    (let ((backup-dir (concat no-littering-var-directory "backup/"))
          (threshold (- (float-time (current-time)) (* 7 24 60 60))))
      (when (file-directory-p backup-dir)
        (dolist (file (directory-files backup-dir t))
          (when (and (file-regular-p file)
                     (< (float-time (file-attribute-modification-time
                                     (file-attributes file)))
                        threshold))
            (delete-file file))))))

  (add-hook 'emacs-startup-hook #'my/delete-old-backups)

  (provide 'utils/utils-backup)
  ;;; utils/utils-backup.el ends here
#+end_src

*** utils/utils-async.el
:PROPERTIES:
:CUSTOM_ID: utils-async
:header-args:emacs-lisp: :tangle lisp/utils/utils-async.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-async.el --- Async helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Code:

  (defun my/safe-run-async (task)
    "Run TASK asynchronously, catching and reporting any errors."
    (run-at-time 0 nil
                 (lambda ()
                   (condition-case err
                       (funcall task)
                     (error (message "[async] error: %s" err))))))

  (provide 'utils/utils-async)
  ;;; utils/utils-async.el ends here
#+end_src

*** utils/utils-org-agenda.el
:PROPERTIES:
:CUSTOM_ID: utils-org-agenda
:header-args:emacs-lisp: :tangle lisp/utils/utils-org-agenda.el
:END:

**** Purpose

Build `org-agenda-files` using a persistent cache to avoid running
`directory-files-recursively` on every startup or reload.

This module is designed to:

- Prevent startup slowdown as the number of Org files grows
- Remove recursive scanning logic from `personal/user.el`
- Make agenda selection rules explicit and reusable

**** Design

- All scanning logic lives in `utils/`
- Results are cached under `user-emacs-directory`
- Cached data is reused in *O(1)* time
- Full rescans happen only when explicitly requested

**** What this module does

- Recursively scans `org-directory` for `*.org` files
- Excludes files whose paths match a configurable regexp (default: `archives`)
- Stores the resulting file list in a cache file
- Returns a list suitable for `org-agenda-files`

**** What this module does NOT do

- Define `org-directory`
- Automatically set `org-agenda-files`
- Register hooks, timers, or background jobs

**** Usage

Normal operation (use cache):

#+begin_src emacs-lisp :tangle no
(setq org-agenda-files (utils-org-agenda-build))
#+end_src

Force cache rebuild:

#+begin_src emacs-lisp :tangle no
M-x utils-org-agenda-rebuild
#+end_src

**** Implementation

#+begin_src emacs-lisp
  ;;; utils-org-agenda.el --- Cached org-agenda-files builder -*- lexical-binding: t; -*-
  ;;
  ;; Purpose:
  ;; - Build org-agenda-files with caching
  ;; - Avoid full recursive scans on every startup
  ;;
  ;;; Code:

  (require 'subr-x)
  (require 'seq)

  (defgroup utils-org-agenda nil
    "Cached org-agenda-files builder."
    :group 'org)

  (defcustom utils-org-agenda-cache-file
    (expand-file-name "org-agenda-files.cache"
                      user-emacs-directory)
    "Cache file for org-agenda-files."
    :type 'file
    :group 'utils-org-agenda)

  (defcustom utils-org-agenda-exclude-regexp
    "archives"
    "Regexp used to exclude files from org-agenda."
    :type 'regexp
    :group 'utils-org-agenda)

  (defun utils-org-agenda--scan (org-directory)
    "Recursively scan ORG-DIRECTORY and return a list of agenda files."
    (seq-filter
     (lambda (file)
       (and (string-match-p "\\.org\\'" file)
            (not (string-match-p utils-org-agenda-exclude-regexp file))))
     (directory-files-recursively org-directory "\\.org\\'")))

  (defun utils-org-agenda--load-cache ()
    "Load cached agenda files from disk."
    (when (file-readable-p utils-org-agenda-cache-file)
      (with-temp-buffer
        (insert-file-contents utils-org-agenda-cache-file)
        (read (current-buffer)))))

  (defun utils-org-agenda--save-cache (files)
    "Save FILES to the agenda cache."
    (with-temp-file utils-org-agenda-cache-file
      (prin1 files (current-buffer))))

  ;;;###autoload
  (defun utils-org-agenda-build (&optional force)
    "Return agenda files using the cache.
  If FORCE is non-nil, rebuild the cache."
    (let ((cached (and (not force)
                       (utils-org-agenda--load-cache))))
      (if (and cached (listp cached))
          cached
        (let ((files (utils-org-agenda--scan org-directory)))
          (utils-org-agenda--save-cache files)
          files))))

  ;;;###autoload
  (defun utils-org-agenda-rebuild ()
    "Force a rebuild of the org-agenda-files cache."
    (interactive)
    (setq org-agenda-files (utils-org-agenda-build t))
    (message "org-agenda-files cache rebuilt (%d files)"
             (length org-agenda-files)))

  (provide 'utils/utils-org-agenda)
  ;;; utils-org-agenda.el ends here
#+end_src

*** utils/search-nav.el
:PROPERTIES:
:CUSTOM_ID: search-nav
:header-args:emacs-lisp: :tangle lisp/utils/search-nav.el
:END:

#+begin_src emacs-lisp
  ;;; utils/search-nav.el --- Project search & navigation -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Modern search/navigation helpers using ripgrep (via consult) and dumb-jump fallback.
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x))

  (leaf dumb-jump :straight t
    :hook (xref-backend-functions . dumb-jump-xref-activate)
    :custom ((dumb-jump-force-searcher  . 'rg)
             (dumb-jump-prefer-searcher . 'rg)))

  (leaf multiple-cursors :straight t)

  (leaf eww :straight nil
    :custom ((eww-search-prefix . "https://duckduckgo.com/html/?kl=jp-jp&k1=-1&kc=1&kf=-1&q=")
             (eww-download-directory . "~/Downloads"))
    :init
    (defvar my:d:eww
      (expand-file-name "eww/" my:d:var)
      "Directory for EWW runtime data.")
    (setopt eww-cache-directory (expand-file-name "cache/" my:d:eww))
    (my/ensure-directory-exists eww-cache-directory)
    (setq eww-history-limit 200)
    (defvar eww-hl-search-word nil "Word to highlight with isearch after EWW loads.")
    (defun my/eww-search (term)
      "Search TERM with EWW and start isearch."
      (interactive "sSearch terms: ")
      (setq eww-hl-search-word term)
      (eww-browse-url (concat eww-search-prefix term)))
    (add-hook 'eww-after-render-hook
              (lambda ()
                (when eww-hl-search-word
                  (isearch-mode t)
                  (isearch-yank-string eww-hl-search-word)
                  (setq eww-hl-search-word nil))))
    (defun my/eww-toggle-images () (interactive)
      (setq shr-inhibit-images (not shr-inhibit-images))
      (eww-reload)))

  (provide 'utils/search-nav)
  ;;; utils-search-nav.el ends here
#+end_src

*** utils/utils-notes-markdown.el
:PROPERTIES:
:CUSTOM_ID: utils-notes-markdown
:header-args:emacs-lisp: :tangle lisp/utils/utils-notes-markdown.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-notes-markdown.el --- Prose-oriented Markdown notes under Org -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;;
  ;; This module provides a prose-oriented Markdown notes system,
  ;; implemented as a *sibling domain* under `my:d:org`.
  ;;
  ;; Design assumptions (documented in README.org):
  ;;
  ;; - `my:d:org` is already defined and points to the Org root directory.
  ;; - Markdown notes are *not* part of Org agenda or task management.
  ;; - Org and Markdown coexist under the same logical knowledge base.
  ;; - Search/navigation is handled by consult + ripgrep.
  ;;
  ;; Directory layout:
  ;;
  ;;   my:d:org/
  ;;     ‚îú‚îÄ agenda/        (Org tasks, schedules)
  ;;     ‚îú‚îÄ projects/      (Org project files)
  ;;     ‚îî‚îÄ notes/         (Markdown prose notes)  ‚Üê this module
  ;;
  ;; Non-goals:
  ;; - No agenda integration
  ;; - No Org capture integration
  ;; - No Zettelkasten semantics
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x))


  ;;; Customization ------------------------------------------------------------

  (defgroup my:notes nil
    "Prose-oriented Markdown notes under Org directory."
    :group 'convenience)

  (defcustom my:notes-directory-name
    "notes"
    "Directory name for Markdown notes under `my:d:org`."
    :type 'string)

  (defcustom my:notes-default-notebooks
    '("inbox" "work" "life" "ideas" "archive")
    "Default notebook subdirectories under the notes directory."
    :type '(repeat string))


  ;;; Derived paths ------------------------------------------------------------

  (defvar my:d:notes
    (expand-file-name my:notes-directory-name my:d:org)
    "Root directory for Markdown notes.

  This directory is a sibling of Org files, not part of agenda scope.")


  ;;; Internal helpers ---------------------------------------------------------

  (defun my/notes--ensure-root ()
    "Ensure `my:d:notes` and default notebooks exist."
    (unless (file-directory-p my:d:notes)
      (make-directory my:d:notes t))
    (dolist (name my:notes-default-notebooks)
      (let ((dir (expand-file-name name my:d:notes)))
        (unless (file-directory-p dir)
          (make-directory dir t)))))

  (defun my/notes--slugify (title)
    "Return a filesystem-safe slug derived from TITLE."
    (let* ((lower (downcase title))
           (repl  (replace-regexp-in-string "[^[:alnum:]]+" "-" lower)))
      (string-trim repl "-+" "-+")))


  ;;; Note creation & navigation ----------------------------------------------

  (defun my/notes-new-note (notebook title)
    "Create a new Markdown note in NOTEBOOK with TITLE.

  NOTEBOOK is a subdirectory under `my:d:notes`."
    (interactive
     (progn
       (my/notes--ensure-root)
       (let* ((choices (directory-files my:d:notes nil "^[^.]"))
              (notebook (completing-read "Notebook: " choices nil nil "inbox"))
              (title (read-string "Title: ")))
         (list notebook title))))
    (my/notes--ensure-root)
    (let* ((dir (expand-file-name notebook my:d:notes))
           (slug (my/notes--slugify title))
           (timestamp (format-time-string "%Y%m%d-%H%M%S"))
           (filename (format "%s-%s.md" timestamp slug))
           (path (expand-file-name filename dir)))
      (unless (file-directory-p dir)
        (make-directory dir t))
      (find-file path)
      (when (= (buffer-size) 0)
        (insert
         (format
          "---\n\
  title: %s\n\
  notebook: %s\n\
  tags: []\n\
  created: %s\n\
  updated: %s\n\
  ---\n\n"
          title
          notebook
          (format-time-string "%Y-%m-%d")
          (format-time-string "%Y-%m-%d")))
        (save-buffer))))

  (defun my/notes-open-root ()
    "Open the Markdown notes root under Org in Dired."
    (interactive)
    (my/notes--ensure-root)
    (dired my:d:notes))


  ;;; Markdown UX --------------------------------------------------------------

  (leaf markdown-mode
    :straight t
    :mode (("\\.md\\'" . gfm-mode)
           ("README\\.md\\'" . gfm-mode))
    :hook
    ((markdown-mode . visual-line-mode)
     (markdown-mode . variable-pitch-mode)
     (markdown-mode . my/notes-markdown-visual-fill))
    :custom
    ((markdown-command . "pandoc")
     (markdown-fontify-code-blocks-natively . t))
    :config
    (defun my/markdown-toggle-live-preview ()
      "Toggle `markdown-live-preview-mode` in the current buffer."
      (interactive)
      (if (bound-and-true-p markdown-live-preview-mode)
          (markdown-live-preview-mode -1)
        (markdown-live-preview-mode 1)))
    (define-key markdown-mode-map (kbd "C-c C-p")
                #'my/markdown-toggle-live-preview))

  (leaf visual-fill-column
    :straight nil
    :commands (visual-fill-column-mode)
    :init
    (defun my/notes-markdown-visual-fill ()
      "Configure `visual-fill-column` for prose Markdown buffers."
      (setq-local visual-fill-column-width 100)
      (setq-local visual-fill-column-center-text t)
      (visual-fill-column-mode 1)))


  ;;; Search & navigation ------------------------------------------------------

  (leaf consult-notes
    :straight t
    :after consult
    :require t
    :init
    (defun my/notes-consult-ripgrep ()
      "Run `consult-ripgrep` scoped to Markdown notes under Org."
      (interactive)
      (my/notes--ensure-root)
      (let ((default-directory my:d:notes))
        (consult-ripgrep)))
    :config
    (setq consult-notes-file-dir-sources
          (list
           (list "Org Notes (MD)" ?m my:d:notes))))

  ;;; Image handling -----------------------------------------------------------

  (with-eval-after-load 'org-download
    (defun my/notes-markdown-org-download-setup ()
      "Enable `org-download` for Markdown notes under Org."
      (setq-local org-download-link-format "![](%s)")
      (setq-local org-download-image-dir "./images")
      (org-download-enable))
    (add-hook 'markdown-mode-hook
              #'my/notes-markdown-org-download-setup))


  (provide 'utils/utils-notes-markdown)
  ;;; utils/utils-notes-markdown.el ends here
#+end_src

*** utils/utils-gc.el
:PROPERTIES:
:CUSTOM_ID: utils-gc
:header-args:emacs-lisp: :tangle lisp/utils/utils-gc.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-gc.el --- GC helpers for long-running sessions -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Utilities for safe garbage collection during long-running Emacs sessions.
  ;;
  ;; This module provides:
  ;; - GC execution at safe moments (focus-out, minibuffer exit)
  ;;
  ;; This module intentionally does NOT provide:
  ;; - Visualization
  ;; - Logging
  ;; - Notifications
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf nil
    :straight nil
    :init
    (defcustom utils-gc-enable-p t
      "Enable GC hooks for long-running sessions."
      :type 'boolean
      :group 'utils)


    (defun utils-gc--collect ()
      "Run garbage collection (best-effort).
  This function never signals errors."
      (when utils-gc-enable-p
        (condition-case _err
            (garbage-collect)
  	(error nil))))

    ;; Run GC at safe moments
    (add-hook 'focus-out-hook #'utils-gc--collect)
    (add-hook 'minibuffer-exit-hook #'utils-gc--collect))

  (provide 'utils/utils-gc)
  ;;; utils/utils-gc.el ends here
#+end_src

*** utils/utils-buffers.el
:PROPERTIES:
:CUSTOM_ID: utils-buffers
:header-args:emacs-lisp: :tangle lisp/utils/utils-buffers.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-buffers.el --- Buffer housekeeping utilities -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Utilities for cleaning up temporary buffers and dead process buffers.
  ;;
  ;; This module provides:
  ;; - Detection of temporary buffers
  ;; - Cleanup of buffers associated with dead processes
  ;; - Periodic housekeeping
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf nil
    :straight nil
    :init
    (defcustom utils-buffers-enable-p t
      "Enable automatic buffer housekeeping."
      :type 'boolean
      :group 'utils)

    (defvar utils-buffers--temporary-regexp
      (rx string-start "*"
          (or "Help" "Warnings" "Compile-Log" "Backtrace"
              "Async-native-compile-log" "eglot-events")
          (* any) string-end)
      "Regexp matching temporary buffers safe to clean up.")

    (defun utils-buffers--temporary-p (buffer)
      "Return non-nil if BUFFER is a temporary buffer."
      (with-current-buffer buffer
        (and (string-match-p utils-buffers--temporary-regexp (buffer-name))
             (not (buffer-file-name))
             (not (buffer-modified-p))
             (not (get-buffer-window buffer 'visible)))))

    (defun utils-buffers--dead-process-p (buffer)
      "Return non-nil if BUFFER is associated with a dead process."
      (let ((proc (get-buffer-process buffer)))
        (and proc
             (memq (process-status proc) '(exit signal)))))

    (defun utils-buffers-cleanup ()
      "Clean up temporary and dead-process buffers."
      (interactive)
      (when utils-buffers-enable-p
        (dolist (buf (buffer-list))
          (when (or (utils-buffers--temporary-p buf)
                    (utils-buffers--dead-process-p buf))
            (kill-buffer buf)))))

    ;; Periodic housekeeping
    (run-with-timer 900 900 #'utils-buffers-cleanup))

  (provide 'utils/utils-buffers)
  ;;; utils/utils-buffers.el ends here
#+end_src

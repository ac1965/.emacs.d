# -*- mode: org; coding: utf-8; -*-

#+TITLE: Modern Emacs Configuration
#+AUTHOR: YAMASHITA, Takao
#+EMAIL: tjy1965@gmail.com
#+LANGUAGE: en
#+OPTIONS: toc:3 num:t
#+STARTUP: overview
#+PROPERTY: header-args :results silent :exports code :mkdirp yes :padline no :tangle no
#+PROPERTY: header-args:emacs-lisp :lexical t :noweb no-export

* Introduction
:PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

A modern, literate Emacs configuration using Org Mode's Babel format, emphasizing performance, language server integration, AI assistance, and productivity.

** Features
:PROPERTIES:
:CUSTOM_ID: features
:END:

- *Performance & Native Compilation* - JIT compilation with optimized settings, intelligent GC via GCMH, and async compilation
- *Language Server Protocol* - Configurable LSP backends (Eglot/LSP-Mode) with automatic server management
- *AI Integration* - Aidermacs with vterm backend supporting GPT-4, Claude 3.5 Sonnet, and OpenRouter APIs
- *Modern UI & Editing* - Tree-Sitter syntax highlighting, ef-themes, Nerd Icons, and advanced completion
- *Productivity Tools* - GTD-style Org workflow, Org-roam networked notes, and modern styling

[[file:demo.png]]

** Tangling Policy
:PROPERTIES:
:CUSTOM_ID: tangling-policy
:END:
_For documentation only; block-level `:tangle` in each source block always wins._

**Purpose**
Provide a single, canonical map from Org sections to tangled file paths so contributors can navigate, extend, and troubleshoot consistently.

**What it does**
- Defines **where** each module tangles to and **what** it should contain.
- Documents naming/namespace expectations (e.g., `core/`, `ui/`, `completion/`, `org/`, `dev/`, `vcs/`, `utils/`, `personal/`).
- Clarifies precedence and exceptions (e.g., `org-visual` chooses **either** `org-modern` **or** `org-superstar`, not both).

**Notes**
- File headers must follow the convention `;;; file.el --- desc -*- lexical-binding: t; -*-` and end with `(provide 'path/feature)`.
- Built-in packages must specify `:straight nil` in their leaf declarations.
- Personal overrides live under `personal/` and are **optional**; they are loaded last **if present**.
- This section is informational; it does not tangle code by itself.

| Directory     | Filename              | Contents                                                             |
|---------------+-----------------------+----------------------------------------------------------------------|
| (top-level)   | early-init.el         | Startup performance & low-level toggles (GC, handlers, native-comp)  |
| (top-level)   | init.el               | Bootstrap (straight + leaf init), then loads `modules.el`            |
| core/         | general.el            | Global policies, hydras, keymaps, Dired/TRAMP/auth scaffolding       |
| core/         | tools.el              | Navigation helpers, Dired helper, Tree-sitter utils, ext tool hooks  |
| core/         | utils.el              | Auto-tangle, revert, lexical-binding header, read-only view helpers  |
| core/         | history.el            | save-place, recentf, savehist, autorevert, transient paths           |
| core/         | editing.el            | paredit/puni, which-key, undo tools, expand-region, dired extras     |
| core/         | eww.el                | EWW QoL: search helpers, toggle images, paths                        |
| core/         | auto-save.el          | Redirect auto-save/backup/TRAMP autosave into `.var/`                |
| ui/           | ui-font.el            | Font setup (default/variable/emoji), ligatures                       |
| ui/           | ui-theme.el           | Theme mgmt (ef-themes + spacious-padding); no face munging here      |
| ui/           | ui-modeline.el        | doom-modeline, minions, time, battery                                |
| ui/           | ui-window.el          | Fullscreen, zoom, tab-bar/line, save/restore layouts                 |
| ui/           | ui-treemacs.el        | Sidebar project/file explorer                                         |
| ui/           | ui-clipboard.el       | macOS clipboard integration (pbcopy)                                 |
| ui/           | ui-faces-sanitize.el  | Post-theme face normalizer / narrow advice for doc-markup face only  |
| completion/   | completion-core.el    | prescient (persist), orderless styles & overrides                     |
| completion/   | completion-vertico.el | vertico (+posframe on GUI), marginalia                               |
| completion/   | completion-consult.el | consult + xref integration                                           |
| completion/   | completion-embark.el  | embark + consult preview                                             |
| completion/   | completion-corfu.el   | corfu (global), kind-icon margin, cape CAPFs                         |
| completion/   | completion-icons.el   | nerd-icons for ibuffer/marginalia                                    |
| org/          | org-core.el           | GTD workflow, agenda/capture/refile, directories                     |
| org/          | org-visual.el         | **Pick one** visual enhancer: `org-modern` **or** `org-superstar`    |
| org/          | org-extensions.el     | org-journal, org-roam, org-download, toc-org, cliplink               |
| org/          | org-export.el         | LaTeX toolchain, Hugo exporter, Markdown/preview                     |
| dev/          | dev-lsp.el            | eglot or lsp-mode (select via `my:use-lsp`)                          |
| dev/          | dev-ai.el             | Aidermacs (OpenRouter/OpenAI), defaults & warnings                   |
| dev/          | dev-term.el           | vterm integration                                                     |
| dev/          | dev-build.el          | Makefile rules, compile bindings, ANSI color in compilation          |
| dev/          | dev-docker.el         | dockerfile-mode, docker.el, tramp-container, yaml-mode, tempel       |
| vcs/          | vcs-magit.el          | Magit bindings/config                                                |
| vcs/          | vcs-gutter.el         | git-gutter/diff-hl fringe indicators                                 |
| vcs/          | vcs-forge.el          | Forge (GitHub/GitLab) DB path under `.var/`                          |
| utils/        | utils-functions.el    | Directory ensure, safe-load helpers                                  |
| utils/        | utils-scratch.el      | scratch auto-recreate & helper                                       |
| utils/        | utils-backup.el       | Old backup cleanup on startup                                        |
| utils/        | utils-async.el        | Safe async runner (error-reporting)                                  |
| utils/        | search-nav.el         | ripgrep, dumb-jump (xref), projectile, multiple-cursors              |
| (top-level)   | modules.el            | Central module loader (compat, then UI/Completion/Org/Dev/VCS/Utils) |
| personal/     | <username>.el         | Optional per-user/per-machine overrides                              |
| personal/     | user.el               | Personal entry point; loaded last if present                         |

** Build pipeline
- =Makefile= :: Reproducible pipeline (=tangle=, =clean=, =compile=)

** Installation
:PROPERTIES:
   :CUSTOM_ID: installation
   :END:

*** Prerequisites
:PROPERTIES:
:CUSTOM_ID: prerequisites
:END:

- **Required**
  - Emacs **30.0+** with native compilation (`--with-native-compilation`)
  - Git
  - GNU Make
  - GCC **10+** with `libgccjit`

- **Optional but Recommended**
  - ripgrep (`rg`) → faster project-wide search
  - aspell or hunspell → spell checking
  - pass + GnuPG → password and auth-source integration
  - Homebrew (macOS only) → for consistent toolchain installation

*** Building Emacs

Use the provided build script:
[[https://github.com/ac1965/dotfiles/blob/master/.local/bin/build-emacs.sh][build-emacs.sh]]

#+begin_src shell
build-emacs.sh --native-compilation
#+end_src

*** Quick Start

1. Clone the repository:
   #+begin_src shell
   git clone --depth 1 https://github.com/ac1965/.emacs.d ~/.emacs.d
   #+end_src

2. Tangle configuration:
   #+begin_src shell
   cd ~/.emacs.d/
   EMACS=/Applications/Emacs.app/Contents/MacOS/Emacs make
   #+end_src

*** Makefile

#+begin_src text :tangle Makefile :comments no
  # Makefile for Emacs config build
  # Emacs 30+, Org Babel (tangle), byte-compilation
  # Safe, minimal, maintainable

  # Variables
  EMACS       ?= emacs
  ORG         ?= README.org
  LISPDIR     ?= lisp
  PERSONALDIR ?= personal
  ELFILES     = $(wildcard $(LISPDIR)/*.el) $(wildcard $(PERSONALDIR)/*.el)
  ELCFILES    = $(ELFILES:.el=.elc)

  # Default target
  all: tangle

  # Tangle all .el files from README.org
  tangle: $(ORG)
  	$(EMACS) --batch -Q \
  		--eval "(require 'org)" \
  		--eval "(org-babel-tangle-file \"$(ORG)\")"

  # Byte-compile all tangled .el files
  compile: tangle $(ELCFILES)

  $(LISPDIR)/%.elc: $(LISPDIR)/%.el
  	$(EMACS) --batch -Q \
  		--eval "(byte-compile-file \"$<\")"

  $(PERSONALDIR)/%.elc: $(PERSONALDIR)/%.el
  	$(EMACS) --batch -Q \
  		--eval "(byte-compile-file \"$<\")"

  # Remove compilation artifacts
  clean:
  	rm -fr $(LISPDIR) $(PERSONALDIR)

  .PHONY: all tangle compile clean
#+end_src

*** System Information

**** Apple Silicon (Primary)
- GNU Emacs *31.0.50*

|Property|Value|
|--------|-----|
|Commit|3271d9fc9654e1d9aa92f19c969f4b3d5b9e6272|
|Branch|master|
|System|aarch64-apple-darwin24.6.0|
|Date|2025-10-04 22:11:47 (JST)|
|Features|ACL DBUS GLIB GNUTLS LCMS2 LIBXML2 MODULES NATIVE_COMP NOTIFY KQUEUE NS PDUMPER PNG RSVG SQLITE3 THREADS TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM ZLIB|
|Options|--with-native-compilation --with-gnutls=ifavailable --with-json --with-modules --with-tree-sitter --with-xml2 --with-librsvg --with-mailutils --with-native-image-api --with-ns CPPFLAGS=-I/opt/homebrew/opt/llvm/include 'LDFLAGS=-L/opt/homebrew/opt/llvm/lib -L/opt/homebrew/opt/llvm/lib/c++ -Wl,-rpath,/opt/homebrew/opt/llvm/lib/c++'|

**** Intel (Secondary)
- GNU Emacs *31.0.50*

|Property|Value|
|--------|-----|
|Commit|aa12cebaa684d7b3ea7e131666d33bcc71b45625|
|Branch|master|
|System|x86_64-apple-darwin24.4.0|
|Date|2025-03-23 10:35:38 (JST)|
|Patch|N/A ns-inline.patch|
|Features|ACL DBUS GIF GLIB GMP GNUTLS JPEG LCMS2 LIBXML2 MODULES NATIVE_COMP NOTIFY KQUEUE NS PDUMPER PNG RSVG SQLITE3 THREADS TIFF TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM XWIDGETS ZLIB|
|Options|--with-native-compilation --with-gnutls=ifavailable --with-json --with-modules --with-tree-sitter --with-xml2 --with-xwidgets --with-librsvg CFLAGS=-I/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include CPPFLAGS=-I/usr/local/opt/llvm/include 'LDFLAGS=-L/usr/local/opt/llvm/lib -L/usr/local/opt/llvm/lib/c++ -Wl,-rpath,/usr/local/opt/llvm/lib/c++'|
* Configuration Files
:PROPERTIES:
:CUSTOM_ID: structure
:END:

This Emacs configuration is modular and organized for **Emacs 30+**.

- `early-init.el` → startup optimizations & directories
- `init.el` → package bootstrap & base settings
- `lisp/` → modular configs (core, ui, completion, org, dev, vcs, utils)
- `personal/` → user-specific settings

** Core Setup
:PROPERTIES:
:CUSTOM_ID: core
:END:

*** early-init.el
:PROPERTIES:
:CUSTOM_ID: early-init
:END:

**Purpose**
Provide safe, reversible early startup optimizations and directory scaffolding for **Emacs 30+**, tailored for a `leaf` + `straight.el` configuration on macOS. Keep macOS Homebrew `libgccjit` probing behaviorally identical.

**What it does**
- Disables `package.el` auto-activation.
- Temporarily widens GC limits and clears `file-name-handler-alist`; restores both on `emacs-startup-hook`.
- Defines `my:d` as project root and defensively creates hidden directories: `.cache/`, `.etc/`, `.var/`, `eln-cache/`, `tree-sitter/`, `treesit-build/`.
- Configures native compilation: silences warnings and pins `native-comp-eln-load-path` to `.cache/eln-cache/`.
- **macOS**: If Homebrew `libgccjit` is present, safely amends `LIBRARY_PATH` (errors are surfaced via `message`).
- After first frame, disables `menu-bar`, `tool-bar`, and `scroll-bar`.
- Sets `straight-base-dir` to `.cache/`. Sets `custom-file` to `.etc/custom.el` and loads it quietly if present.
- If available, adds `.var/tree-sitter/` to `treesit-extra-load-path`.

**Notes**
- Ensure this tangled file is placed as `~/.emacs.d/early-init.el`, because Emacs loads `early-init.el` only from the top-level directory.
- Directory creation is idempotent and reports failures via `warn`/`message`.
- Uses only documented Emacs 30+ features; no internal/unstable APIs.

#+begin_src emacs-lisp :tangle early-init.el
  ;;; early-init.el --- Early initialization -*- lexical-binding: t; -*-
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Early startup optimizations and directory setup for Emacs 30+.
  ;; Safe, reversible, and compatible with straight.el + leaf.el.
  ;;; Code:

  ;; 1) package.el off
  (setopt package-enable-at-startup nil)

  ;; 2) GC: widen during startup, restore after
  (defvar my:orig:gc-cons-threshold gc-cons-threshold)
  (defvar my:orig:gc-cons-percentage gc-cons-percentage)
  (setopt gc-cons-threshold most-positive-fixnum
          gc-cons-percentage 0.6)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setopt gc-cons-threshold my:orig:gc-cons-threshold
                      gc-cons-percentage my:orig:gc-cons-percentage)))

  ;; 3) File-name handlers: clear during startup, restore after
  (defvar my:orig:file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq file-name-handler-alist my:orig:file-name-handler-alist)))

  ;; 4) Helpers: defensive mkdir with warnings
  (defun my/ensure-directory-exists (dir)
    "Ensure DIR exists; create if necessary."
    (unless (file-directory-p dir)
      (condition-case err
          (make-directory dir t)
        (error (warn "Failed to create directory: %s (%s)"
                     dir (error-message-string err))))))

  ;; 5) Project root and directory layout (hidden dirs)
  (defvar my:d (or (and load-file-name
                        (file-name-directory (file-chase-links load-file-name)))
                   user-emacs-directory))

  (defvar my:d:cache   (expand-file-name ".cache/"       my:d))
  (defvar my:d:etc     (expand-file-name ".etc/"         my:d))
  (defvar my:d:var     (expand-file-name ".var/"         my:d))
  (defvar my:d:lisp    (expand-file-name "lisp/"         my:d))
  (defvar my:d:eln     (expand-file-name "eln-cache/"    my:d:cache))
  (defvar my:d:treesit (expand-file-name "tree-sitter/"  my:d:var))
  (defvar my:d:treesit-build (expand-file-name "treesit-build/" my:d:cache))
  (defvar my:f:custom  (expand-file-name "custom.el"     my:d:etc))

  (dolist (dir (list my:d:cache my:d:etc my:d:var my:d:lisp
                     my:d:eln my:d:treesit my:d:treesit-build))
    (my/ensure-directory-exists dir))

  (add-to-list 'load-path my:d:lisp)

  ;; 6) Native compilation (Emacs 29+)
  (when (featurep 'native-compile)
    (setopt native-comp-async-report-warnings-errors 'silent
            native-comp-eln-load-path (list my:d:eln)))

  ;; 7) treesit: prefer local grammar directory if supported
  (when (boundp 'treesit-extra-load-path)
    (add-to-list 'treesit-extra-load-path my:d:treesit))

  ;; 8) macOS + Homebrew libgccjit support (preserved semantics)
  (when (and (eq system-type 'darwin) (executable-find "brew"))
    (condition-case err
        (let* ((prefix (string-trim (shell-command-to-string "brew --prefix")))
               (brew-libgccjit (expand-file-name "lib/gcc/current" prefix)))
          (when (file-directory-p brew-libgccjit)
            (setenv "LIBRARY_PATH"
                    (concat brew-libgccjit
                            (when-let* ((orig (getenv "LIBRARY_PATH")))
                              (concat ":" orig))))))
      (error (message "[early-init] brew probe failed: %s"
                      (error-message-string err)))))

  ;; 9) Disable heavy UI after first frame
  (add-hook 'emacs-startup-hook
            (lambda ()
              (dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
                (when (fboundp mode) (funcall mode -1)))))

  ;; 10) straight.el defaults (base dir under .cache/)
  (setopt straight-base-dir my:d:cache
          straight-use-package-by-default t
          straight-profiles '((nil . "default.el")))

  ;; 11) custom-file under .etc/ and load quietly if present
  (setopt custom-file my:f:custom)
  (when (file-exists-p custom-file)
    (load custom-file 'noerror 'nomessage))

  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** init.el
:PROPERTIES:
:CUSTOM_ID: init
:END:

*Purpose*
Bootstrap packages, configure base behavior, and load modular files.

*What it does*
- Bootstraps `straight.el` (guarded, timeout).
- Installs and initializes `leaf`.
- Defines user customization group (`my`) and LSP selector.
- Temporarily enlarges process I/O buffer; restores later.
- Configures sensible defaults (UI, editing, scrolling).
- Uses `no-littering` to centralize paths.
- On macOS: imports shell env safely; extends PATH; configures `dired`.
- Loads personal and modular configs fault-tolerantly.
- Reports startup time & GC count asynchronously.

*Notes*
- Safe wrappers prevent single-file errors from breaking init.
- `custom.el` is isolated in `.etc`.
- Load-path sanitized (no root dir).

#+begin_src emacs-lisp :tangle init.el
  ;;; init.el --- Main initialization -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao <tjy1965@gmail.com>
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Entry point for Emacs 30+ configuration.
  ;; - Bootstraps package management (straight.el + leaf)
  ;; - Defines customization groups and defaults
  ;; - Configures basic UI and performance
  ;; - Loads modular configuration via lisp/modules.el
  ;; - Optionally loads personal overrides

  ;;; Code:

  ;; ---------------------------------------------------------------------------
  ;;; Bootstrap straight.el
  ;; ---------------------------------------------------------------------------
  (defvar bootstrap-version 7)
  (let* ((base (or (bound-and-true-p straight-base-dir) user-emacs-directory))
         (bootstrap-file (expand-file-name "straight/repos/straight.el/bootstrap.el" base)))
    (unless (file-exists-p bootstrap-file)
      (condition-case err
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp))
        (error (user-error "[straight] bootstrap failed: %s" (error-message-string err)))))
    (load bootstrap-file nil 'nomessage))

  ;; Ensure essential packages
  (dolist (pkg '(leaf leaf-keywords leaf-convert blackout org))
    (straight-use-package pkg))
  (require 'org)

  (eval-when-compile
    (require 'leaf)
    (require 'leaf-keywords))
  (leaf-keywords-init)

  ;; ---------------------------------------------------------------------------
  ;;; Customization group
  ;; ---------------------------------------------------------------------------
  (defgroup my nil
    "User customizations."
    :group 'convenience)

  (defcustom my:use-lsp 'eglot
    "Select which LSP client to use. Valid values: 'eglot or 'lsp."
    :type '(choice (const :tag "Eglot" eglot)
                   (const :tag "lsp-mode" lsp))
    :group 'my)

  ;; ---------------------------------------------------------------------------
  ;;; Performance tweaks
  ;; ---------------------------------------------------------------------------
  (defvar my:orig:read-process-output-max
    (and (boundp 'read-process-output-max) read-process-output-max))
  (when (boundp 'read-process-output-max)
    (setq read-process-output-max (* 4 1024 1024)))
  (add-hook 'emacs-startup-hook
            (lambda ()
              (when (boundp 'read-process-output-max)
                (setq read-process-output-max my:orig:read-process-output-max))))

  (leaf gcmh
    :straight t
    :hook (emacs-startup . gcmh-mode)
    :init
    (setq gcmh-idle-delay 2
          gcmh-high-cons-threshold (* 64 1024 1024)))

  ;; ---------------------------------------------------------------------------
  ;;; Basic UI and editing defaults
  ;; ---------------------------------------------------------------------------
  (leaf emacs
    :straight nil
    :init
    ;; Unset disruptive keys
    (dolist (k '("C-z" "C-x C-z" "C-x C-c" "M-z" "M-m" "M-/"))
      (keymap-global-unset k))
    (when (fboundp 'cape-dabbrev)
      (keymap-global-set "M-/" #'cape-dabbrev))
    (when (fboundp 'pixel-scroll-precision-mode)
      (pixel-scroll-precision-mode 1))
    (setopt inhibit-startup-screen  t
            initial-scratch-message nil
            use-short-answers       t
            create-lockfiles        nil
            make-backup-files       t
            delete-old-versions     t
            version-control         t
            idle-update-delay       0.2
            ring-bell-function      #'ignore
            display-line-numbers-type 'relative
            auto-save-default       t
            auto-save-visited-interval 2)
    (electric-pair-mode 1)
    (add-hook 'prog-mode-hook #'display-line-numbers-mode)
    (auto-save-visited-mode 1))

  ;; Modifier keys
  (leaf my:modifier
    :straight nil
    :init
    (cond
     ((eq system-type 'darwin)
      (setq mac-option-modifier 'meta
            mac-command-modifier 'super
            mac-control-modifier 'control
            mac-function-modifier 'hyper))
     ((eq system-type 'windows-nt)
      (setq w32-lwindow-modifier 'super
            w32-rwindow-modifier 'super
            w32-apps-modifier   'hyper))
     ((eq system-type 'gnu/linux)
      (setq my:os "linux"))))

  ;; ---------------------------------------------------------------------------
  ;;; Files and environment
  ;; ---------------------------------------------------------------------------
  (leaf no-littering
    :straight t
    :init
    (setq no-littering-etc-directory my:d:etc
          no-littering-var-directory my:d:var))

  (leaf exec-path-from-shell
    :straight t
    :if (memq window-system '(mac ns))
    :custom ((exec-path-from-shell-check-startup-files . nil)
             (exec-path-from-shell-arguments . '("-l" "-i"))
             (exec-path-from-shell-variables
              . '("PATH" "LANG" "PASSWORD_STORE_DIR" "GPG_KEY_ID"
                  "OPENROUTER_API_KEY" "OPENAI_API_KEY")))
    :config
    (ignore-errors (exec-path-from-shell-initialize)))

  (when (eq system-type 'darwin)
    (dolist (p '("/opt/homebrew/bin" "/usr/local/bin"))
      (when (and (file-directory-p p) (not (member p exec-path)))
        (add-to-list 'exec-path p)
        (setenv "PATH" (concat p ":" (getenv "PATH"))))))

  ;; Dired defaults
  (leaf dired
    :straight nil
    :after dired-subtree
    :custom ((dired-listing-switches . "-aBhl --group-directories-first"))
    :config
    (when (and (eq system-type 'darwin) (executable-find "gls"))
      (setq insert-directory-program "gls"
            dired-use-ls-dired t))
    :bind (:dired-mode-map
           ("i"   . dired-subtree-insert)
           ("TAB" . dired-subtree-toggle)
           ("z"   . my/dired-view-file-other-window)))

  ;; ---------------------------------------------------------------------------
  ;;; Misc
  ;; ---------------------------------------------------------------------------
  (leaf hydra :straight t :commands (defhydra))

  (setq custom-file my:f:custom)
  (when (file-readable-p custom-file)
    (ignore-errors (load custom-file nil 'nomessage)))

  ;; Safe file loader
  (defun my/safe-load-file (file &optional noerror)
    "Load FILE safely. If NOERROR is non-nil, log error instead of raising."
    (when (and file (file-exists-p file))
      (condition-case err
          (load file nil 'nomessage)
        (error
         (funcall (if noerror #'message #'user-error)
                  "[load] failed to load %s: %s"
                  file (error-message-string err))))))

  ;; ---------------------------------------------------------------------------
  ;;; User-specific overrides
  ;; ---------------------------------------------------------------------------
  (my/safe-load-file (concat my:d "personal/" user-login-name ".el") t)

  ;; ---------------------------------------------------------------------------
  ;;; Modular configuration
  ;; ---------------------------------------------------------------------------
  (let* ((root (if (and (boundp 'my:d) (stringp my:d) (file-directory-p my:d))
                   (file-name-as-directory my:d)
                 (file-name-as-directory user-emacs-directory)))
         (lisp-dir (expand-file-name "lisp" root)))
    (add-to-list 'load-path lisp-dir)
    (require 'modules nil t))

  ;; ---------------------------------------------------------------------------
  ;;; Startup report
  ;; ---------------------------------------------------------------------------
  (add-hook 'after-init-hook
            (lambda ()
              (run-with-idle-timer
               0 nil
               (lambda ()
                 (message "Emacs ready in %.2f seconds with %d GCs."
                          (float-time (time-subtract after-init-time before-init-time))
                          gcs-done)))))

  (provide 'init)
  ;;; init.el ends here
#+end_src

** Modular Configuration
:PROPERTIES:
:CUSTOM_ID: modules
:END:

*** modules.el
:PROPERTIES:
:CUSTOM_ID: core-modules
:END:

**Purpose**
Deterministic, resilient loader for modular config under `lisp/`, updated to load **compat shims first** and **UI face sanitizers** early to prevent startup warnings.

**What it does**
- Builds the final module list as: base ⇒ unique ⇒ minus `my:modules-skip` ⇒ plus `my:modules-extra` (unique).
- Requires each feature **safely** (errors logged; startup continues) and optionally **times** loads.
- Ensures **`core/compat`** is early so legacy helpers (e.g. `my--nl-var`) exist before other modules.
- Includes **`ui/ui-faces-sanitize`** to avoid invalid face attribute warnings after themes.

**Notes**
- Every file must `(provide 'path/feature)` matching its relative path, e.g. `lisp/core/compat.el` ⇒ `(provide 'core/compat)`.
- You can disable auto-load by setting `(setopt my:modules-autoload-on-require nil)` before requiring this file.

#+begin_src emacs-lisp :tangle lisp/modules.el
  ;;; modules.el --- Modular config loader -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Stable, safe module loader. Loads compat shims first, then the rest in order.
  ;;; Code:

  (require 'cl-lib)
  (require 'seq)
  (require 'subr-x)

  (defgroup my:modules nil
    "Loader options for modular Emacs configuration."
    :group 'convenience)

  (defcustom my:modules-verbose t
    "When non-nil, print per-module load time and a summary."
    :type 'boolean
    :group 'my:modules)

  (defcustom my:modules-autoload-on-require t
    "When non-nil, call `my/modules-load' as soon as this file is required."
    :type 'boolean
    :group 'my:modules)

  (defcustom my:modules-skip nil
    "List of module features to skip during loading."
    :type '(repeat symbol)
    :group 'my:modules)

  (defcustom my:modules-extra nil
    "Extra module features to append after the base list (deduped, order-preserving)."
    :type '(repeat symbol)
    :group 'my:modules)

  ;; -----------------------------------------------------------------------------
  ;; Canonical base list (order matters)
  ;; -----------------------------------------------------------------------------
  (defconst my:modules
    '(
      ;; --- Core (compat first) --------------------------------------------------
      core/compat
      core/general
      core/tools
      core/utils
      core/history
      core/editing
      core/eww
      core/auto-save

      ;; --- UI -------------------------------------------------------------------
      ;; ui/ui-faces-sanitize   ;; prevent nil face attr warnings early
      ui/ui-font
      ui/ui-theme
      ui/ui-modeline
      ui/ui-window
      ui/ui-treemacs
      ui/ui-clipboard

      ;; --- Completion -----------------------------------------------------------
      completion/completion-core
      completion/completion-vertico
      completion/completion-consult
      completion/completion-embark
      completion/completion-corfu
      completion/completion-icons

      ;; --- Org ------------------------------------------------------------------
      org/org-core
      org/org-visual
      org/org-extensions
      org/org-export

      ;; --- Development ----------------------------------------------------------
      dev/dev-lsp
      dev/dev-ai
      dev/dev-term
      dev/dev-build
      dev/dev-docker

      ;; --- Web/Infra (optional, keep placeholders if you have them) ------------
      ;; dev/web-core
      ;; dev/lsp-web
      ;; dev/format
      ;; dev/infra-modes
      ;; dev/sql
      ;; dev/rest

      ;; --- VCS ------------------------------------------------------------------
      vcs/vcs-magit
      vcs/vcs-gutter
      vcs/vcs-forge

      ;; --- Utils ----------------------------------------------------------------
      utils/utils-functions
      utils/utils-scratch
      utils/utils-backup
      utils/utils-async
      utils/search-nav
      )
    "Default set of modules to load in order. `core/compat` must be first.")

  ;; -----------------------------------------------------------------------------
  ;; Helpers
  ;; -----------------------------------------------------------------------------
  (defun my/modules--format-seconds (sec)
    "Format SEC (float seconds) succinctly."
    (cond
     ((< sec 0.001) (format "%.3fms" (* sec 1000.0)))
     ((< sec 1.000) (format "%.1fms" (* sec 1000.0)))
     (t             (format "%.2fs"  sec))))

  (defun my/modules--unique (features)
    "Return FEATURES with duplicates removed while preserving order."
    (let ((seen (make-hash-table :test #'eq))
          (out  '()))
      (dolist (f features (nreverse out))
        (unless (gethash f seen)
          (puthash f t seen)
          (push f out)))))

  (defun my/modules--final-list ()
    "Compute final load list from base + extras, minus skips."
    (let* ((base (my/modules--unique my:modules))
           (extra (my/modules--unique my:modules-extra))
           (combined (my/modules--unique (append base extra))))
      (seq-remove (lambda (f) (memq f my:modules-skip)) combined)))

  (defun my/modules--require-safe (feature)
    "Require FEATURE safely; return non-nil on success."
    (condition-case err
        (progn
          (unless (featurep feature)
            (require feature))
          t)
      (error
       (message "[modules] Failed to load %s: %s"
                feature (error-message-string err))
       nil)))

  ;; -----------------------------------------------------------------------------
  ;; Entry point
  ;; -----------------------------------------------------------------------------
  (defun my/modules-load ()
    "Load modules per `my:modules`, honoring skip/extra settings.
  Returns plist: `:loaded', `:failed', `:skipped', `:elapsed`."
    (let* ((t0 (and my:modules-verbose (current-time)))
           (final (my/modules--final-list))
           (requested (my/modules--unique (append my:modules my:modules-extra)))
           (skipped (seq-filter (lambda (f) (memq f my:modules-skip)) requested))
           (loaded '())
           (failed '()))
      (dolist (mod final)
        (let ((m0 (and my:modules-verbose (current-time))))
          (if (my/modules--require-safe mod)
              (push mod loaded)
            (push mod failed))
          (when my:modules-verbose
            (message "[modules] %-30s %s"
                     mod
                     (my/modules--format-seconds
                      (float-time (time-subtract (current-time) m0)))))))
      (let* ((elapsed (and t0 (float-time (time-subtract (current-time) t0))))
             (ok (length loaded))
             (ng (length failed))
             (sk (length skipped)))
        (when my:modules-verbose
          (message "[modules] loaded=%d skipped=%d failed=%d total=%s"
                   ok sk ng (or (and elapsed (my/modules--format-seconds elapsed)) "n/a")))
        (list :loaded (nreverse loaded)
              :failed (nreverse failed)
              :skipped skipped
              :elapsed elapsed))))

  (when my:modules-autoload-on-require
    (my/modules-load))

  (provide 'modules)
  ;;; modules.el ends here
#+end_src

*** core/compat.el
:PROPERTIES:
:CUSTOM_ID: core-compat
:END:

**Purpose**
Provide **forward-compatible shims** so legacy helpers like `my--nl-var` won’t break byte-compilation or eager macro-expansion. Also supplies a safe fallback for `no-littering-var-directory`.

**What it does**
- Defines `no-littering-var-directory` fallback (uses `~/.emacs.d/.var/` by default).
- Defines `(my--nl-var &rest SEGMENTS)` helper that **joins under** `no-littering-var-directory`.
- Exposes `my:d:var` pointing at `.var/` so other modules can rely on a stable root.
- Contains **no side effects** beyond definitions; safe to load very early.

**Notes**
- Put `core/compat` **before** `core/general` in your module order (or add `(require 'core/compat)` at the top of `core/general.el`).
- This removes the error:
  `[modules] Failed to load core/general: Eager macro-expansion failure: (void-function my--nl-var)`.

#+begin_src emacs-lisp :tangle lisp/core/compat.el
;;; compat.el --- Lightweight shims for legacy helpers -*- lexical-binding: t; -*-
;;; Commentary:
;; Provide forward-compatible helpers used by older snippets (e.g., my--nl-var).
;;; Code:

(require 'subr-x)

;; Fallback when no-littering is not present.
(defvar no-littering-var-directory
  (expand-file-name ".var/"
                    (or (and load-file-name
                             (file-name-directory (file-chase-links load-file-name)))
                        user-emacs-directory))
  "Variable data directory. If `no-littering` is installed, it usually sets this.")

(defvar my:d:var no-littering-var-directory
  "Canonical variable-data root for this config (defaults to `.var/`).")

;; Legacy helper used by some configs/snippets: (my--nl-var \"sub/dir\" \"file\")
(unless (fboundp 'my--nl-var)
  (defun my--nl-var (&rest segments)
    "Join SEGMENTS under `no-littering-var-directory` and return an absolute path."
    (let ((base (file-name-as-directory no-littering-var-directory)))
      (expand-file-name (mapconcat #'identity segments "/") base))))

(provide 'core/compat)
;;; compat.el ends here
#+end_src
*** core/general.el
:PROPERTIES:
:CUSTOM_ID: core-general
:END:

**Purpose**
Global policies and keymaps. Fix fragile spots (dired keymap timing, error guards) and keep built-in packages under `:straight nil`.

**What it does**
- Text-scale hydra and curated global bindings.
- Dired bindings guarded to load **after** `dired-subtree`.
- Desktop/session/backup/TRAMP/auth scaffolding with fallbacks when `no-littering` is absent.

**Notes**
- Requires `core/utils` (for `my/ensure-directory-exists`) and `core/eww` (for helpers referenced by keybindings).

#+begin_src emacs-lisp :tangle lisp/core/general.el
  ;;; core/general.el --- General settings & keybindings -*- lexical-binding: t; -*-
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; General-purpose settings and curated keybindings.
  ;;; Code:

  (require 'leaf)
  (require 'leaf-keywords)

  ;; ---------------------------------------------------------------------------
  ;; Text scaling hydra
  (leaf hydra :straight t
    :config
    (defhydra hydra-text-scale (:hint nil :color red)
      "
  ^Text Scaling^
  [_+_] Increase   [_-_] Decrease   [_0_] Reset   [_q_] Quit
  "
      ("+" text-scale-increase)
      ("-" text-scale-decrease)
      ("0" (text-scale-set 0) :color blue)
      ("q" nil "quit" :color blue)))

  ;; ---------------------------------------------------------------------------
  ;; Common Key Bindings
  (leaf my:key
    :straight nil
    :doc "Centralized keybindings via leaf."
    :emacs>= 30.0
    :bind
    (;; Global
     ("<f1>"     . help)
     ("<f5>"     . my/revert-buffer-quick)
     ("<f8>"     . treemacs)
     ("C-h"      . backward-delete-char)
     ;; Undo/redo
     ("C-/"      . undo-fu-only-undo)
     ("C-?"      . undo-fu-only-redo)
     ;; Text scaling
     ("C-c z"    . hydra-text-scale/body)
     ;; Buffer navigation
     ("C-c b"    . consult-buffer)
     ("M-n"      . forward-paragraph)
     ("M-p"      . backward-paragraph)
     ("s-<down>" . end-of-buffer)
     ("s-<up>"   . beginning-of-buffer)
     ("s-<right>". next-buffer)
     ("s-<left>" . previous-buffer)
     ;; Window management
     ("C-."      . other-window)
     ("C-c 2"    . my/toggle-window-split)
     ("s-."      . ace-window)
     ("s-w"      . ace-swap-window)
     ("s-d"      . delete-frame)
     ("s-m"      . (lambda ()
                     (interactive)
                     (let ((frame (make-frame)))
                       (with-selected-frame frame
                         (switch-to-buffer (generate-new-buffer "untitled"))))))
     ;; File ops
     ("s-j"      . find-file-other-window)
     ("s-o"      . find-file-other-frame)
     ("C-c o"    . find-file)
     ("C-c v"    . find-file-read-only)
     ("C-c V"    . view-file-other-window)
     ("C-c k"    . kill-buffer-and-window)
     ;; Search
     ("C-s"      . consult-line)
     ("C-c r"    . consult-ripgrep)
     ;; Text manipulation
     ("C-="      . er/expand-region)
     ("C-c M-a"  . align-regexp)
     ("C-c ;"    . comment-or-uncomment-region)
     ("C-c l"    . display-line-numbers-mode)
     ;; Org/Roam
     ("C-c d a"  . org-agenda)
     ("C-c d c"  . org-capture)
     ("C-c d i"  . org-roam-node-insert)
     ("C-c d f"  . org-roam-node-find)
     ;; Aider
     ("C-c a a"  . aidermacs-transient-menu)
     ;; EWW (helpers in core/eww.el)
     ("C-c w w"  . eww)
     ("C-c w s"  . my/eww-search)
     ("C-c w o"  . eww-open-file)
     ("C-c w b"  . eww-list-bookmarks)
     ("C-c w r"  . eww-readable)
     ("C-c w u"  . my/eww-toggle-images)
     ;; Misc
     ("C-x g"    . magit-status)
     ("s-r"      . restart-emacs)
     ("M-x"      . execute-extended-command))
    :init
    (windmove-default-keybindings))

  ;; ---------------------------------------------------------------------------
  ;; Desktop save (fallback if no-littering is absent)
  (leaf desktop :straight nil
    :config
    (let* ((var (if (boundp 'no-littering-var-directory)
                    no-littering-var-directory
                  (locate-user-emacs-file ".var/")))
           (dir (expand-file-name "desktop/" var)))
      (setq desktop-dirname          dir
            desktop-path             (list dir)
            desktop-base-file-name   "desktop"
            desktop-base-lock-name   "lock"
            desktop-restore-eager    10
            desktop-save             t
            desktop-load-locked-desktop t
            desktop-auto-save-timeout 300)
      (when (fboundp 'my/ensure-directory-exists)
        (my/ensure-directory-exists dir)))
    (desktop-save-mode 1))

  ;; ---------------------------------------------------------------------------
  ;; Winner mode
  (leaf winner :straight nil
    :global-minor-mode t
    :bind (("M-[" . winner-undo)
           ("M-]" . winner-redo)))

  ;; ---------------------------------------------------------------------------
  ;; TRAMP
  (leaf tramp :straight nil
    :preface
    (defun my--nl-var (name fallback)
      (expand-file-name name (if (boundp 'no-littering-var-directory)
                                 no-littering-var-directory
                               (locate-user-emacs-file ".var/"))))
    :custom
    `((tramp-persistency-file-name . ,(my--nl-var "tramp" ".var/tramp"))
      (tramp-auto-save-directory   . ,(my--nl-var "tramp-autosave" ".var/tramp-autosave"))
      (tramp-default-method        . "scp")
      (tramp-verbose               . 3)))

  ;; ---------------------------------------------------------------------------
  ;; Auto-save / backup
  (leaf files :straight nil
    :custom
    `((auto-save-file-name-transforms
       . '((".*" ,(expand-file-name "backup/" (if (boundp 'no-littering-var-directory)
                                                  no-littering-var-directory
                                                (locate-user-emacs-file ".var/"))) t)))
      (auto-save-list-file-prefix
       . ,(expand-file-name "auto-save-list/.saves-"
                            (if (boundp 'no-littering-var-directory)
                                no-littering-var-directory
                              (locate-user-emacs-file ".var/"))))
      (backup-directory-alist
       . '(("." . ,(expand-file-name "backup/"
                                     (if (boundp 'no-littering-var-directory)
                                         no-littering-var-directory
                                       (locate-user-emacs-file ".var/"))))))
      (delete-old-versions . t)))
  (let ((var (if (boundp 'no-littering-var-directory)
                 no-littering-var-directory
               (locate-user-emacs-file ".var/"))))
    (when (fboundp 'my/ensure-directory-exists)
      (my/ensure-directory-exists (expand-file-name "backup/" var))
      (my/ensure-directory-exists (expand-file-name "auto-save-list/" var))))

  ;; ---------------------------------------------------------------------------
  ;; Authentication
  (defvar my:d:password-store
    (or (getenv "PASSWORD_STORE_DIR")
        (expand-file-name "password-store/"
                          (if (boundp 'no-littering-var-directory)
                              no-littering-var-directory
                            (locate-user-emacs-file ".var/"))))
    "Path to the password store.")

  (defun my/auth-check-env ()
    "Validate authentication environment and warn if misconfigured."
    (unless (getenv "GPG_KEY_ID")
      (display-warning 'auth "GPG_KEY_ID is not set." :level 'debug))
    (unless (file-directory-p my:d:password-store)
      (display-warning 'auth
                       (format "Password store directory does not exist: %s"
                               my:d:password-store)
                       :level 'warning)))

  (leaf *authentication :straight nil
    :init (my/auth-check-env)
    (leaf epa-file :straight nil
      :commands (epa-file-enable)
      :init
      (setq epa-pinentry-mode
            (if (getenv "USE_GPG_LOOPBACK") 'loopback 'default))
      (add-hook 'emacs-startup-hook #'epa-file-enable))
    (leaf auth-source :straight nil
      :init
      (with-eval-after-load 'auth-source
        (let ((key (getenv "GPG_KEY_ID")))
          (if key
              (setq auth-source-gpg-encrypt-to key)
            (display-warning 'auth-source
                             "GPG_KEY_ID is not set. Auth backends may be limited.")))))
    (leaf password-store :straight t)
    (leaf auth-source-pass :straight t
      :commands (auth-source-pass-enable)
      :hook (emacs-startup-hook . (lambda ()
                                    (when (executable-find "pass")
                                      (auth-source-pass-enable)))))
    (leaf plstore :straight nil
      :init
      (with-eval-after-load 'plstore
        (setq plstore-secret-keys 'silent
              plstore-encrypt-to (getenv "GPG_KEY_ID")))))

  (provide 'core/general)
  ;;; core/general.el ends here
#+end_src

*** core/autoorsave.el
:PROPERTIES:
:CUSTOM_ID: core-auto-save
:END:

**Purpose**
Hide the `auto-save-list/` directory under `no-littering-var-directory` (e.g., `.var/auto-save-list/`) and keep all auto-save artifacts out of the project root.

**What it does**
- Ensures `.var/auto-save-list/` exists and points `auto-save-list-file-prefix` there.
- Redirects auto-saved file fragments to `.var/backup/` via `auto-save-file-name-transforms`.
- (Optional) Redirects TRAMP auto-saves to `.var/tramp-autosave/`.

**Notes**
- Falls back gracefully if `no-littering` is not installed by defining `no-littering-var-directory` locally.
- Uses `my/ensure-directory-exists` when available; otherwise defines a safe fallback.

#+begin_src emacs-lisp :tangle lisp/core/auto-save.el
  ;;; auto-save.el --- Keep auto-saves under .var/ -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Centralize auto-save artifacts below no-littering-var-directory to avoid
  ;; polluting the project root and $HOME. Creates directories defensively.
  ;;; Code:

  (require 'subr-x)

  ;; Fallback for no-littering var dir (override if no-littering is present)
  (defvar no-littering-var-directory
    (expand-file-name ".var/"
                      (or (and load-file-name (file-name-directory (file-chase-links load-file-name)))
                          user-emacs-directory))
    "Variable data directory (usually provided by no-littering).")

  ;; Try to use the shared helper if present; otherwise define a minimal version.
  (unless (fboundp 'my/ensure-directory-exists)
    (defun my/ensure-directory-exists (dir)
      "Create DIR recursively if missing; warn on failure."
      (unless (file-directory-p dir)
        (condition-case err
            (make-directory dir t)
          (error (warn "[core/auto-save] mkdir failed: %s (%s)"
                       dir (error-message-string err)))))))

  ;; Directories we manage
  (defconst my:d:autosave-list (expand-file-name "auto-save-list/" no-littering-var-directory))
  (defconst my:d:backup        (expand-file-name "backup/"         no-littering-var-directory))
  (defconst my:d:tramp-autosave (expand-file-name "tramp-autosave/" no-littering-var-directory))

  ;; Ensure they exist
  (dolist (d (list my:d:autosave-list my:d:backup my:d:tramp-autosave))
    (my/ensure-directory-exists d))

  ;; 1) Put auto-save *list* files (the .saves-*) under .var/auto-save-list/
  ;;    Emacs will create files like .saves-<PID>-<HOSTNAME> in this directory.
  (setopt auto-save-list-file-prefix (expand-file-name ".saves-" my:d:autosave-list))

  ;; 2) Put auto-saved *file fragments* under .var/backup/
  ;;    This controls where #foo# and similar temporary auto-saves live.
  ;;    Note: The 3rd element `t` preserves directory structure to avoid collisions.
  (setopt auto-save-file-name-transforms
          `((".*" ,(file-name-as-directory my:d:backup) t)))

  ;; 3) (Optional) Keep TRAMP auto-saves local and hidden as well.
  (with-eval-after-load 'tramp
    (setopt tramp-auto-save-directory my:d:tramp-autosave))

  (provide 'core/auto-save)
  ;;; auto-save.el ends here
#+end_src

*** core/tools.el
:PROPERTIES:
:CUSTOM_ID: core-tools
:END:

**Purpose**
Utility commands for windows, Dired helpers, Tree-sitter, environment/build info, and Org folding.

**What it does**
- Safer window split toggle; Dired view helper.
- Tree-sitter install advice uses local grammar dirs.
- VSCode opener, environment echo, guarded build-info buffer.
- Org fold helpers with keybindings.

**Notes**
- Guards around git metadata retrieval avoid errors when Emacs isn’t built from a git repo.

#+begin_src emacs-lisp :tangle lisp/core/tools.el
  ;;; core/tools.el --- Developer & UI helper tools -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Small helper library used by multiple modules.
  ;;; Code:

  (require 'subr-x)

  ;; UI & Navigation Helpers
  (defun my/toggle-linum-lines ()
    "Toggle line numbers."
    (interactive) (display-line-numbers-mode 'toggle))

  (defun my/toggle-window-split ()
    "Toggle between horizontal and vertical split for exactly two windows."
    (interactive)
    (when (= (count-windows) 2)
      (let* ((this-buf (window-buffer))
             (next-buf (window-buffer (next-window)))
             (this-edges (window-edges))
             (next-edges (window-edges (next-window)))
             (split-vert (eq (car this-edges) (car next-edges)))
             (split-fn (if split-vert #'split-window-horizontally #'split-window-vertically)))
        (delete-other-windows)
        (funcall split-fn)
        (set-window-buffer (selected-window) this-buf)
        (set-window-buffer (next-window) next-buf))))

  ;; Dired Helper
  (defun my/dired-view-file-other-window ()
    "Open selected Dired file or directory in another window."
    (interactive)
    (let ((file (dired-get-file-for-visit)))
      (if (file-directory-p file)
          (or (and (cdr dired-subdir-alist) (dired-goto-subdir file)) (dired file))
        (view-file-other-window file))))

  ;; Tree-sitter Integration
  (defvar my:d:treesit (expand-file-name "tree-sitter/" (or (bound-and-true-p my:d:var)
                                                            (locate-user-emacs-file ".var/"))))
  (defvar my:d:treesit-build (expand-file-name "treesit-build/" (or (bound-and-true-p my:d:cache)
                                                                    (locate-user-emacs-file ".cache/"))))

  (defun my/treesit--call-with-outdir (orig-fn &rest args)
    "Advice ORIG-FN to force OUT-DIR to `my:d:treesit` when omitted."
    (let* ((len (length args))
           (args* (append args (make-list (max 0 (- 7 len)) nil)))
           (out-dir (or (nth 6 args*) my:d:treesit)))
      (setf (nth 6 args*) out-dir)
      (when (fboundp 'my/ensure-directory-exists)
        (my/ensure-directory-exists out-dir))
      (let ((default-directory my:d:treesit-build))
        (apply orig-fn args*))))

  (defun my/treesit-install (lang)
    "Install a tree-sitter grammar for LANG interactively."
    (interactive
     (list (intern (completing-read "Language: " (mapcar #'car treesit-language-source-alist)))))
    (treesit-install-language-grammar lang))

  (with-eval-after-load 'treesit
    (add-to-list 'treesit-extra-load-path my:d:treesit)
    (advice-add 'treesit-install-language-grammar :around #'my/treesit--call-with-outdir))

  ;; External Integration
  (defun my/open-by-vscode ()
    "Open current file & position in VSCode."
    (interactive)
    (when (buffer-file-name)
      (async-shell-command
       (format "code -r -g %s:%d:%d"
               (shell-quote-argument (buffer-file-name))
               (line-number-at-pos)
               (current-column)))))

  (defun my/show-env-variable (var)
    "Echo environment variable VAR."
    (interactive "sEnvironment variable: ")
    (message "%s = %s" var (or (getenv var) "Not set")))

  (defun my/print-build-info ()
    "Show a small buffer with build information (guards non-git builds)."
    (interactive)
    (let ((buf (get-buffer-create "*Build Info*")))
      (with-current-buffer buf
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (format "- GNU Emacs *%s*\n\n" emacs-version))
          (insert "|Property|Value|\n|--------|-----|\n")
          (when (fboundp 'emacs-repository-get-version)
            (insert (format "|Commit|%s|\n" (emacs-repository-get-version))))
          (when (fboundp 'emacs-repository-get-branch)
            (insert (format "|Branch|%s|\n" (emacs-repository-get-branch))))
          (insert (format "|System|%s|\n" system-configuration))
          (insert (format "|Date|%s|\n"
                          (format-time-string "%Y-%m-%d %T (%Z)" emacs-build-time)))
          (when (boundp 'system-configuration-features)
            (insert (format "|Features|%s|\n" system-configuration-features)))
          (when (boundp 'system-configuration-options)
            (insert (format "|Options|%s|\n" system-configuration-options))))
        (view-mode 1))
      (pop-to-buffer buf)))

  ;; Org Helpers
  (with-eval-after-load 'org
    (require 'org-fold)
    (defun my/org-fold-subtree ()   (interactive) (org-fold-subtree t))
    (defun my/org-unfold-subtree () (interactive) (org-show-subtree))
    (defun my/org-toggle-fold ()
      (interactive)
      (save-excursion
        (org-back-to-heading t)
        (if (org-fold-folded-p (point))
            (org-show-subtree)
          (org-fold-subtree t))))
    (define-key org-mode-map (kbd "C-c C-f") #'my/org-fold-subtree)
    (define-key org-mode-map (kbd "C-c C-e") #'my/org-unfold-subtree)
    (define-key org-mode-map (kbd "C-c C-t") #'my/org-toggle-fold))

  (provide 'core/tools)
  ;;; core/tools.el ends here
#+end_src

*** core/utils.el
:PROPERTIES:
:CUSTOM_ID: core-utils
:END:

**Purpose**
Core hooks/utilities: timestamp, Org auto-tangle, quick revert, lexical-binding header, read-only view-mode.

**What it does**
- `$Lastupdate` timestamp on save.
- Auto-tangle `README.org` on save (non-interactive).
- Insert `lexical-binding` header in generated `.el` under `.var/` when missing.
- Toggle `view-mode` with `read-only-mode`.

**Notes**
- Guards around paths when `no-littering` is not present.

#+begin_src emacs-lisp :tangle lisp/core/utils.el
  ;;; core/utils.el --- Core utility helpers -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Small helpers wired via hooks; side-effect-light.
  ;;; Code:

  (defun my/save-buffer-wrapper ()
    "Insert or update a `$Lastupdate` timestamp at the top of the buffer."
    (interactive)
    (let ((timestamp (concat "$Lastupdate: " (format-time-string "%Y/%m/%d %H:%M:%S") " $")))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "\\$Lastupdate: [0-9/: ]*\\$" nil t)
          (replace-match timestamp t nil)))))

  (add-hook 'after-save-hook #'my/save-buffer-wrapper)

  (defun my/auto-tangle-updated-src-blocks ()
    "Automatically tangle Org source blocks when saving README.org."
    (when (and buffer-file-name
               (string= (file-name-nondirectory buffer-file-name) "README.org"))
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'after-save-hook #'my/auto-tangle-updated-src-blocks nil 'make-it-local)))

  (defun my/revert-buffer-quick () (interactive) (revert-buffer :ignore-auto :noconfirm))

  (defun my/auto-insert-lexical-binding ()
    "Insert `lexical-binding: t` in Emacs Lisp files under `.var/` if missing."
    (when (and (stringp buffer-file-name)
               (string-match-p "\\.el\\'" buffer-file-name)
               (not (save-excursion (goto-char (point-min))
                                    (re-search-forward "lexical-binding" (line-end-position 5) t))))
      (save-excursion (goto-char (point-min))
                      (insert ";; -*- lexical-binding: t; -*-\n"))))

  (add-hook 'find-file-hook #'my/auto-insert-lexical-binding)

  (defun my/enable-view-mode-on-read-only ()
    "Enable `view-mode` when buffer is read-only; disable otherwise."
    (if buffer-read-only (view-mode 1) (view-mode -1)))

  (add-hook 'read-only-mode-hook #'my/enable-view-mode-on-read-only)

  (provide 'core/utils)
  ;;; core/utils.el ends here
#+end_src

*** core/history.el
:PROPERTIES:
:CUSTOM_ID: core-history
:END:

**Purpose**
Persist cursor positions, recent files, minibuffer history; auto-revert changed files; transient state.

**What it does**
- Enables `save-place-mode`, `recentf-mode`, `savehist-mode`, `global-auto-revert-mode`.
- Stores all artifacts under `.var/` when possible.

**Notes**
- Built-ins explicitly use `:straight nil`.

#+begin_src emacs-lisp :tangle lisp/core/history.el
  ;;; core/history.el --- Session persistence & autorevert -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Persistence of positions/history and automatic file reloading.
  ;;; Code:

  (leaf saveplace :straight nil
    :init
    (setq save-place-file
          (expand-file-name "saveplace"
                            (if (boundp 'no-littering-var-directory)
                                no-littering-var-directory
                              (locate-user-emacs-file ".var/"))))
    (save-place-mode +1))

  (leaf recentf :straight nil
    :init
    (setq recentf-max-saved-items 100
          recentf-save-file
          (expand-file-name "recentf"
                            (if (boundp 'no-littering-var-directory)
                                no-littering-var-directory
                              (locate-user-emacs-file ".var/"))))
    (recentf-mode +1))

  (leaf savehist :straight nil
    :global-minor-mode t
    :config
    (setq savehist-file
          (expand-file-name "history"
                            (if (boundp 'no-littering-var-directory)
                                no-littering-var-directory
                              (locate-user-emacs-file ".var/"))))
    (when (fboundp 'my/ensure-directory-exists)
      (my/ensure-directory-exists (file-name-directory savehist-file))))

  (leaf autorevert :straight nil
    :custom ((auto-revert-interval . 2)
             (auto-revert-verbose  . nil))
    :global-minor-mode global-auto-revert-mode)

  ;; Transient state files
  (leaf transient :straight t
    :config
    (let ((var (if (boundp 'no-littering-var-directory)
                   no-littering-var-directory
                 (locate-user-emacs-file ".var/"))))
      (setq transient-history-file (expand-file-name "transient/history.el" var)
            transient-levels-file  (expand-file-name "transient/levels.el"  var)
            transient-values-file  (expand-file-name "transient/values.el"  var))
      (when (fboundp 'my/ensure-directory-exists)
        (my/ensure-directory-exists (expand-file-name "transient/" var)))))

  (provide 'core/history)
  ;;; core/history.el ends here
#+end_src

*** core/editing.el
:PROPERTIES:
:CUSTOM_ID: core-editing
:END:

**Purpose**
Modern structural editing, paren/sexp helpers, which-key, undo helpers, soft wrap, and Dired UI helpers.

**What it does**
- `paredit` for Lisp, `puni` globally with minibuffer guard.
- `show-paren-mode`, `which-key`, `ace-window`, `vundo`, `undo-fu`.
- `expand-region`, `aggressive-indent`, `delete-selection-mode`.
- `dired-filter`, `dired-subtree`.

**Notes**
- Built-ins marked `:straight nil`. Avoids loading non-existent libraries by using proper features.

#+begin_src emacs-lisp :tangle lisp/core/editing.el
;;; core/editing.el --- Editing helpers & UX aids -*- lexical-binding: t; -*-
;; License: GNU GPL v3 or later
;;; Commentary:
;; Editing comfort features with minimal global side effects.
;;; Code:

(leaf paredit :straight t
  :hook (emacs-lisp-mode . (lambda () (paredit-mode 1) (electric-pair-local-mode -1))))

(leaf paren :straight nil
  :custom ((show-paren-delay . 0)
           (show-paren-style . 'expression)
           (show-paren-highlight-openparen . t))
  :global-minor-mode show-paren-mode)

(leaf puni :straight t
  :global-minor-mode puni-global-mode
  :hook ((minibuffer-setup . (lambda () (puni-global-mode -1)))))

(leaf which-key :straight t
  :global-minor-mode t
  :custom ((which-key-idle-delay . 0.5)))

(leaf undo-fu :straight t
  :custom ((undo-fu-allow-undo-in-region . t)))

(leaf vundo :straight t
  :bind (("C-c u" . vundo)))

(leaf ace-window :straight t
  :custom ((aw-keys . '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
           (aw-scope . 'frame)
           (aw-background . t))
  :config (ace-window-display-mode 1))

;; Soft wrap (feature 'simple provides visual-line-mode)
(leaf simple :straight nil
  :hook (text-mode . visual-line-mode))

(leaf dired-filter :straight t)
(leaf dired-subtree :straight t :after dired)

(leaf expand-region :straight t :after treesit)
(leaf aggressive-indent :straight t :hook (prog-mode . aggressive-indent-mode))
(leaf delsel :straight nil :global-minor-mode delete-selection-mode)

(provide 'core/editing)
;;; core/editing.el ends here
#+end_src

*** core/eww.el
:PROPERTIES:
:CUSTOM_ID: core-eww
:END:

**Purpose**
QoL for EWW: search primed for isearch, toggle images, history/bookmarks locations.

**What it does**
- `my/eww-search` sets initial isearch.
- `my/eww-toggle-images` toggles images and reloads.
- Stores bookmarks under `.var/` when possible.

**Notes**
- EWW is built-in; `:straight nil`.

#+begin_src emacs-lisp :tangle lisp/core/eww.el
  ;;; core/eww.el --- EWW helpers -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Small helpers and sane defaults for EWW.
  ;;; Code:

  (leaf eww :straight nil
    :custom ((eww-search-prefix . "https://duckduckgo.com/html/?kl=jp-jp&k1=-1&kc=1&kf=-1&q=")
             (eww-download-directory . "~/Downloads"))
    :init
    (let ((var (if (boundp 'no-littering-var-directory)
                   no-littering-var-directory
                 (locate-user-emacs-file ".var/"))))
      (setq eww-bookmarks-file (expand-file-name "eww-bookmarks" var)))
    (setq eww-history-limit 200)
    (defvar eww-hl-search-word nil
      "Word to highlight with isearch after EWW loads.")
    (defun my/eww-search (term)
      "Search TERM with EWW and start isearch."
      (interactive "sSearch terms: ")
      (setq eww-hl-search-word term)
      (eww-browse-url (concat eww-search-prefix term)))
    (add-hook 'eww-after-render-hook
              (lambda ()
                (when eww-hl-search-word
                  (isearch-mode t)
                  (isearch-yank-string eww-hl-search-word)
                  (setq eww-hl-search-word nil))))
    (defun my/eww-toggle-images ()
      "Toggle images in EWW and reload."
      (interactive)
      (setq shr-inhibit-images (not shr-inhibit-images))
      (eww-reload)))

  (provide 'core/eww)
  ;;; core/eww.el ends here
#+end_src

*** ui/ui-faces-sanitize.el
:PROPERTIES:
:CUSTOM_ID: ui-faces-sanitize
:END:

**Purpose**
Eliminate the warning:
“setting attribute ‘:foreground’ of face ‘font-lock-doc-markup-face’: nil value is invalid, use ‘unspecified’ instead”
without breaking callers of `set-face-attribute`.

**What it does**
- Removes any global `:filter-args` advice (which can mis-handle call shapes).
- Adds a **narrow :around advice** that only sanitizes `:foreground nil` when the face is `font-lock-doc-markup-face`, converting it to `'unspecified`.
- Adds a small **post-theme normalizer** as a safety net.

**Notes**
- This advice is minimal and only touches the one problematic face/attribute.
- Load this early (your `modules.el` already lists it before theme/UI blocks).

#+begin_src emacs-lisp :tangle lisp/ui/ui-faces-sanitize.el
;;; ui-faces-sanitize.el --- Sanitize doc-markup face safely -*- lexical-binding: t; -*-
;;; Commentary:
;; Avoid the warning:
;;   setting attribute ‘:foreground’ of face ‘font-lock-doc-markup-face’:
;;   nil value is invalid, use ‘unspecified’ instead.
;; We do NOT use :filter-args (which caused assertions in some call paths).
;; Instead, apply a narrow :around advice that only sanitizes the problematic case.
;;; Code:

(defvar my/ui--faces-sanitize-installed nil
  "Non-nil when our around-advice for `set-face-attribute` is installed.")

(defun my/ui--sanitize-doc-markup-foreground (orig face frame &rest attrs)
  "Around advice: sanitize `:foreground nil` when FACE is the doc-markup face."
  (if (not (eq face 'font-lock-doc-markup-face))
      (apply orig face frame attrs)
    (let ((rest attrs) out)
      (while rest
        (let ((k (pop rest))
              (v (pop rest)))
          (when (and (eq k :foreground) (eq v nil))
            (setq v 'unspecified))
          (push v out) (push k out)))
      (apply orig face frame (nreverse out)))))

(unless my/ui--faces-sanitize-installed
  (advice-add 'set-face-attribute :around #'my/ui--sanitize-doc-markup-foreground)
  (setq my/ui--faces-sanitize-installed t))

;; Post-theme normalizer (belt and suspenders).
(defun my/ui--normalize-doc-markup-face ()
  "Ensure `font-lock-doc-markup-face` has a non-nil :foreground."
  (when (eq (face-attribute 'font-lock-doc-markup-face :foreground nil 'default) nil)
    (set-face-attribute 'font-lock-doc-markup-face nil :foreground 'unspecified)))

(add-hook 'emacs-startup-hook #'my/ui--normalize-doc-markup-face)
(when (boundp 'enable-theme-functions)
  (add-hook 'enable-theme-functions (lambda (&rest _) (my/ui--normalize-doc-markup-face))))
(when (boundp 'after-load-theme-hook)
  (add-hook 'after-load-theme-hook #'my/ui--normalize-doc-markup-face))

(provide 'ui/ui-faces-sanitize)
;;; ui-faces-sanitize.el ends here
#+end_src

*** ui/ui-font.el
:PROPERTIES:
:CUSTOM_ID: ui-font
:END:

**Purpose**
Font setup for default/variable-pitch/emoji and ligatures.

**What it does**
- Picks OS-appropriate defaults when user overrides are absent.
- Enables `ligature` in `prog-mode`.

**Notes**
- Applies only in GUI frames (daemon-friendly).

#+begin_src emacs-lisp :tangle lisp/ui/ui-font.el
  ;;; ui/ui-font.el --- Font configuration -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Fonts and ligatures for GUI frames.
  ;;; Code:

  (defun my/system-default-font ()
    "Return a default monospace font family depending on OS."
    (cond ((eq system-type 'darwin) "Menlo")
          ((eq system-type 'gnu/linux) "Monospace")
          ((eq system-type 'windows-nt) "Consolas")
          (t "Monospace")))

  (defun my/system-emoji-font ()
    "Return a default emoji font family depending on OS."
    (cond ((eq system-type 'darwin) "Apple Color Emoji")
          ((eq system-type 'gnu/linux) "Noto Color Emoji")
          ((eq system-type 'windows-nt) "Segoe UI Emoji")
          (t "Noto Color Emoji")))

  (defun my/font-setup ()
    "Apply font settings, respecting user overrides."
    (when (display-graphic-p)
      (set-face-attribute 'default nil
                          :family (or (bound-and-true-p my:font-default) (my/system-default-font))
                          :height (* 10 (or (bound-and-true-p my:font-size) 16)))
      (set-face-attribute 'variable-pitch nil
                          :family (or (bound-and-true-p my:font-alt) (my/system-default-font)))
      (set-fontset-font t 'emoji
                        (font-spec :family (or (bound-and-true-p my:emoji-font)
                                                (my/system-emoji-font))))))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame) (with-selected-frame frame (my/font-setup))))
    (add-hook 'after-init-hook #'my/font-setup))

  (leaf ligature :straight t
    :config
    (ligature-set-ligatures 'prog-mode '("->" "=>" "::" "===" "!=" "&&" "||"))
    (global-ligature-mode 1))

  (provide 'ui/ui-font)
  ;;; ui/ui-font.el ends here
#+end_src

**** ui/ui-theme.el
:PROPERTIES:
:CUSTOM_ID: ui-theme
:END:

**Purpose**
Theme management with `ef-themes` and `spacious-padding`, plus a **safe face-normalizer** that avoids setting face attributes to `nil` (which causes warnings in Emacs 30+).

**What it does**
- Keeps your original theme setup (incl. `(modus-themes-to-toggle . '(ef-frost ef-spring))`).
- Adds `ui--normalize-faces-after-theme` to set problematic face attributes to `'unspecified` instead of `nil`.
- Hooks the normalizer to `after-load-theme-hook` and runs it once at init.

**Notes**
If your `custom-file` (under `.etc/custom.el`) sets any face attribute to `nil`, this helper will correct it at runtime to prevent warnings like:
`Warning: setting attribute ‘:foreground’ of face ‘font-lock-doc-markup-face’: nil value is invalid, use ‘unspecified’ instead.`

#+begin_src emacs-lisp :tangle lisp/ui/ui-theme.el
  ;;; ui/ui-theme.el --- Theme configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Theme management (ef-themes + spacious-padding) and a face normalizer that
  ;; replaces invalid `nil` attributes with `unspecified` to avoid warnings on
  ;; Emacs 30+ (e.g., font-lock-doc-markup-face :foreground nil).
  ;; Category: ui
  ;;;
  ;;; Code:

  (leaf ef-themes :straight t
    ;; Keep the user's original toggle pair as requested.
    :custom ((modus-themes-to-toggle . '(ef-frost ef-spring)))
    :config
    (unless custom-enabled-themes
      (load-theme (if (display-graphic-p) 'ef-frost 'deeper-blue) t)))

  (leaf spacious-padding :straight t
    :if (display-graphic-p)
    :custom ((spacious-padding-widths . '((left . 15) (right . 15)))
             (spacious-padding-subtle-mode-line . t))
    :config (spacious-padding-mode 1))

  ;;;; Face normalization --------------------------------------------------------
  ;; Emacs 30+: setting a face attribute to NIL is invalid; use 'unspecified.

  (defgroup ui-theme-normalize nil
    "Normalize face attributes set to nil."
    :group 'faces)

  (defcustom ui:normalize-face-attrs
    '((font-lock-doc-markup-face :foreground))
    "List of (FACE ATTR ...) pairs to ensure are not nil."
    :type '(repeat (cons symbol (repeat symbol)))
    :group 'ui-theme-normalize)

  (defun ui--normalize-face-attr (face attr)
    "If FACE's ATTR is nil, set it to 'unspecified to avoid warnings."
    (when (facep face)
      (let ((val (face-attribute face attr nil 'default)))
        (when (null val)
          (set-face-attribute face nil attr 'unspecified)))))

  (defun ui--normalize-faces ()
    "Normalize all faces declared in `ui:normalize-face-attrs`."
    (dolist (entry ui:normalize-face-attrs)
      (let ((face (car entry))
            (attrs (cdr entry)))
        (dolist (attr attrs)
          (ui--normalize-face-attr face attr)))))

  ;; Run after any theme is enabled (THEME arg is ignored).
  (add-hook 'enable-theme-functions
            (lambda (_theme) (ui--normalize-faces)))

  ;; Also run once at startup (covers custom-file faces before first theme load).
  (add-hook 'emacs-startup-hook #'ui--normalize-faces)

  ;; Back-compat: if something still calls the old name with args, don't error.
  (defun ui--normalize-faces-after-theme (&rest _ignore)
    "Compatibility shim; call `ui--normalize-faces' and ignore extra args."
    (ui--normalize-faces))

  (defcustom ui:normalize-face-attrs
    '((font-lock-doc-markup-face :foreground))
    "List of (FACE ATTR ...) pairs to ensure are not nil."
    :type '(repeat (cons symbol (repeat symbol)))
    :group 'ui-theme-normalize)

  (defun ui--normalize-face-attr (face attr)
    "If FACE's ATTR is nil, set it to 'unspecified to avoid warnings."
    (when (facep face)
      (let ((val (face-attribute face attr nil 'default)))
        (when (null val)
          (set-face-attribute face nil attr 'unspecified)))))

  (defun ui--normalize-faces ()
    "Normalize all faces declared in `ui:normalize-face-attrs`."
    (dolist (entry ui:normalize-face-attrs)
      (let ((face (car entry))
            (attrs (cdr entry)))
        (dolist (attr attrs)
          (ui--normalize-face-attr face attr)))))

  (add-hook 'enable-theme-functions (lambda (_theme) (ui--normalize-faces)))
  (add-hook 'emacs-startup-hook #'ui--normalize-faces)

  (defun ui--normalize-faces-after-theme (&rest _) (ui--normalize-faces))

  (provide 'ui/ui-theme)
  ;;; ui/ui-theme.el ends here
#+end_src

*** ui/ui-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-modeline
:END:

**Purpose**
Modeline essentials, time, and battery display.

**What it does**
- Enables `doom-modeline` and `minions`.
- Shows time every 30s; shows battery when available.

**Notes**
- GUI/TTY friendly.

#+begin_src emacs-lisp :tangle lisp/ui/ui-modeline.el
  ;;; ui/ui-modeline.el --- Modeline configuration -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Modeline widgets and lightweight indicators.
  ;;; Code:

  (leaf doom-modeline :straight t
    :hook (after-init-hook . doom-modeline-mode))

  (leaf minions :straight t
    :custom ((minions-mode-line-lighter . "⚙"))
    :hook (after-init-hook . minions-mode))

  (setq display-time-interval 30
        display-time-day-and-date t
        display-time-24hr-format t)
  (display-time-mode 1)
  (when (fboundp 'display-battery-mode) (display-battery-mode 1))

  (provide 'ui/ui-modeline)
  ;;; ui/ui-modeline.el ends here
#+end_src

*** ui/ui-window.el
:PROPERTIES:
:CUSTOM_ID: ui-window
:END:

**Purpose**
Window management: fullscreen on startup, zoom, tabs, and save/restore layout.

**What it does**
- Fullscreen frames at startup (daemon-aware).
- `zoom-mode` defaults; `tab-bar` and `tab-line` enabled after init.
- Save/restore window layout via simple commands.

**Notes**
- Built-ins use `:straight nil`.

#+begin_src emacs-lisp :tangle lisp/ui/ui-window.el
  ;;; ui/ui-window.el --- Window management -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Window/frame ergonomics with minimal globals.
  ;;; Code:

  (defun my/set-frame-fullscreen (&optional frame)
    "Set FRAME (or current) to fullscreen in GUI sessions."
    (when (display-graphic-p frame)
      (set-frame-parameter (or frame (selected-frame)) 'fullscreen 'fullboth)))

  (if (daemonp)
      (add-hook 'after-make-frame-functions #'my/set-frame-fullscreen)
    (add-hook 'emacs-startup-hook #'my/set-frame-fullscreen))

  (leaf zoom :straight t
    :hook (after-init-hook . zoom-mode)
    :custom ((zoom-size . '(0.62 . 0.62))
             (zoom-ignored-major-modes . '(dired-mode treemacs-mode))
             (zoom-ignored-buffer-names . '("*Messages*" "*Help*"))))

  (leaf tab-bar :straight nil
    :custom ((tab-bar-show . 1)
             (tab-bar-new-tab-choice . "*scratch*"))
    :hook (after-init-hook . tab-bar-mode))

  (leaf tab-line :straight nil
    :hook (after-init-hook . global-tab-line-mode))

  (defvar my:saved-window-config nil)

  (defun my/save-window-layout ()
    "Save current window configuration."
    (interactive)
    (setq my:saved-window-config (window-state-get nil t))
    (message "Window configuration saved."))

  (defun my/restore-window-layout ()
    "Restore last saved window configuration."
    (interactive)
    (if my:saved-window-config
        (window-state-put my:saved-window-config)
      (message "No saved window configuration found.")))

  (provide 'ui/ui-window)
  ;;; ui/ui-window.el ends here
#+end_src

v*** ui/ui-treemacs.el
:PROPERTIES:
:CUSTOM_ID: ui-treemacs
:END:

**Purpose**
Sidebar project/file explorer with icons.

**What it does**
- Configures Treemacs with follow/filewatch.
- Adds `nerd-icons-dired` in Dired.

**Notes**
- GUI only for Treemacs.

#+begin_src emacs-lisp :tangle lisp/ui/ui-treemacs.el
  ;;; ui/ui-treemacs.el --- Treemacs configuration -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; Treemacs and Dired icons.
  ;;; Code:

  (leaf treemacs :straight t
    :if (display-graphic-p)
    :custom ((treemacs-filewatch-mode . t)
             (treemacs-follow-mode . t)
             (treemacs-indentation . 2)
             (treemacs-missing-project-action . 'remove)))

  (leaf nerd-icons-dired :straight t
    :hook (dired-mode . nerd-icons-dired-mode))

  (provide 'ui/ui-treemacs)
  ;;; ui/ui-treemacs.el ends here
#+end_src

*** ui/ui-clipboard.el
:PROPERTIES:
:CUSTOM_ID: ui-clipboard
:END:

**Purpose**
Use macOS clipboard seamlessly from Emacs.

**What it does**
- Enables `pbcopy` integration in macOS GUI frames.

**Notes**
- Conditional on `window-system` being `mac`/`ns`.

#+begin_src emacs-lisp :tangle lisp/ui/ui-clipboard.el
  ;;; ui/ui-clipboard.el --- macOS clipboard integration -*- lexical-binding: t; -*-
  ;; License: GNU GPL v3 or later
  ;;; Commentary:
  ;; pbcopy bridge for macOS.
  ;;; Code:

  (leaf pbcopy
    :if (memq window-system '(mac ns))
    :straight t
    :config (turn-on-pbcopy))

  (provide 'ui/ui-clipboard)
  ;;; ui/ui-clipboard.el ends here
#+end_src

*** completion/completion-core.el
:PROPERTIES:
:CUSTOM_ID: completion-core
:END:

**Purpose**
Completion styles and persistence with Prescient; keep defaults predictable and fast.

**What it does**
- Enables `orderless` styles with sensible category overrides.
- Configures `prescient` save location under `.var/` and enables persistence.

**Notes**
- Keep this neutral; UI layers (Vertico/Corfu) live in their own files.

#+begin_src emacs-lisp :tangle lisp/completion/completion-core.el
  ;;; completion/completion-core.el --- Completion core settings -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Orderless + Prescient persistence. Keep UI pluggable.
  ;;; Code:

  (require 'subr-x)

  (defvar my:d:var
    (expand-file-name ".var/" (or (and load-file-name (file-name-directory (file-chase-links load-file-name)))
                                  user-emacs-directory))
    "Variable data directory (set by early-init.el).")

  (leaf orderless :straight t
    :custom
    ((completion-styles . '(orderless basic flex))
     (completion-category-overrides
      . '((file (styles . (partial-completion)))
          (symbol (styles . (flex)))
          (command (styles . (orderless)))))))

  (leaf prescient :straight t
    :custom ((prescient-aggressive-file-save . t))
    :config
    (setopt prescient-save-file (expand-file-name "prescient-save.el" my:d:var))
    (with-eval-after-load 'prescient
      (prescient-persist-mode 1)))

  (provide 'completion/completion-core)
  ;;; completion/completion-core.el ends here
#+end_src

*** completion/completion-vertico.el
:PROPERTIES:
:CUSTOM_ID: completion-vertico
:END:

**Purpose**
Minibuffer completion UI via Vertico, optional posframe, and rich annotations with Marginalia.

**What it does**
- Enables `vertico-mode` with a higher candidate count.
- Uses `vertico-posframe` only on GUI.
- Enables `marginalia-mode`.

**Notes**
- Keep xref/consult bindings in the consult module.

#+begin_src emacs-lisp :tangle lisp/completion/completion-vertico.el
  ;;; completion/completion-vertico.el --- Vertico minibuffer UI -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Vertico core UI + optional posframe + marginalia annotations.
  ;;; Code:

  (leaf vertico :straight t
    :global-minor-mode vertico-mode
    :custom ((vertico-count . 15)))

  (leaf vertico-posframe :straight t
    :if (display-graphic-p)
    :after vertico
    :custom ((vertico-posframe-border-width . 2))
    :config (vertico-posframe-mode 1))

  (leaf marginalia :straight t
    :global-minor-mode marginalia-mode)

  (provide 'completion/completion-vertico)
  ;;; completion/completion-vertico.el ends here
#+end_src

*** completion/completion-consult.el
:PROPERTIES:
:CUSTOM_ID: completion-consult
:END:

**Purpose**
Consult-powered search/navigation and xref integration.

**What it does**
- Binds xref providers to Consult.
- Leaves keybindings to higher-level keymap modules.

**Notes**
- Combine with ripgrep/project tools in utils/search-nav when needed.

#+begin_src emacs-lisp :tangle lisp/completion/completion-consult.el
  ;;; completion/completion-consult.el --- Consult search/navigation -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Xref integration with Consult.
  ;;; Code:

  (leaf consult :straight t
    :custom
    ((xref-show-xrefs-function . #'consult-xref)
     (xref-show-definitions-function . #'consult-xref)))

  (provide 'completion/completion-consult)
  ;;; completion/completion-consult.el ends here
#+end_src

*** completion/completion-embark.el
:PROPERTIES:
:CUSTOM_ID: completion-embark
:END:

**Purpose**
Contextual actions with Embark, integrated with Consult previews.

**What it does**
- Uses `embark-prefix-help-command`.
- Enables Consult preview in Embark Collect buffers.

**Notes**
- Keep custom keybindings in a dedicated keymap module.

#+begin_src emacs-lisp :tangle lisp/completion/completion-embark.el
  ;;; completion/completion-embark.el --- Embark actions -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Context actions + Consult preview integration.
  ;;; Code:

  (leaf embark :straight t
    :custom ((prefix-help-command . #'embark-prefix-help-command)))

  (leaf embark-consult :straight t
    :after (embark consult)
    :hook (embark-collect-mode . consult-preview-at-point-mode))

  (provide 'completion/completion-embark)
  ;;; completion/completion-embark.el ends here
#+end_src

*** completion/completion-corfu.el
:PROPERTIES:
:CUSTOM_ID: completion-corfu
:END:

**Purpose**
Popup completion via Corfu; icons via kind-icon; extra CAPF sources via Cape.

**What it does**
- Enables `global-corfu-mode` with auto/cycle.
- Adds kind-icon formatter to Corfu margin.
- Adds `cape-file`, `cape-dabbrev`, `cape-keyword` to `completion-at-point-functions`.

**Notes**
- Keep LSP completion in dev-lsp.

#+begin_src emacs-lisp :tangle lisp/completion/completion-corfu.el
  ;;; completion/completion-corfu.el --- Corfu popup completion -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Corfu UI + icons + additional CAPFs via Cape.
  ;;; Code:

  (leaf corfu :straight t
    :init (global-corfu-mode)
    :custom ((corfu-auto . t)
             (corfu-cycle . t)))

  (leaf kind-icon :straight t
    :after corfu
    :custom ((kind-icon-default-face . 'corfu-default))
    :config (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (leaf cape :straight t
    :init
    (dolist (fn '(cape-file cape-dabbrev cape-keyword))
      (add-to-list 'completion-at-point-functions fn)))

  (provide 'completion/completion-corfu)
  ;;; completion/completion-corfu.el ends here
#+end_src

*** completion/completion-icons.el
:PROPERTIES:
:CUSTOM_ID: completion-icons
:END:

**Purpose**
Nerd-icons integrations for ibuffer and completion UIs.

**What it does**
- Enables `nerd-icons-ibuffer`.
- Enables `nerd-icons-completion` with Marginalia setup.

**Notes**
- GUI-friendly; works in TTY as well.

#+begin_src emacs-lisp :tangle lisp/completion/completion-icons.el
  ;;; completion/completion-icons.el --- Nerd icons for completion -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Icons for Ibuffer and completion UIs.
  ;;; Code:

  (leaf nerd-icons-ibuffer :straight t
    :hook (ibuffer-mode-hook . nerd-icons-ibuffer-mode))

  (leaf nerd-icons-completion :straight t
    :hook (marginalia-mode-hook . nerd-icons-completion-marginalia-setup)
    :config (nerd-icons-completion-mode))

  (provide 'completion/completion-icons)
  ;;; completion/completion-icons.el ends here
#+end_src

*** org/org-core.el
:PROPERTIES:
:CUSTOM_ID: org-core
:END:

**Purpose**
Core Org setup: directories, agenda, capture, keywords, and refile targets.

**What it does**
- Creates `org/`, `journal/`, `org-roam/`, `pictures/` under `.var/`.
- Sets agenda files, TODO keywords, capture templates, and refile targets.

**Notes**
- If you use Emacs-bundled Org, change `:straight t` to `:straight nil`.

#+begin_src emacs-lisp :tangle lisp/org/org-core.el
  ;;; org/org-core.el --- Org Mode core configuration -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Base Org directories and workflow preferences.
  ;;; Code:

  (require 'subr-x)

  (defvar my:d:var
    (expand-file-name ".var/" (or (and load-file-name (file-name-directory (file-chase-links load-file-name)))
                                  user-emacs-directory))
    "Variable data directory (set by early-init.el).")

  (defvar my:d:org          (expand-file-name "org/"       my:d:var))
  (defvar my:d:org-journal  (expand-file-name "journal/"   my:d:org))
  (defvar my:d:org-roam     (expand-file-name "org-roam/"  my:d:org))
  (defvar my:d:org-pictures (expand-file-name "pictures/"  my:d:org))
  (defvar my:f:capture-blog-file (expand-file-name "blog.org" my:d:org))

  (dolist (d (list my:d:org my:d:org-journal my:d:org-roam my:d:org-pictures))
    (unless (file-directory-p d) (make-directory d t)))

  (leaf org :straight t
    :custom
    ((org-directory . my:d:org)
     (org-default-notes-file . "notes.org")
     (org-log-done . 'time)
     (org-support-shift-select . t)
     (org-return-follows-link . t))
    :config
    (setopt org-agenda-files
            (or (seq-filter (lambda (f)
                              (and (string-match-p "\\.org\\'" f)
                                   (not (string-match-p "archives" f))))
                            (directory-files-recursively org-directory "\\.org\\'"))
                (list (expand-file-name "inbox.org" org-directory))))
    (setopt org-todo-keywords
            '((sequence "TODO(t)" "SOMEDAY(s)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c@)")))
    (setopt org-refile-targets
            '((nil :maxlevel . 3)
              (org-agenda-files :maxlevel . 3)))
    (setopt org-capture-templates
            `(("t" "Todo" entry (file+headline ,(expand-file-name "gtd.org" org-directory) "Inbox")
               "* TODO %?\n %i\n %a")
              ("n" "Note" entry (file+headline ,(expand-file-name "notes.org" org-directory) "Notes")
               "* %?\nEntered on %U\n %i\n %a")
              ("j" "Journal" entry (file ,(expand-file-name "journal.org" org-directory))
               "* %<%Y-%m-%d %H:%M> %?"))))

  (provide 'org/org-core)
  ;;; org/org-core.el ends here
#+end_src

*** org/org-visual.el
:PROPERTIES:
:CUSTOM_ID: org-visual-modern
:END:

**Purpose**
Modernize Org visuals comprehensively using org-modern.

**Notes**
Remove any org-superstar setup to avoid duplicate bullet rendering.

#+begin_src emacs-lisp :tangle lisp/org/org-visual.el
  ;;; org/org-visual.el --- Org visuals (org-modern only) -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Use org-modern as the sole visual enhancer for Org.
  ;;; Code:

  (leaf org-modern :straight t
    :hook (org-mode . org-modern-mode)
    :custom
    ((org-startup-indented . t)
     (org-hide-leading-stars . t)
     (org-auto-align-tags . nil)
     (org-tags-column . 0)
     (org-catch-invisible-edits . 'show-and-error)
     (org-special-ctrl-a/e . t)
     (org-insert-heading-respect-content . t)
     (org-hide-emphasis-markers . t)
     (org-pretty-entities . t)
     (org-agenda-tags-column . 0)
     (org-agenda-block-separator . ?─)
     (org-agenda-time-grid .
                           '((daily today require-timed)
                             (800 1000 1200 1400 1600 1800 2000)
                             " ┄┄┄┄┄ " " ┄┄┄┄┄ "))
     (org-agenda-current-time-string . "⭠ now ─────────────────────────────────────────────────")))

  (provide 'org/org-visual)
  ;;; org/org-visual.el ends here
#+end_src
*** org/org-extensions.el
:PROPERTIES:
:CUSTOM_ID: org-extensions
:END:

**Purpose**
Useful Org extensions: journal, roam, download, toc-org, cliplink.

**What it does**
- Configures paths for journal/roam/downloads.
- Enables TOC generation and link capture helpers.

**Notes**
- Keep heavy integrations in dedicated files if they grow.

#+begin_src emacs-lisp :tangle lisp/org/org-extensions.el
  ;;; org/org-extensions.el --- Org Mode extensions -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Journal, Roam, download, TOC, and cliplink integrations.
  ;;; Code:

  (require 'subr-x)

  (defvar my:d:org-journal (expand-file-name "journal/" (expand-file-name "org/" (expand-file-name ".var/" user-emacs-directory))))
  (defvar my:d:org-roam    (expand-file-name "org-roam/" (expand-file-name "org/" (expand-file-name ".var/" user-emacs-directory))))
  (defvar my:d:org-pictures(expand-file-name "pictures/" (expand-file-name "org/" (expand-file-name ".var/" user-emacs-directory))))

  (leaf org-journal :straight t
    :custom ((org-journal-dir . my:d:org-journal)))

  (leaf org-roam :straight t
    :custom ((org-roam-directory . my:d:org-roam))
    :config
    (setopt org-roam-db-location (expand-file-name "org-roam.db" my:d:org-roam))
    (org-roam-db-autosync-mode))

  (leaf org-download :straight t
    :custom ((org-download-image-dir . my:d:org-pictures)))

  (leaf toc-org :straight t
    :hook ((org-mode . toc-org-enable)
           (markdown-mode . toc-org-mode)))

  (leaf org-cliplink :straight t
    :bind ("C-x p i" . org-cliplink))

  (provide 'org/org-extensions)
  ;;; org/org-extensions.el ends here
#+end_src

*** org/org-export.el
:PROPERTIES:
:CUSTOM_ID: org-export
:END:

**Purpose**
Export setup for LaTeX/Hugo/Markdown.

**What it does**
- Configures LaTeX packages and build pipeline.
- Enables Hugo exporter and Markdown preview.

**Notes**
- Ensure `pdflatex`/`bibtex` exist for LaTeX exports.

#+begin_src emacs-lisp :tangle lisp/org/org-export.el
  ;;; org/org-export.el --- Org export configuration -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; LaTeX, Hugo, and Markdown export helpers.
  ;;; Code:

  (leaf org-latex :straight nil
    :after org
    :custom
    ((org-latex-packages-alist
      '(("" "graphicx" t)
        ("" "longtable" nil)
        ("" "wrapfig" nil)))
     (org-latex-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
        "bibtex %b"
        "pdflatex -interaction nonstopmode -output-directory %o %f"
        "pdflatex -interaction nonstopmode -output-directory %o %f"))))

  (leaf ox-hugo :straight t
    :after ox
    :custom ((org-hugo-front-matter-format . "toml")))

  (leaf markdown-mode :straight t)
  (leaf markdown-preview-mode :straight t)

  (provide 'org/org-export)
  ;;; org/org-export.el ends here
#+end_src

*** dev/dev-lsp.el
:PROPERTIES:
:CUSTOM_ID: dev-lsp
:END:

**Purpose**
Language Server Protocol integrations via Eglot or lsp-mode.

**What it does**
- Chooses Eglot or lsp-mode by `my:use-lsp` variable.
- Auto-enables in `prog-mode` when server contact is available.
- Utility to temporarily enlarge `read-process-output-max`.

**Notes**
- Do not mix backends in the same session.

#+begin_src emacs-lisp :tangle lisp/dev/dev-lsp.el
  ;;; dev/dev-lsp.el --- LSP support -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Eglot or lsp-mode; pick one via `my:use-lsp`.
  ;;; Code:

  (defvar my:use-lsp 'eglot
    "Choose LSP backend: 'eglot or 'lsp.")

  (leaf eglot :straight t
    :when (eq my:use-lsp 'eglot)
    :commands (eglot eglot-ensure)
    :hook ((prog-mode . (lambda ()
                          (when (fboundp 'eglot--guess-contact)
                            (when (eglot--guess-contact) (eglot-ensure))))))
    :custom ((eglot-autoreconnect . t)))

  (leaf lsp-mode :straight t
    :when (eq my:use-lsp 'lsp)
    :commands (lsp lsp-deferred)
    :custom ((lsp-keymap-prefix . "C-c l"))
    :hook ((prog-mode . lsp-deferred)))

  (defun my/with-larger-rpom (size-bytes fn)
    "Call FN with `read-process-output-max` temporarily set to SIZE-BYTES."
    (let ((sym 'read-process-output-max)
          (orig (and (boundp 'read-process-output-max) read-process-output-max)))
      (when (boundp sym) (set sym size-bytes))
      (unwind-protect (funcall fn)
        (when (boundp sym) (set sym orig)))))

  (provide 'dev/dev-lsp)
  ;;; dev/dev-lsp.el ends here
#+end_src

*** dev/dev-ai.el
:PROPERTIES:
:CUSTOM_ID: dev-ai
:END:

**Purpose**
AI-assisted development via Aidermacs with OpenRouter/OpenAI backends.

**What it does**
- Picks backend from environment variables.
- Sets default model and retry policy.

**Notes**
- Warns if no API keys are present.

#+begin_src emacs-lisp :tangle lisp/dev/dev-ai.el
  ;;; dev/dev-ai.el --- AI-assisted development -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Aidermacs configuration with backend auto-detection.
  ;;; Code:

  (leaf aidermacs :straight t
    :init
    (cond
     ((getenv "OPENROUTER_API_KEY")
      (setenv "OPENAI_API_BASE" "https://openrouter.ai/api/v1")
      (setenv "OPENAI_API_KEY"  (getenv "OPENROUTER_API_KEY"))
      (setopt aidermacs-default-model "openrouter/anthropic/claude-3.5-sonnet"))
     ((getenv "OPENAI_API_KEY")
      (setenv "OPENAI_API_BASE" "https://api.openai.com/v1")
      (setopt aidermacs-default-model "gpt-4o-mini"))
     (t
      (display-warning 'aidermacs "No API keys set. Set OPENROUTER_API_KEY or OPENAI_API_KEY.")))
    (setopt aidermacs-retry-attempts 3
            aidermacs-retry-delay   2.0
            aidermacs-backend       'vterm))

  (provide 'dev/dev-ai)
  ;;; dev/dev-ai.el ends here
#+end_src

*** dev/dev-term.el
:PROPERTIES:
:CUSTOM_ID: dev-term
:END:

**Purpose**
Terminal integration with vterm.

**What it does**
- Installs `vterm`.

**Notes**
- For project shells, consider `eat` or `ansi-term` as alternates.

#+begin_src emacs-lisp :tangle lisp/dev/dev-term.el
;;; dev/dev-term.el --- Terminal integration -*- lexical-binding: t; -*-
;;; Commentary:
;; vterm integration.
;;; Code:

(leaf vterm :straight t)

(provide 'dev/dev-term)
;;; dev/dev-term.el ends here
#+end_src

*** dev/dev-build.el
:PROPERTIES:
:CUSTOM_ID: dev-build
:END:

**Purpose**
Build system helpers for Makefile/compile buffers with ANSI colors.

**What it does**
- Strict tabs for `makefile-gmake-mode`.
- Compile/recompile/project-compile bindings.
- Colorizes compilation output.

**Notes**
- Adds a heuristic for default `compile-command` when Makefile exists.

#+begin_src emacs-lisp :tangle lisp/dev/dev-build.el
;;; dev/dev-build.el --- Build & Makefile tools -*- lexical-binding: t; -*-
;;; Commentary:
;; Makefile settings and compile UX improvements.
;;; Code:

(leaf make-mode :straight nil
  :mode (("\\`Makefile\\'"    . makefile-gmake-mode)
         ("\\`GNUmakefile\\'" . makefile-gmake-mode)
         ("\\`makefile\\'"    . makefile-gmake-mode))
  :hook ((makefile-mode . (lambda ()
                            (setq-local indent-tabs-mode t
                                        tab-width 8
                                        show-trailing-whitespace t))))
  :config
  (leaf compile :straight nil
    :bind (("C-c m c" . compile)
           ("C-c m r" . recompile)
           ("C-c m p" . project-compile))
    :custom ((compilation-scroll-output . t)
             (compilation-skip-threshold . 2))
    :init
    (defun my/set-make-compile-command ()
      "Use `make -k` when a Makefile is present."
      (when (or (derived-mode-p 'makefile-mode)
                (locate-dominating-file default-directory "Makefile")
                (locate-dominating-file default-directory "GNUmakefile"))
        (setq-local compile-command "make -k")))
    (add-hook 'after-change-major-mode-hook #'my/set-make-compile-command))
  (leaf ansi-color :straight nil
    :hook (compilation-filter . (lambda ()
                                  (let ((inhibit-read-only t))
                                    (ansi-color-apply-on-region compilation-filter-start (point-max)))))))

(provide 'dev/dev-build)
;;; dev/dev-build.el ends here
#+end_src

*** dev/dev-docker.el
:PROPERTIES:
:CUSTOM_ID: dev-docker
:END:

**Purpose**
Docker workflows: Dockerfile mode, compose YAML, `docker.el`, tramp-container, and snippets.

**What it does**
- Associates major modes and basic settings.
- Adds quick access commands and tempel snippets.

**Notes**
- Requires Docker CLI on PATH for some operations.

#+begin_src emacs-lisp :tangle lisp/dev/dev-docker.el
;;; dev/dev-docker.el --- Docker integration -*- lexical-binding: t; -*-
;;; Commentary:
;; Dockerfile/YAML modes and docker.el helpers.
;;; Code:

(leaf dockerfile-mode :straight t
  :mode (("Dockerfile\\(\\..*\\)?\\'" . dockerfile-mode)
         ("\\.dockerfile\\'"         . dockerfile-mode))
  :custom ((dockerfile-mode-command . "docker")))

(leaf yaml-mode :straight t
  :mode (("\\`docker-compose.*\\.ya?ml\\'" . yaml-mode)
         ("\\.ya?ml\\'"                   . yaml-mode)))

(leaf docker :straight t
  :commands (docker docker-containers docker-images docker-volumes docker-networks)
  :bind (("C-c d d" . docker)
         ("C-c d c" . docker-containers)
         ("C-c d i" . docker-images)
         ("C-c d v" . docker-volumes)
         ("C-c d n" . docker-networks)))

(leaf tramp-container :straight nil
  :after tramp
  :init (setopt tramp-container-method "docker"))

(leaf tempel :straight t
  :commands (tempel-insert)
  :bind (dockerfile-mode-map
         ("C-c d t" . tempel-insert))
  :init
  (with-eval-after-load 'tempel
    (defvar my:tempel-docker-templates
      '((dockerfile "FROM " p n
                    "WORKDIR /app" n
                    "COPY . /app" n
                    "RUN " p n
                    "CMD [" p "]" n)))
    (add-to-list 'tempel-user-elements my:tempel-docker-templates)))

(provide 'dev/dev-docker)
;;; dev/dev-docker.el ends here
#+end_src

*** vcs/vcs-magit.el
:PROPERTIES:
:CUSTOM_ID: vcs-magit
:END:

**Purpose**
Magit keybindings and entry points.

**What it does**
- Binds `C-x g` to `magit-status`.

**Notes**
- Configure Forge/gh/CI separately.

#+begin_src emacs-lisp :tangle lisp/vcs/vcs-magit.el
;;; vcs/vcs-magit.el --- Git integration with Magit -*- lexical-binding: t; -*-
;;; Commentary:
;; Magit entry binding.
;;; Code:

(leaf magit :straight t
  :bind (("C-x g" . magit-status)))

(provide 'vcs/vcs-magit)
;;; vcs/vcs-magit.el ends here
#+end_src

*** vcs/vcs-gutter.el
:PROPERTIES:
:CUSTOM_ID: vcs-gutter
:END:

**Purpose**
Show VCS diffs in fringe.

**What it does**
- Enables `git-gutter` or `diff-hl` integrations.

**Notes**
- `diff-hl` integrates with Magit refresh.

#+begin_src emacs-lisp :tangle lisp/vcs/vcs-gutter.el
;;; vcs/vcs-gutter.el --- Show Git changes in fringe -*- lexical-binding: t; -*-
;;; Commentary:
;; Git gutter indicators and diff-hl integration.
;;; Code:

(leaf git-gutter :straight t
  :hook (prog-mode . git-gutter-mode)
  :custom ((git-gutter:update-interval . 2)))

(leaf diff-hl :straight t
  :hook ((prog-mode . diff-hl-mode)
         (magit-post-refresh . diff-hl-magit-post-refresh)))

(provide 'vcs/vcs-gutter)
;;; vcs/vcs-gutter.el ends here
#+end_src

*** vcs/vcs-forge.el
:PROPERTIES:
:CUSTOM_ID: vcs-forge
:END:

**Purpose**
Forge integration for GitHub/GitLab issues and PRs.

**What it does**
- Loads `forge` after Magit.
- Stores database under `.var/forge/`.

**Notes**
- Authenticate once via Magit/Forge workflow.

#+begin_src emacs-lisp :tangle lisp/vcs/vcs-forge.el
;;; vcs/vcs-forge.el --- GitHub/GitLab integration via Forge -*- lexical-binding: t; -*-
;;; Commentary:
;; Forge database relocation and activation.
;;; Code:

(leaf forge :straight t
  :after magit
  :config
  (defvar no-littering-var-directory
    (expand-file-name ".var/" (or (and load-file-name (file-name-directory (file-chase-links load-file-name)))
                                  user-emacs-directory)))
  (setopt forge-database-file
          (expand-file-name "forge/forge-database.sqlite" no-littering-var-directory))
  (let ((dir (file-name-directory forge-database-file)))
    (unless (file-directory-p dir) (make-directory dir t))))

(provide 'vcs/vcs-forge)
;;; vcs/vcs-forge.el ends here
#+end_src

*** utils/utils-functions.el
:PROPERTIES:
:CUSTOM_ID: utils-functions
:END:

**Purpose**
General utility helpers.

**What it does**
- Ensures directory creation with warnings.
- Safely loads external files.

**Notes**
- Keep these side-effect free and reusable.

#+begin_src emacs-lisp :tangle lisp/utils/utils-functions.el
  ;;; utils/utils-functions.el --- General utility functions -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Simple helpers shared across modules.
  ;;; Code:

  (defun my/ensure-directory-exists (dir)
    "Ensure DIR exists; create it recursively when missing."
    (unless (file-directory-p dir)
      (condition-case err
          (make-directory dir t)
        (error (warn "[utils] mkdir failed: %s (%s)" dir (error-message-string err))))))

  (defun my/safe-load-file (file &optional noerror)
    "Load FILE safely. If NOERROR is non-nil, log error instead of signaling."
    (when (and file (file-exists-p file))
      (condition-case err
          (load file nil 'nomessage)
        (error
         (funcall (if noerror #'message #'user-error)
                  "[utils] failed to load %s: %s"
                  file (error-message-string err))))))

  (provide 'utils/utils-functions)
  ;;; utils/utils-functions.el ends here
#+end_src

*** utils/utils-scratch.el
:PROPERTIES:
:CUSTOM_ID: utils-scratch
:END:

**Purpose**
Ensure `*scratch*` is always available and quick to recreate.

**What it does**
- Recreates `*scratch*` on kill.
- Provides a command to create `*scratch*` with `lisp-interaction-mode`.

**Notes**
- Minimal side effects.

#+begin_src emacs-lisp :tangle lisp/utils/utils-scratch.el
  ;;; utils/utils-scratch.el --- Scratch buffer helpers -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Auto-recreate and utilities for *scratch*.
  ;;; Code:

  (defun my/create-scratch-buffer ()
    "Create a new `*scratch*` buffer with `lisp-interaction-mode`."
    (let ((buf (get-buffer-create "*scratch*")))
      (with-current-buffer buf
        (lisp-interaction-mode)
        (insert ";; This is a new *scratch* buffer\n\n"))
      buf))

  (add-hook 'kill-buffer-hook
            (lambda ()
              (when (string= (buffer-name) "*scratch*")
                (run-at-time 0 nil #'my/create-scratch-buffer))))

  (provide 'utils/utils-scratch)
  ;;; utils/utils-scratch.el ends here
#+end_src

*** utils/utils-backup.el
:PROPERTIES:
:CUSTOM_ID: utils-backup
:END:

**Purpose**
Backup and autosave hygiene.

**What it does**
- Deletes backup files older than 7 days under `.var/backup/`.

**Notes**
- Uses `no-littering-var-directory` if available; otherwise defaults to `.var/`.

#+begin_src emacs-lisp :tangle lisp/utils/utils-backup.el
  ;;; utils/utils-backup.el --- Backup and auto-save helpers -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Cleanup tasks for backups.
  ;;; Code:

  (defvar no-littering-var-directory
    (expand-file-name ".var/" (or (and load-file-name (file-name-directory (file-chase-links load-file-name)))
                                  user-emacs-directory))
    "Directory to store variable data; provided by no-littering if installed.")

  (defun my/delete-old-backups ()
    "Delete backup files older than 7 days under var/backup/."
    (interactive)
    (let* ((backup-dir (concat no-littering-var-directory "backup/"))
           (threshold (- (float-time (current-time)) (* 7 24 60 60))))
      (when (file-directory-p backup-dir)
        (dolist (file (directory-files backup-dir t))
          (when (and (file-regular-p file)
                     (< (float-time (file-attribute-modification-time (file-attributes file)))
                        threshold))
            (ignore-errors (delete-file file)))))))

  (add-hook 'emacs-startup-hook #'my/delete-old-backups)

  (provide 'utils/utils-backup)
  ;;; utils/utils-backup.el ends here
#+end_src

*** utils/utils-async.el
:PROPERTIES:
:CUSTOM_ID: utils-async
:END:

**Purpose**
Run tasks safely in a deferred manner.

**What it does**
- Provides `my/safe-run-async` which traps errors and logs them.

**Notes**
- Keep tasks small and non-blocking.

#+begin_src emacs-lisp :tangle lisp/utils/utils-async.el
  ;;; utils/utils-async.el --- Async helpers -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Non-blocking task runner with error capture.
  ;;; Code:

  (defun my/safe-run-async (task)
    "Run TASK asynchronously, catching and reporting any errors."
    (run-at-time 0 nil
                 (lambda ()
                   (condition-case err
                       (funcall task)
                     (error (message "[async] error: %s" (error-message-string err)))))))

  (provide 'utils/utils-async)
  ;;; utils/utils-async.el ends here
#+end_src

*** utils/search-nav.el
:PROPERTIES:
:CUSTOM_ID: utils-search-nav
:END:

**Purpose**
Project-wide search and navigation helpers.

**What it does**
- Prefers ripgrep when available.
- Adds dumb-jump xref backend.
- Configures Projectile cache paths under `.var/projectile/`.
- Installs multiple-cursors.

**Notes**
- Ensure `rg` is installed for best performance.

#+begin_src emacs-lisp :tangle lisp/utils/search-nav.el
  ;;; utils/search-nav.el --- Project search & navigation -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Ripgrep, dumb-jump, projectile, and multiple-cursors.
  ;;; Code:

  (defvar no-littering-var-directory
    (expand-file-name ".var/" (or (and load-file-name (file-name-directory (file-chase-links load-file-name)))
                                  user-emacs-directory)))

  (when (executable-find "rg")
    (setopt grep-program "rg")
    (leaf rg :straight t))

  (leaf dumb-jump :straight t
    :hook (xref-backend-functions . dumb-jump-xref-activate)
    :custom
    ((dumb-jump-force-searcher  . 'rg)
     (dumb-jump-prefer-searcher . 'rg)))

  (leaf projectile :straight t
    :config
    (let ((base (expand-file-name "projectile/" no-littering-var-directory)))
      (unless (file-directory-p base) (make-directory base t))
      (setopt projectile-cache-file
              (expand-file-name "cache.el" base)
              projectile-known-projects-file
              (expand-file-name "bookmarks.eld" base)))
    (projectile-mode 1))

  (leaf multiple-cursors :straight t)

  (provide 'utils/search-nav)
  ;;; utils/search-nav.el ends here
#+end_src

** Personal Configuration
:PROPERTIES:
:CUSTOM_ID: personal
:END:

This module defines **personal settings and device-specific configurations**.
It customizes identity, fonts, input sources, device preferences, and Apple Music control.

- **Purpose**
  Centralize personal identity, fonts, input methods, device preferences, and music control.

- **What it does**
  - Sets user identity and fonts.
  - Defines cloud/blog directories and ensures they exist.
  - Cleans `load-path` from unwanted dirs.
  - Configures IME auto-switching (`sis`) on macOS.
  - Adjusts Logitech MX Ergo S mouse behavior.
  - Provides Apple Music control with Hydra UI (macOS only).

- **Notes**
  - Requires `my/ensure-directory-exists` from utils (soft-required; falls back safely).
  - `sis` needs macOS + `macism` (install via Homebrew).
  - Apple Music functions only work on macOS.

#+begin_src emacs-lisp :tangle (eval (format "personal/%s.el" (user-login-name)))
  ;;; user.el --- Personal configuration -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Personal settings and device-specific configurations.
  ;;
  ;; Includes:
  ;; - Identity, fonts, directories
  ;; - macOS IME auto-switch (sis)
  ;; - Device: Logitech MX Ergo S
  ;; - Apple Music control with Hydra UI
  ;;
  ;; Requirements:
  ;; - my/ensure-directory-exists (from utils/utils-functions)
  ;; - macOS + `macism` for sis integration (brew install macism)
  ;;; Code:

  (eval-when-compile (require 'leaf))
  (require 'subr-x)   ;; string-trim, when-let, etc.
  (require 'seq)      ;; seq-remove
  ;; Soft-require utils helpers; continue even if absent.
  (require 'utils/utils-functions nil t)

  ;; Fallback for ensure-directory when utils is missing.
  (unless (fboundp 'my/ensure-directory-exists)
    (defun my/ensure-directory-exists (dir)
      "Create DIR recursively if missing; warn on failure."
      (unless (file-directory-p dir)
        (condition-case err
            (make-directory dir t)
          (error (warn "[personal] mkdir failed: %s (%s)"
                       dir (error-message-string err)))))))

  ;; -----------------------------------------------------------------------------
  ;; Personal identity, fonts, and directories
  ;; -----------------------------------------------------------------------------
  (leaf *personals
    :straight nil
    :init
    ;; Identity
    (setopt user-full-name "YAMASHITA, Takao"
            user-mail-address "tjy1965@gmail.com"
            inhibit-compacting-font-caches t
            plstore-cache-passphrase-for-symmetric-encryption t)

    ;; Fonts (consumed by ui/ui-font.el)
    (setopt my:font-default "JetBrains Mono NL"
            my:font-alt    "Noto Sans JP"
            my:emoji-font  "Apple Color Emoji"
            my:font-size   20)

    ;; Directories
    (defvar my:d:cloud
      (expand-file-name "Documents/" (or (getenv "HOME") "~"))
      "Cloud storage base directory.")
    (defvar my:d:org
      (expand-file-name "org/" my:d:cloud)
      "Org directory for personal notes.")
    (defvar my:d:blog
      (expand-file-name "devel/repos/mysite/" my:d:cloud)
      "Blog directory.")
    (defvar my:f:capture-blog-file
      (expand-file-name "all-posts.org" my:d:blog)
      "Default Org file for blog captures.")
    (defvar my:d:excluded-directories
      (list (expand-file-name "Library/Accounts" (or (getenv "HOME") "~")))
      "Directories excluded from `load-path` for safety.")

    ;; Ensure directories exist
    (mapc #'my/ensure-directory-exists (list my:d:cloud my:d:org my:d:blog))

    ;; Recompute org-directory and agenda files (non-destructive)
    (setopt org-directory my:d:org)
    (when (fboundp 'directory-files-recursively)
      (setopt org-agenda-files
              (seq-filter (lambda (file)
                            (and (string-match-p "\\.org\\'" file)
                                 (not (string-match-p "archives" file))))
                          (directory-files-recursively org-directory "\\.org\\'"))))

    ;; Clean up load-path
    (setopt load-path
            (seq-remove (lambda (dir)
                          (member (file-name-as-directory (expand-file-name dir))
                                  (mapcar (lambda (d) (file-name-as-directory (expand-file-name d)))
                                          my:d:excluded-directories)))
                        load-path)))

  ;; -----------------------------------------------------------------------------
  ;; Smart Input Source (macOS only, requires macism)
  ;; -----------------------------------------------------------------------------
  (leaf sis
    :straight t
    :if (eq system-type 'darwin)
    :commands (sis-ism-lazyman-config
               sis-global-cursor-color-mode
               sis-global-respect-mode
               sis-global-inline-mode)
    :hook (emacs-startup .
           (lambda ()
             (when (and (executable-find "macism")
                        (fboundp 'sis-ism-lazyman-config))
               (sis-ism-lazyman-config
                "com.apple.keylayout.ABC"
                "com.apple.inputmethod.Kotoeri.RomajiTyping.Japanese"
                'macism))
             (when (fboundp 'sis-global-cursor-color-mode)
               (sis-global-cursor-color-mode t))
             (when (fboundp 'sis-global-respect-mode)
               (sis-global-respect-mode t))
             (when (fboundp 'sis-global-inline-mode)
               (sis-global-inline-mode t)))))

  ;; Sync cursor face after theme changes (works across themes)
  (add-hook 'enable-theme-functions
            (lambda (&rest _)
  	    (when-let* ((clr (face-background 'cursor nil t)))
                (set-face-background 'cursor clr))))

  ;; -----------------------------------------------------------------------------
  ;; Logitech MX Ergo S configuration (generic mouse tuning)
  ;; -----------------------------------------------------------------------------
  (leaf *device/MX_ErgoS
    :straight nil
    :init
    (setopt mouse-wheel-scroll-amount       '(1 ((shift) . 5) ((control) . 10))
            mouse-wheel-progressive-speed   nil
            scroll-conservatively           10000
            scroll-margin                   2
            scroll-preserve-screen-position t
            mac-mouse-wheel-smooth-scroll   t
            mouse-wheel-tilt-scroll         t
            mouse-wheel-flip-direction      nil)
    ;; Quick gestures (note: mouse-4/5 are typically wheel events)
    (global-set-key [mouse-2] #'yank)
    (global-set-key [mouse-4] #'previous-buffer)
    (global-set-key [mouse-5] #'next-buffer))

  ;; -----------------------------------------------------------------------------
  ;; Apple Music Control (macOS only)
  ;; -----------------------------------------------------------------------------
  (when (eq system-type 'darwin)

    ;; Core AppleScript helpers
    (defun my/apple-music-osascript-async (script &optional callback)
      "Run AppleScript SCRIPT asynchronously, invoking CALLBACK with output."
      (let* ((proc-name "apple-music-async")
             (buffer-name "*Apple Music Async*")
             (proc (start-process proc-name buffer-name "osascript" "-e" script)))
        (when callback
          (set-process-sentinel
           proc
           (lambda (process event)
             (when (string= event "finished\n")
               (when-let* ((buf (process-buffer process)))
                 (with-current-buffer buf
                   (let ((output (string-trim (buffer-string))))
                     (funcall callback output)))
                 (kill-buffer buf))))))))

    (defun my/apple-music-osascript-sync (script)
      "Run AppleScript SCRIPT synchronously and return trimmed output."
      (string-trim (shell-command-to-string (format "osascript -e %S" script))))

    ;; Player controls
    (defun my/apple-music-play-pause () (interactive)
      "Toggle play/pause in Apple Music."
      (my/apple-music-osascript-async "tell application \"Music\" to playpause"))

    (defun my/apple-music-next-track () (interactive)
      "Skip to the next track in Apple Music."
      (my/apple-music-osascript-async "tell application \"Music\" to next track"))

    (defun my/apple-music-previous-track () (interactive)
      "Return to the previous track in Apple Music."
      (my/apple-music-osascript-async "tell application \"Music\" to previous track"))

    ;; Track info
    (defun my/apple-music-current-track-info ()
      "Return and display current track info: Title — Artist [Album]."
      (interactive)
      (let ((info (my/apple-music-osascript-sync
                   "tell application \"Music\" \
  to (get name of current track) & \" — \" & (get artist of current track) & \" [\" & (get album of current track) & \"]\"")))
        (if (called-interactively-p 'any)
            (message "%s" info)
          info)))

    ;; Playlists
    (defun my/apple-music-get-playlists ()
      "Return a list of playlist names from Apple Music."
      (split-string
       (my/apple-music-osascript-sync
        "tell application \"Music\" to get name of playlists")
       ", " t))

    (defun my/apple-music-play-playlist (playlist)
      "Prompt for PLAYLIST and play it in Apple Music."
      (interactive
       (list (completing-read "Playlist: " (my/apple-music-get-playlists))))
      (my/apple-music-osascript-async
       (format "tell application \"Music\" to play playlist %S" playlist)))

    ;; Hydra UI (lazy; only if hydra is available)
    (with-eval-after-load 'hydra
      (defhydra hydra-apple-music (:hint nil)
        "
  Apple Music:
  _p_: Play/Pause  _n_: Next  _b_: Back  _l_: Playlist  _i_: Info  _q_: Quit
  "
        ("p" my/apple-music-play-pause)
        ("n" my/apple-music-next-track)
        ("b" my/apple-music-previous-track)
        ("l" my/apple-music-play-playlist)
        ("i" my/apple-music-current-track-info)
        ("q" nil "quit"))
      (global-set-key (kbd "C-c m") #'hydra-apple-music/body)))

  (provide 'personal/user)
  ;;; user.el ends here
#+end_src

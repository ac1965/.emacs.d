# -*- mode: org; coding: utf-8; -*-
#+TITLE: Modern Emacs Configuration
#+AUTHOR: YAMASHITA, Takao
#+EMAIL: tjy1965@gmail.com
#+LANGUAGE: en
#+OPTIONS: toc:3 num:t
#+STARTUP: overview
#+PROPERTY: header-args :results silent :exports code :mkdirp yes :padline no :tangle no
#+PROPERTY: header-args:emacs-lisp :lexical t :noweb no-export

* Introduction
:PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

A modern, literate Emacs configuration using Org Mode's Babel format, emphasizing performance, language server integration, AI assistance, and productivity.

** Features
:PROPERTIES:
:CUSTOM_ID: features
:END:

-  üöÄ *Performance & Native Compilation* ‚Äî Early-init moves ELN under `.cache/`, silences async warnings, widens GC at startup and restores sane values later, and uses GCMH for idle GC.
-  üß© *Language Server Protocol* ‚Äî Backend-agnostic helpers in `core/general.el`; choose *Eglot* or *lsp-mode* via `core/switches.el` with presence checks and auto-enable logic.
-  ü§ñ *AI Integration* ‚Äî Aidermacs (vterm backend). Prefers OpenRouter when `OPENROUTER_API_KEY` is set; otherwise uses OpenAI with `OPENAI_API_KEY`.
-  üé® *Modern UI & Editing* ‚Äî Tree-sitter remaps (`*-ts-mode`), ef-themes + spacious-padding, Nerd Icons, Vertico/Orderless/Corfu/CAPE/Embark/Consult, Doom/Nano modeline switchers.
-  üóÇÔ∏è *Productivity Tools* ‚Äî Opinionated Org stack (agenda, capture, journal, roam, download, TOC), Magit + diff-hl/Forge, REST client, Docker/dev helpers, tidy backups/autosave-visited.

[[file:demo.png]]

** Coding Rules
:PROPERTIES:
:CUSTOM_ID: conventions
:END:

- ‚úÖ `lexical-binding: t` is *mandatory* for all files.
- ‚úÖ The `(provide 'FEATURE)` symbol *must match the file‚Äôs logical feature name*
  (usually derived from the file path).
- üì¶ Built-in packages MUST explicitly declare `:straight nil`.
- üåø Each `leaf` form follows a stable, readable structure:
  `:straight` ‚Üí `:bind` ‚Üí `:hook` ‚Üí `:custom` ‚Üí `:config`
- üìö Only documented, public APIs are used.
  - Private, internal, or speculative APIs are intentionally avoided.
- üß† *Compatibility & Forward-Safety Policy*
  - This configuration targets **Emacs 30+**.
  - Code is written with **Emacs 31 and later** in mind.
  - Obsolete APIs are avoided even if still functional.
    - Prefer `if-let*`, `when-let*`, `and-let*` over deprecated forms.
  - New compiler or runtime warnings are treated as *actionable signals*.
  - The codebase aims to remain warning-free under the latest stable Emacs
    with default `byte-compile-warnings`.

See also: [[#modular-loader-and-core-suite][Modular Loader & Core/Utils design]]
for how these rules are enforced structurally.

** Installation
:PROPERTIES:
   :CUSTOM_ID: installation
   :END:

*** Prerequisites
:PROPERTIES:
:CUSTOM_ID: prerequisites
:END:

- *Required*
  - Emacs *30.0+* with native compilation (`--with-native-compilation`)
  - Git
  - GNU Make
  - GCC *10+* with `libgccjit`

- *Optional but Recommended*
  - ripgrep (`rg`) ‚Üí faster project-wide search
  - aspell or hunspell ‚Üí spell checking
  - pass + GnuPG ‚Üí password and auth-source integration
  - Homebrew (macOS only) ‚Üí for consistent toolchain installation

*** Building Emacs

Use the provided build script:
[[https://github.com/ac1965/dotfiles/blob/master/.local/bin/build-emacs.sh][build-emacs.sh]]

#+begin_src shell
  build-emacs.sh
#+end_src

*** Quick Start

1. Clone the repository:
   #+begin_src shell
     git clone --depth 1 https://github.com/ac1965/.emacs.d ~/.emacs.d/
   #+end_src

2. Tangle configuration:
   #+begin_src shell
     EMACS=/Applications/Emacs.app/Contents/MacOS/Emacs make -C ~/.emacs.d/ tangle
   #+end_src

*** Makefile

#+begin_src text :tangle Makefile :comments no
  # Makefile ‚Äî One-pass builder for a modular Emacs config
  # - Default / `make all` : onepass-init (tangle -> incremental byte-compile)
  # - `make onepass-q`     : -Q (minimal env) tangle -> full byte-compile
  # - Paths are absolutized from repo root to avoid "lisp/personal" confusion.

  SHELL := /bin/sh

  # ---- Repo-root & absolutized dirs --------------------------------------------
  ROOT := $(CURDIR)

  EMACS  ?= emacs
  ORG    ?= README.org
  EARLY  ?= early-init.el
  INIT   ?= init.el

  # Always treat these as top-level under repo root
  LISPDIR_REL     ?= lisp
  PERSONALDIR_REL ?= personal

  LISPDIR     := $(abspath $(ROOT)/$(LISPDIR_REL))
  PERSONALDIR := $(abspath $(ROOT)/$(PERSONALDIR_REL))
  ORG := $(abspath $(ROOT)/$(ORG))
  EARLY := $(abspath $(ROOT)/$(EARLY))
  INIT  := $(abspath $(ROOT)/$(INIT))

  STRICT_BYTE_WARN ?= 0   # Treat byte-compile warnings as errors
  NATIVE_COMPILE   ?= 1   # Prefer native-compile if available

  # ---- Emacs runners & common eval snippets ------------------------------------
  EMACS_BATCH := "$(EMACS)" --batch
  EMACS_Q     := $(EMACS_BATCH) -Q

  EVAL_STRICT := $(if $(filter 1,$(STRICT_BYTE_WARN)),--eval "(setq byte-compile-error-on-warn t)",)
  EVAL_NATIVE := $(if $(filter 1,$(NATIVE_COMPILE)),--eval "(setq comp-deferred-compilation t)",)

  # Optional leaf injection for -Q
  STRAIGHT_BASE_DIR ?= $(shell \
    if [ -f "$(EARLY)" ]; then \
      $(EMACS_Q) -l "$(EARLY)" \
        --eval "(princ (expand-file-name (or (ignore-errors STRAIGHT_BASE_DIR) \
                                             (ignore-errors (and (boundp 'straight-base-dir) straight-base-dir)) \
                                             (expand-file-name \"straight\" user-emacs-directory))))"; \
    else \
      printf "%s" "$$HOME/.emacs.d/straight"; \
    fi)
  LEAF_DIR   := $(STRAIGHT_BASE_DIR)/repos/leaf
  LEAFKW_DIR := $(STRAIGHT_BASE_DIR)/repos/leaf-keywords

  EVAL_LEAF := \
    --eval "(let* ((ldir \"$(LEAF_DIR)\") (kwdir \"$(LEAFKW_DIR)\")) \
              (when (file-directory-p ldir)  (add-to-list 'load-path ldir)) \
              (when (file-directory-p kwdir) (add-to-list 'load-path kwdir)) \
              (ignore-errors (require 'leaf)) \
              (ignore-errors (require 'leaf-keywords)) \
              (when (featurep 'leaf-keywords) (leaf-keywords-init)))"

  # ---- Default target (no args) ------------------------------------------------
  .PHONY: all onepass-init onepass-q clean distclean show-files echo-paths tangle
  all: onepass-init

  # ---- One-pass (early+init env) : tangle -> incremental compile ---------------
  onepass-init: $(ORG)
  	@echo "[onepass-init] tangle -> incremental byte-compile (init loaded)"
  	@$(EMACS_BATCH) -l "$(EARLY)" -l "$(INIT)" \
  	  $(EVAL_STRICT) $(EVAL_NATIVE) \
  	  --eval "(setq org-confirm-babel-evaluate nil)" \
  	  --eval "(require 'org)" \
  	  --eval "(org-babel-tangle-file \"$(ORG)\")" \
  	  --eval "(let* ((dirs (delq nil (list (and (file-directory-p \"$(LISPDIR)\") \"$(LISPDIR)\") \
  	                                        (and (file-directory-p \"$(PERSONALDIR)\") \"$(PERSONALDIR)\"))))) \
  	            (dolist (d dirs) (byte-recompile-directory d 0)) \
  	            (when (and (featurep 'comp) (bound-and-true-p comp-deferred-compilation)) \
  	              (dolist (d dirs) (ignore-errors (native-compile-async d 'recursively)))))" \
  	  --eval "(message \"[onepass-init] done\")"

  # ---- One-pass (-Q minimal env) : tangle -> full compile ----------------------
  onepass-q: $(ORG)
  	@echo "[onepass-q] -Q tangle -> full byte-compile (init not loaded)"
  	@$(EMACS_Q) \
  	  $(EVAL_LEAF) $(EVAL_STRICT) $(EVAL_NATIVE) \
  	  --eval "(setq org-confirm-babel-evaluate nil)" \
  	  --eval "(require 'org)" \
  	  --eval "(org-babel-tangle-file \"$(ORG)\")" \
  	  --eval "(let* ((dirs (delq nil (list (and (file-directory-p \"$(LISPDIR)\") \"$(LISPDIR)\") \
  	                                        (and (file-directory-p \"$(PERSONALDIR)\") \"$(PERSONALDIR)\"))))) \
  	            (dolist (d dirs) (byte-recompile-directory d t)) \
  	            (when (and (featurep 'comp) (bound-and-true-p comp-deferred-compilation)) \
  	              (dolist (d dirs) (ignore-errors (native-compile-async d 'recursively)))))" \
  	  --eval "(message \"[onepass-q] done\")"

  # ---- Utilities ---------------------------------------------------------------
  show-files:
  	@echo "[list] $(LISPDIR)";    { [ -d "$(LISPDIR)" ] && find "$(LISPDIR)" -type f -name '*.el' | sort; } || true
  	@echo "[list] $(PERSONALDIR)"; { [ -d "$(PERSONALDIR)" ] && find "$(PERSONALDIR)" -type f -name '*.el' | sort; } || true

  echo-paths:
  	@echo "ROOT=$(ROOT)"; \
  	echo "EARLY=$(EARLY)"; \
  	echo "INIT=$(INIT)"; \
  	echo "LISPDIR=$(LISPDIR)"; \
  	echo "PERSONALDIR=$(PERSONALDIR)"; \
  	echo "STRAIGHT_BASE_DIR=$(STRAIGHT_BASE_DIR)"; \
  	echo "LEAF_DIR=$(LEAF_DIR)"; \
  	echo "LEAFKW_DIR=$(LEAFKW_DIR)"

  clean:
  	@echo "[clean] remove *.elc under $(LISPDIR) and $(PERSONALDIR)"
  	@{ [ -d "$(LISPDIR)" ] && find "$(LISPDIR)" -type f -name '*.elc' -delete; } 2>/dev/null || true
  	@{ [ -d "$(PERSONALDIR)" ] && find "$(PERSONALDIR)" -type f -name '*.elc' -delete; } 2>/dev/null || true

  distclean: clean
  	@echo "[distclean] remove stray *.eln"
  	@find "$(ROOT)" -type f -name '*.eln' -delete

  tangle:
  	@echo "[tangle] $(ORG)"
  	@$(EMACS_Q) \
  	  --eval "(require 'org)" \
  	  --eval "(require 'ob-core)" \
  	  --eval "(org-babel-do-load-languages 'org-babel-load-languages '((emacs-lisp . t)))" \
  	  --eval "(setq org-confirm-babel-evaluate nil noninteractive t)" \
  	  --eval "(org-babel-tangle-file \"$(ORG)\")"
#+end_src

*** System Information

**** Apple Silicon (Primary)
- GNU Emacs *31.0.50*

|Property|Value|
|--------|-----|
|Commit|6287637ccd9f66a219844231380ab9873d049c6e|
|Branch|master|
|System|aarch64-apple-darwin25.2.0|
|Date|2026-01-17 15:41:46 (JST)|
|Patch|N/A ns-inline.patch|
|Features|ACL DBUS GLIB GNUTLS IMAGEMAGICK LCMS2 LIBXML2 MODULES NATIVE_COMP NOTIFY KQUEUE NS PDUMPER PNG RSVG SQLITE3 THREADS TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM XWIDGETS ZLIB|
|Options|--with-ns --enable-mac-app=yes --with-xwidgets --with-native-compilation --with-json --with-tree-sitter --with-imagemagick --with-gnutls --prefix=/Users/ac1965/.local CPPFLAGS=-I/opt/homebrew/opt/llvm/include 'LDFLAGS=-L/opt/homebrew/opt/llvm/lib -L/opt/homebrew/opt/llvm/lib/c++ -Wl,-rpath,/opt/homebrew/opt/llvm/lib/c++'|

**** Intel (Secondary)
- GNU Emacs *31.0.50*

|Property|Value|
|--------|-----|
|Commit|63ea5e5b3a57e7660ece022ba1834002ca2f206d|
|Branch|master|
|System|x86_64-apple-darwin25.1.0|
|Date|2025-11-01 12:05:25 (JST)|
|Patch|N/A ns-inline.patch|
|Features|ACL DBUS GIF GLIB GMP GNUTLS JPEG LCMS2 LIBXML2 MODULES NATIVE_COMP NOTIFY KQUEUE NS PDUMPER PNG RSVG SQLITE3 THREADS TIFF TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM ZLIB|
|Options|--with-native-compilation --with-gnutls=ifavailable --with-json --with-modules --with-tree-sitter --with-xml2 --with-librsvg --with-mailutils --with-native-image-api --with-ns CPPFLAGS=-I/usr/local/opt/llvm/include 'LDFLAGS=-L/usr/local/opt/llvm/lib -L/usr/local/opt/llvm/lib/c++ -Wl,-rpath,/usr/local/opt/llvm/lib/c++'|

** Tools
:PROPERTIES:
   :CUSTOM_ID: tools
:END:

*** Graph Capture (Require Dependency Visualization)
:PROPERTIES:
:CUSTOM_ID: tools-graph-capture
:header-args:emacs-lisp: :tangle lisp/tools/graph.el
:END:

**** Purpose
Capture and visualize `require` relationships between Emacs Lisp features
during startup or module loading.
This helps understanding implicit dependencies, load order, and unwanted
coupling between modules.

**** What it does
- Advises `require` to record *from ‚Üí to* edges between features
- Stores edges in a hash table (no duplicates)
- Exports the dependency graph as:
  - Graphviz DOT
  - Mermaid (for Org / Markdown)
- Provides interactive commands to enable/disable capture at runtime

**** Notes
- Intended for **diagnostics only**, not for normal startup
- Enable capture *before* loading modules
- Disable capture after use to avoid overhead
- Feature names are derived from file names or `require` symbols

**** Implementation (tangled to lisp/tools/graph.el)

#+begin_src emacs-lisp
;;; tools/graph.el --- Require dependency graph capture -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2025
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;;
;;; Commentary:
;; Diagnostic tool to capture and visualize `require` dependencies
;; between Emacs Lisp features.  Outputs Graphviz DOT or Mermaid graphs.
;; Category: tools
;;;
;;; Code:

(defvar graph/require-edges (make-hash-table :test 'equal)
  "Hash table storing recorded require edges as FROM->TO keys.")

(defun graph--record (from to)
  "Record a require edge FROM -> TO if both are symbols."
  (when (and (symbolp from) (symbolp to))
    (puthash (format "%s->%s" from to) t graph/require-edges)))

(defun graph/require-advice (orig feature &optional filename noerror)
  "Advice around `require` to record dependency edges."
  (let* ((from-file (or load-file-name (buffer-file-name)))
         (from-sym (if from-file
                       (intern (file-name-sans-extension
                                (file-name-nondirectory from-file)))
                     'init))
         (to-sym (if (symbolp feature)
                     feature
                   (intern (format "%s" feature)))))
    (graph--record from-sym to-sym)
    (funcall orig feature filename noerror)))

(defun graph/edge-list ()
  "Return a sorted list of recorded edges."
  (sort (hash-table-keys graph/require-edges) #'string<))

(defun graph/export-dot ()
  "Render recorded require edges as Graphviz DOT."
  (interactive)
  (let ((buf (get-buffer-create "*Require Graph (DOT)*")))
    (with-current-buffer buf
      (erase-buffer)
      (insert "digraph G {\n  rankdir=LR;\n  node [shape=box, fontsize=10];\n")
      (dolist (e (graph/edge-list))
        (when (string-match "^\\([^->]+\\)->\\(.+\\)$" e)
          (insert (format "  \"%s\" -> \"%s\";\n"
                          (match-string 1 e)
                          (match-string 2 e)))))
      (insert "}\n"))
    (pop-to-buffer buf)))

(defun graph/export-mermaid ()
  "Render recorded require edges as Mermaid flowchart."
  (interactive)
  (let ((buf (get-buffer-create "*Require Graph (Mermaid)*")))
    (with-current-buffer buf
      (erase-buffer)
      (insert "```mermaid\nflowchart LR\n")
      (dolist (e (graph/edge-list))
        (when (string-match "^\\([^->]+\\)->\\(.+\\)$" e)
          (insert
           (format "  %s --> %s\n"
                   (replace-regexp-in-string "[./-]" "_" (match-string 1 e))
                   (replace-regexp-in-string "[./-]" "_" (match-string 2 e))))))
      (insert "```\n"))
    (pop-to-buffer buf)))

(defun graph/enable-require-capture ()
  "Enable require dependency capture."
  (interactive)
  (clrhash graph/require-edges)
  (advice-add 'require :around #'graph/require-advice)
  (message "[graph] require capture enabled"))

(defun graph/disable-require-capture ()
  "Disable require dependency capture."
  (interactive)
  (advice-remove 'require #'graph/require-advice)
  (message "[graph] require capture disabled"))

(provide 'tools/graph)
;;; tools/graph.el ends here
#+end_src

**** Module Load Summary Helper

#+begin_src emacs-lisp :tangle lisp/tools/graph.el
(defun my/modules-summary-line ()
  "Display a concise summary of module loading and captured require edges."
  (interactive)
  (let* ((edges (if (and (boundp 'graph/require-edges)
                         (hash-table-p graph/require-edges))
                    (hash-table-count graph/require-edges)
                  "N/A"))
         (skip  (if (boundp 'my:modules-skip)
                    (length (or my:modules-skip '()))
                  0))
         (extra (if (boundp 'my:modules-extra)
                    (length (or my:modules-extra '()))
                  0)))
    (message "[modules] edges=%s, skip=%d, extra=%d"
             edges skip extra)))
#+end_src

**** Usage

1. Restart Emacs
2. Enable capture:
   - `M-: (require 'tools/graph)`
   - `M-: (graph/enable-require-capture)`
3. Load modules (e.g. `(require 'modules)` or normal startup)
4. Export graph:
   - `M-: (graph/export-mermaid)`
   - or `M-: (graph/export-dot)`
5. Paste the result into Org / Markdown
6. (Optional) `M-: (my/modules-summary-line)`

**** Mermaid Example

#+begin_src mermaid :file ./graphs/require-graph.svg :results file
%% Paste the Mermaid text generated by (graph/export-mermaid) below:
flowchart LR
  modules --> core_general
  core_general --> utils_misc
#+end_src

#+RESULTS:
[[file:./graphs/require-graph.svg]]

* Configuration Files
:PROPERTIES:
:CUSTOM_ID: structure
:END:

This Emacs configuration is *modular by design* and targets **Emacs 30+**.
Each layer has a clearly defined responsibility to keep behavior predictable,
UI replaceable, and personal customizations isolated.

- =early-init.el= ‚Üí earliest bootstrap (performance, paths, UI defaults)
- =init.el=       ‚Üí package bootstrap, global defaults, module entrypoint
- =lisp/=         ‚Üí shared, versioned modules (core, ui, completion, orgx, dev, vcs, utils)
- =personal/=     ‚Üí user- and device-specific overlays (not shared policy)

** Core Bootstrap ‚Äî early-init.el & init.el
:PROPERTIES:
:CUSTOM_ID: core-bootstrap
:END:

*** Overview

**** Purpose
Provide a *clean, fast, and conservative* bootstrap sequence that prepares
Emacs before regular initialization.

The bootstrap is split into two explicit stages:

- =early-init.el= runs **before package initialization** and establishes
  directories, performance guards, and flicker-free UI defaults.
- =init.el= completes package bootstrapping (*straight.el + leaf*), imports
  the login environment on macOS, applies runtime performance knobs, and
  exposes a deterministic module loader entrypoint.

This separation keeps early startup minimal and infrastructure-focused,
while deferring all feature logic to later stages.

**** What this configuration does

- Disables =package.el= early; *straight.el* and *leaf* are the only package managers.
- Speeds up startup by temporarily widening GC limits and clearing
  =file-name-handler-alist=, then restoring sane runtime values.
- Normalizes all state under predictable directories:
  =.cache/=, =.etc/=, and =.var/= (including native-comp artifacts).
- On macOS, prefers the Homebrew toolchain by preparing PATH-related variables
  (e.g. =PATH=, =LIBRARY_PATH=, =CC=) *before* native compilation is triggered.
- Disables classic backups and auto-save early; higher-level modules may enable
  =auto-save-visited-mode= later in a controlled way.
- Applies early UI defaults (no menu/tool/scroll bars, stable frame parameters)
  to avoid startup flicker.
- Bootstraps *straight.el* robustly, with guarded network access and explicit
  error reporting.
- Initializes *leaf* and its keywords, and enables conservative performance
  helpers (e.g. GCMH, =read-process-output-max=).
- Sets URL-related state paths *before* =url.el= loads, so downstream consumers
  (including *straight*) inherit them.
- Provides two stable entrypoints:
  - a per-user personal override file (=personal/<login-name>.el=)
  - a shared module loader (=lisp/modules.el=)

**** Reproducibility Note (Personal Tangling)

This configuration prioritizes reproducibility for all *shared* layers:

- =early-init.el=
- =init.el=
- =lisp/=

Personal files are intentionally tangled to user-specific paths:

: personal/<login-name>.el

This design explicitly trades strict reproducibility for:
- Per-user isolation
- Safe multi-user sharing of the same repository
- Zero-conflict personal overrides

This behavior is intentional and by design.

**** Module map (where things live)

| File            | Role |
|-----------------+------|
| =early-init.el= | Pre-init bootstrap (dirs, performance guards, package.el off, macOS toolchain, early UI) |
| =init.el=       | Main init (URL state, straight bootstrap, env import, runtime knobs, module loader) |

**** How it works (boot flow)

1. Emacs loads =early-init.el=:
   - Directory paths are established.
   - =package.el= is disabled.
   - GC and file-handler pressure is relaxed.
   - Early UI defaults are applied.
   - macOS toolchain variables are prepared when applicable.

2. Emacs loads =init.el=:
   - URL state directories are set *before* =url.el=.
   - *straight.el* is bootstrapped.
   - On macOS GUI/daemon sessions, the login environment is imported.
   - *leaf* is initialized and a minimal base of packages is ensured.
   - Runtime performance knobs (GCMH, IO buffers) are applied.
   - A per-user personal file is loaded safely.
   - =modules.el= is required as the canonical feature entrypoint.

3. After initialization completes, a concise startup summary
   (elapsed time and GC count) is printed.

**** Key settings (reference)

- =package-enable-at-startup= :: =nil= ‚Äî rely exclusively on *straight.el*.
- =straight-base-dir= :: Located under =.cache/= to keep the config root clean.
- =native-comp-eln-load-path= :: Centralized under =.cache/eln-cache=.
- =read-process-output-max= :: Temporarily raised (4 MiB) for better LSP/IO throughput.
- =gcmh-high-cons-threshold= :: 16 MiB; =gcmh-mode= enabled for smoother long sessions.

**** Usage tips

- Treat =early-init.el= as infrastructure only; avoid user behavior or feature logic.
- Put shared behavior in modules loaded via =modules.el=.
- Put identity, device-specific glue, and workflow integrations in
  =personal/<login-name>.el= or related personal modules.
- After installing or upgrading Homebrew toolchains, restart Emacs so native
  compilation sees updated paths.
- To relocate the entire setup, move the config directory; Emacs will regenerate
  =.cache/=, =.etc/=, and =.var/= automatically.

**** Troubleshooting

- *‚ÄúNative compilation can‚Äôt find libgccjit on macOS‚Äù* ‚Üí
  Ensure Homebrew‚Äôs =libgccjit= is installed and visible. The early bootstrap
  prepares =LIBRARY_PATH= when possible.
- *‚ÄúStraight bootstrap failed‚Äù* ‚Üí
  A transient network issue during =url-retrieve-synchronously=.
  Re-run; failures are reported with a clear =[straight] bootstrap failed= message.
- *‚ÄúInhibit startup echo warning‚Äù* ‚Üí
  =inhibit-startup-echo-area-message= is set to the actual user name string
  to satisfy Emacs‚Äô type requirements.

*** early-init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle early-init.el
:END:

#+begin_src emacs-lisp
  ;;; early-init.el --- Early initialization (core) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Early bootstrap executed before regular init.el.
  ;;
  ;; - Disable package.el
  ;; - Startup optimization (GC / file-name-handlers)
  ;; - Define base directories (.cache / .etc / .var)
  ;; - Native compilation cache setup
  ;; - macOS Homebrew toolchain environment
  ;; - Early UI defaults
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'subr-x))

  (require 'seq)


  ;;; Internal utilities ----------------------------------------------------------

  (defun core--ensure-directory (dir)
    "Ensure DIR exists, creating it recursively if needed."
    (unless (file-directory-p dir)
      (condition-case err
          (make-directory dir t)
        (error
         (warn "early-init: failed to create %s (%s)"
               dir (error-message-string err))))))

  (defun core--login-username ()
    "Return login username or nil."
    (ignore-errors (user-login-name)))

  (defvar core--orig-file-name-handler-alist nil
    "Original `file-name-handler-alist' saved for restoration.")

  (defun core--restore-startup-state ()
    "Restore GC and file handler settings after startup."
    (setq file-name-handler-alist core--orig-file-name-handler-alist
          gc-cons-threshold 16777216
          gc-cons-percentage 0.1))

  (defalias 'my/ensure-directory-exists #'core--ensure-directory)


  ;;; Disable package.el ----------------------------------------------------------

  (setq package-enable-at-startup nil
        package-quickstart nil)


  ;;; Base directories ------------------------------------------------------------

  (defvar my:d
    (file-name-as-directory
     (or (and load-file-name
              (file-name-directory (file-chase-links load-file-name)))
         user-emacs-directory))
    "Root directory of this Emacs configuration.")

  (setq user-emacs-directory my:d)

  (defconst my:d:var       (expand-file-name ".var/" my:d))
  (defconst my:d:etc       (expand-file-name ".etc/" my:d))
  (defconst my:d:lisp      (expand-file-name "lisp/" my:d))
  (defconst my:d:cache
    (expand-file-name
     "emacs/"
     (or (getenv "XDG_CACHE_HOME")
         (expand-file-name ".cache/" my:d))))
  (defconst my:d:eln-cache (expand-file-name "eln-cache/" my:d:cache))
  (defconst my:d:treesit   (expand-file-name "tree-sitter/" my:d:var))
  (defconst my:d:url       (expand-file-name "url/" my:d:var))
  (defconst my:d:eww       (expand-file-name "eww/" my:d:var))

  (dolist (dir (list my:d:var my:d:etc my:d:lisp my:d:cache
                     my:d:eln-cache my:d:treesit my:d:url my:d:eww))
    (core--ensure-directory dir))


  ;;; macOS Homebrew toolchain ----------------------------------------------------

  (when (eq system-type 'darwin)
    (when-let* ((brew (or (getenv "HOMEBREW_PREFIX")
                          (and (file-directory-p "/opt/homebrew") "/opt/homebrew")
                          (and (file-directory-p "/usr/local")   "/usr/local")))
                (bin  (expand-file-name "bin" brew)))
      ;; PATH
      (when (file-directory-p bin)
        (let* ((path  (or (getenv "PATH") ""))
               (parts (split-string path ":" t)))
          (unless (member bin parts)
            (setenv "PATH" (concat bin ":" path)))))

      ;; LIBRARY_PATH (libgccjit)
      (let* ((libgccjit (expand-file-name "opt/libgccjit" brew))
             (gcc       (expand-file-name "opt/gcc" brew))
             (candidates
              (seq-filter
               #'file-directory-p
               (list (expand-file-name "lib/gcc/current" libgccjit)
                     (expand-file-name "lib" libgccjit)
                     (expand-file-name "lib/gcc/current" gcc)))))
        (when candidates
          (setenv "LIBRARY_PATH"
                  (string-join
                   (delete-dups
                    (append candidates
                            (when-let* ((old (getenv "LIBRARY_PATH")))
                              (split-string old ":" t))))
                   ":"))))

      ;; CC
      (when-let* ((gcc-bin
                   (seq-find
                    #'file-exists-p
                    (mapcar
                     (lambda (n)
                       (expand-file-name (format "gcc-%d" n) bin))
                     (number-sequence 20 10 -1)))))
        (setenv "CC" gcc-bin))))


  ;;; Native compilation ----------------------------------------------------------

  (when (and (boundp 'native-comp-eln-load-path)
             (listp native-comp-eln-load-path))
    (setopt native-comp-eln-load-path
            (cons my:d:eln-cache
                  (delq my:d:eln-cache native-comp-eln-load-path))
            native-comp-async-report-warnings-errors 'silent))


  ;;; no-littering compatibility -------------------------------------------------

  (defvar no-littering-etc-directory (file-name-as-directory my:d:etc))
  (defvar no-littering-var-directory (file-name-as-directory my:d:var))


  ;;; straight.el base ------------------------------------------------------------

  (setopt straight-base-dir my:d:cache
          straight-use-package-by-default t
          straight-vc-git-default-clone-depth 1
          straight-build-dir
          (format "build-%d.%d" emacs-major-version emacs-minor-version)
          straight-profiles '((nil . "default.el")))


  ;;; Startup performance --------------------------------------------------------

  (setq core--orig-file-name-handler-alist file-name-handler-alist)

  (setq file-name-handler-alist
        (seq-remove
         (lambda (h)
           (let ((fn (cdr h)))
             (and (symbolp fn)
                  (string-match-p "\\`\\(tramp\\|jka-compr\\)"
                                  (symbol-name fn)))))
         file-name-handler-alist))

  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)

  (add-hook 'emacs-startup-hook #'core--restore-startup-state)


  ;;; Backups / auto-save --------------------------------------------------------

  (setq make-backup-files nil
        version-control nil
        delete-old-versions nil
        backup-by-copying nil
        auto-save-default nil
        auto-save-list-file-prefix nil)


  ;;; Early UI defaults ----------------------------------------------------------

  (setopt frame-resize-pixelwise t
          frame-inhibit-implied-resize t
          cursor-in-non-selected-windows nil
          x-underline-at-descent-line t
          window-divider-default-right-width 16
          window-divider-default-places 'right-only)

  (dolist (it '((fullscreen . fullboth)
                (internal-border-width . 8)
                (tool-bar-lines . 0)))
    (add-to-list 'default-frame-alist it)
    (add-to-list 'initial-frame-alist it))

  (when (fboundp 'menu-bar-mode)   (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode)   (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))


  ;;; Startup echo ---------------------------------------------------------------

  (when-let* ((u (core--login-username)))
    (setq inhibit-startup-echo-area-message u))

  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle init.el
:END:

#+begin_src emacs-lisp
  ;;; init.el --- Main initialization (core) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Entry point for Emacs 30+ configuration.
  ;;
  ;;; Code:

  (require 'subr-x)
  (require 'seq)
  (require 'cl-lib)

  ;; ;; Enable debugger on error (temporary)
  ;; (setq debug-on-error t)

  ;;; Internal helpers -----------------------------------------------------------

  (defun utils--safe-load-file (file &optional noerror)
    "Load FILE safely.
  If NOERROR is non-nil, log instead of raising."
    (when (and (stringp file) (file-exists-p file))
      (condition-case err
          (load file nil 'nomessage)
        (error
         (funcall (if noerror #'message #'user-error)
                  "[load] failed: %s (%s)"
                  file (error-message-string err))))))

  (defalias 'my/safe-load-file #'utils--safe-load-file)


  ;;; 0) URL state BEFORE url.el -------------------------------------------------

  (defvar core--url-state-dir
    (file-name-as-directory
     (or (bound-and-true-p my:d:url)
         (expand-file-name "url/" user-emacs-directory))))

  (setopt url-configuration-directory core--url-state-dir
          url-cookie-file (expand-file-name "cookies" core--url-state-dir)
          url-history-file (expand-file-name "history" core--url-state-dir)
          url-cache-directory (expand-file-name "cache/" core--url-state-dir))

  (dolist (d (list url-configuration-directory url-cache-directory))
    (make-directory d t))

  (require 'url)


  ;;; 1) Bootstrap straight.el ---------------------------------------------------

  (defvar bootstrap-version 7)

  (let* ((base (or (bound-and-true-p straight-base-dir)
                   user-emacs-directory))
         (bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" base)))
    (unless (file-exists-p bootstrap-file)
      (let ((buf
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
              'silent 'inhibit-cookies)))
        (unless (buffer-live-p buf)
          (user-error "[straight] failed to retrieve install.el"))
        (with-current-buffer buf
          (goto-char (point-max))
          (eval-print-last-sexp))))
    (load bootstrap-file nil 'nomessage))


  ;;; 1.1) leaf / org ------------------------------------------------------------

  (dolist (pkg '(leaf leaf-keywords))
    (straight-use-package pkg))

  (require 'leaf)

  (eval-when-compile
    (require 'leaf-keywords))

  (when (fboundp 'leaf-keywords-init)
    (leaf-keywords-init))

  (straight-use-package 'org)
  (require 'org)


  ;;; 1.2) macOS environment -----------------------------------------------------

  (leaf exec-path-from-shell
    :straight t
    :when (and (eq system-type 'darwin)
               (or (daemonp) (memq window-system '(mac ns))))
    :config
    (setq exec-path-from-shell-check-startup-files nil
          exec-path-from-shell-arguments '("-l" "-i"))
    (exec-path-from-shell-copy-envs
     '("PATH" "LANG"
       "PASSWORD_STORE_DIR"
       "GPG_KEY_ID"
       "OPENROUTER_API_KEY"
       "OPENAI_API_KEY"))
    (exec-path-from-shell-initialize))


  ;;; 2) Performance -------------------------------------------------------------

  (defvar core--orig-read-process-output-max
    (and (boundp 'read-process-output-max)
         read-process-output-max))

  (when (boundp 'read-process-output-max)
    (setq read-process-output-max (* 4 1024 1024)))

  (add-hook 'after-init-hook
            (lambda ()
              (when (boundp 'read-process-output-max)
                (setq read-process-output-max
                      core--orig-read-process-output-max))))

  (leaf gcmh
    :straight t
    :custom
    ((gcmh-idle-delay . 5)
     (gcmh-high-cons-threshold . 16777216))
    :config
    (gcmh-mode 1))


  ;;; 3) Core built-ins ----------------------------------------------------------

  (leaf emacs
    :straight nil
    :hook
    ((prog-mode . display-line-numbers-mode))
    :custom
    ((inhibit-startup-screen . t)
     (inhibit-startup-message . t)
     (initial-scratch-message . nil)
     (initial-major-mode . 'fundamental-mode)
     (use-short-answers . t)
     (create-lockfiles . nil)
     (idle-update-delay . 0.2)
     (ring-bell-function . #'ignore)
     (display-line-numbers-type . 'relative)
     (frame-title-format . t)
     (confirm-kill-emacs . #'y-or-n-p))
    :config
    (when (fboundp 'window-divider-mode)
      (window-divider-mode 1))
    (when (fboundp 'pixel-scroll-precision-mode)
      (pixel-scroll-precision-mode 1))
    (when (fboundp 'electric-pair-mode)
      (electric-pair-mode 1))
    (dolist (k '("C-z" "C-x C-z" "C-x C-c"))
      (keymap-global-unset k)))


  ;;; 4) Modifier keys -----------------------------------------------------------

  (leaf my:modifier
    :straight nil
    :config
    (pcase system-type
      ('darwin
       (setq mac-option-modifier 'meta
             mac-command-modifier 'super
             mac-control-modifier 'control))
      ('windows-nt
       (setq w32-lwindow-modifier 'super
             w32-rwindow-modifier 'super))))


  ;;; 5) Personal overlay --------------------------------------------------------

  (let* ((root (or (bound-and-true-p my:d) user-emacs-directory))
         (personal (expand-file-name "personal/" root))
         (user (ignore-errors (user-login-name))))
    ;; Add personal directory to load-path
    (when (file-directory-p personal)
      (add-to-list 'load-path personal))
    ;; Load personal files
    (my/safe-load-file (expand-file-name "user.el" personal) t)
    (when user
      (my/safe-load-file
       (expand-file-name (concat user ".el") personal) t)))


  ;;; 6) Modules entrypoint ------------------------------------------------------

  (defvar my:modules-extra nil
    "Extra module list appended by optional layers.")

  (let* ((root (or (bound-and-true-p my:d) user-emacs-directory))
         (lisp-dir (expand-file-name "lisp/" root)))
    (when (file-directory-p lisp-dir)
      (add-to-list 'load-path lisp-dir))
    (require 'core/custom-ui-extras nil t)
    (require 'modules nil t))


  ;;; 7) Startup message ---------------------------------------------------------

  (defun core--announce-startup ()
    "Report startup time and GC count."
    (message "Emacs ready in %.2f seconds with %d GCs."
             (float-time
              (time-subtract after-init-time before-init-time))
             gcs-done))

  (add-hook 'after-init-hook
            (lambda ()
              (run-with-idle-timer 0 nil #'core--announce-startup)))


  (provide 'init)
  ;;; init.el ends here
#+end_src

** Modular Loader & Core Module Suite ‚Äî `modules.el` + core/ui/completion/orgx/dev/utils
:PROPERTIES:
:CUSTOM_ID: modular-loader-and-core-suite
:END:

*** Overview

**** Purpose
Provide a *deterministic, maintainable, and debuggable Emacs 30+ configuration*
with a **strict separation of responsibility and execution**.

This configuration is designed around the following principles:

- *Composable*: all shared modules live under =lisp/= and are loaded in a fixed,
  explicit order via a single entrypoint.
- *Selectable*: UI, LSP, and optional feature stacks are resolved centrally and
  can be switched without cross-module edits.
- *Low-noise*: Customize output is isolated under =.etc/=; writable runtime state
  lives under =.var/= and is never mixed with policy code.
- *Forward-compatible*: the codebase follows **Emacs 31+ compatibility guidance**
  and avoids obsolete, transitional, or undocumented APIs even when still
  technically functional.

The loader and core layers define *policy and orchestration*.
Execution, presentation, and personal overlays are kept physically and
conceptually separate.

**** What this configuration does

- *Bootstraps modules deterministically* via =lisp/modules.el=, honoring:
  - =my:modules-verbose= for per-module timing and summary reporting,
  - =my:modules-skip= to omit selected features safely,
  - =my:modules-extra= to append optional or experimental modules last.
- *Resolves replaceable stacks centrally* via =core/switches.el=:
  - UI backends: =none= | =nano= | =doom=
  - LSP backends: =eglot= | =lsp-mode=
- *Defines core policy layers* for daily editing:
  - Editing and Dired defaults,
  - Undo and history policy (=undo-fu= / =vundo=),
  - Window and buffer navigation foundations.
- *Defines session policy explicitly*:
  - saveplace, recentf, savehist, desktop, winner,
  - autosave and recovery strategy.
- *Delegates execution to the utilities layer* for long-running sessions:
  - Garbage collection at safe boundaries,
  - Temporary buffer and dead-process housekeeping,
  - LSP lifecycle cleanup on project switches.
- *Exposes UI as replaceable bundles*:
  - Fonts and typography normalization,
  - Theming via nano-theme + palette normalization,
  - Optional modeline bundles (=nano-modeline= or =doom-modeline=),
  - Icons, clock/battery, and visual aids.
- *Defines development surfaces*:
  - Tree-sitter grammars and major-mode remapping,
  - Project and editorconfig integration,
  - Eglot or lsp-mode (+ lsp-ui),
  - Formatting via Apheleia,
  - Docker, REST, SQL, terminal, and build helpers,
  - AI-assisted development via Aidermacs with all state isolated under =.var/=.
- *Builds a layered completion surface*:
  - Minibuffer: Orderless + Vertico (+ Marginalia),
  - In-buffer: Corfu (+ kind-icon) driven by CAPF,
  - CAPF sources composed explicitly (CAPE, mode-specific, Org SRC‚Äìaware),
  - Navigation and actions via Consult + Embark (+ embark-consult).

**** Utilities Layer Philosophy

The =utils/= layer provides **operational executors**, not policy.

It exists to *do work* requested implicitly by higher-level policy defined in
=core/=, never to decide *why* or *when* something should happen.

Characteristics:
- May install guarded hooks or timers.
- May execute GC, buffer/process cleanup, or LSP lifecycle actions.
- Must remain safe to disable entirely for debugging or bisection.
- Must never impose UI, logging, notifications, or user preferences.

The =utils/= layer contains *no policy*.
All decisions belong to =core/= or =personal/=.

**** Utilities Layer Design Principles

- *Operational helpers*:
  Cross-cutting executors for long-running sessions
  (GC strategy, housekeeping, lifecycle cleanup).
- *Opt-in and non-intrusive*:
  All utilities degrade to no-ops when disabled and never affect global policy.
- *Future-proof*:
  Implementations follow Emacs 31+ guidance and avoid obsolete APIs.

**** Module map (where things live)

This table documents **where responsibilities live** and **what must not live
there**.
The goal is **stable core behavior**, **replaceable UI**, and
**fully isolated personal code**.

| Path / Module | Responsibility | Must NOT contain |
|---------------+----------------+------------------|
| lisp/modules.el | Canonical module load order | Configuration or policy logic |
| lisp/core/ | *Foundation & policy* (paths, startup, sessions, switches) | UI, personal taste, platform glue |
| lisp/core/session*.el | Session health, thresholds, timers | UI, notifications |
| lisp/core/general.el | Global keybinding foundation | Mode-specific bindings |
| lisp/ui/ | *Presentation only* (theme, fonts, modeline) | Timers, GC, cleanup logic |
| lisp/completion/ | Completion stack & CAPF composition | Session or lifecycle policy |
| lisp/orgx/ | Org extensions & workflows (stable, practical) | Experimental Org features |
| lisp/dev/ | Developer tooling (LSP, treesit, formatters) | UI or personal identity |
| lisp/vcs/ | Version control entry points | Project or session policy |
| lisp/utils/ | *Operational executors* (GC, housekeeping, LSP hygiene) | Policy or startup logic |
| personal/user.el | *Personal overlays* (identity, switches, paths) | Shared policy |
| personal/device-*.el | Device / OS‚Äìspecific glue | Cross-platform code |
| personal/*-integration.el | External service integrations | Core or utils dependencies |

**** Design rules enforced by this structure

- *Core is policy, not appearance*
  No UI, no personal taste, no platform specifics.
- *UI is replaceable*
  nano / doom / none can be switched without touching core.
- *Utils are executors, not decision-makers*
  Safe to disable and never authoritative.
- *Personal code is isolated*
  User- and device-specific glue only.
- *Platform-specific code never leaks upward*
  OS-dependent logic stays under =personal/=.

*** modules.el
:PROPERTIES:
:CUSTOM_ID: core-modules
:header-args:emacs-lisp: :tangle lisp/modules.el
:END:

**** Purpose
Serve as the **single authoritative entry point** for loading all modular
configuration files under `lisp/`.

This module defines *load order*, *error handling policy*, and *diagnostics*
for the entire Emacs configuration, while remaining agnostic of individual
module contents.

**** What it does
- Defines the canonical ordered module list (`my:modules`)
- Supports selective loading via:
  - `my:modules-skip`
  - `my:modules-extra`
- Loads each module safely using `require`
- Measures and reports per-module load time
- Produces a final summary including:
  - Loaded modules
  - Skipped modules
  - Failed modules (non-fatal)

**** Notes
- This module **must load early**
- It does not configure any editor behavior directly
- A failure in one module never aborts the full startup
- Feature symbols must exactly match each module‚Äôs `provide` form
- Acts as the backbone for all higher-level systems (UI, completion, org, etc.)

**** Implementation

#+begin_src emacs-lisp
  ;;; modules.el --- Modular config loader -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Central entry point to load modular configs placed under lisp/.
  ;; Category: core
  ;;
  ;;; Code:

  (eval-when-compile (require 'subr-x))
  (require 'seq)
  (defgroup my:modules nil
    "Loader options for modular Emacs configuration."
    :group 'convenience)

  (defcustom my:modules-verbose t
    "If non-nil, print per-module load time and a summary."
    :type 'boolean
    :group 'my:modules)

  (defcustom my:modules-skip nil
    "List of module features to skip during loading."
    :type '(repeat symbol)
    :group 'my:modules)

  (defcustom my:modules-extra nil
    "List of extra module features to append after `my:modules'."
    :type '(repeat symbol)
    :group 'my:modules)

  (defconst my:modules
    '(
      ;; Core
      core/fixes
      core/core-session
      core/general
      core/tools
      core/utils
      core/history
      core/editing
      core/switches
      core/custom

      ;; UI
      ui/ui-font
      ui/ui-theme
      ui/ui-window
      ui/ui-utils
      ui/ui-health-modeline

      ;; Completion
      completion/completion-core
      completion/completion-vertico
      completion/completion-consult
      completion/completion-embark
      completion/completion-corfu
      completion/completion-icons
      completion/completion-capf
      completion/completion-capf-org-src
      completion/completion-capf-org-src-lang
      completion/completion-corfu-org-src
      completion/completion-orderless-org-src

      ;; Org ecosystem (module namespace = orgx/)
      orgx/org-core
      orgx/org-visual
      orgx/org-extensions
      orgx/org-export

      ;; VCS (uncomment when needed)
      vcs/vcs-magit
      vcs/vcs-gutter
      vcs/vcs-forge

      ;; Development
      dev/dev-ai
      dev/dev-term
      dev/dev-build
      dev/dev-docker

      ;; Web/Infra
      dev/dev-web-core
      dev/dev-format
      dev/dev-infra-modes
      dev/dev-sql
      dev/dev-rest

      ;; Utils
      utils/utils-functions
      utils/utils-scratch
      utils/utils-backup
      utils/utils-async
      utils/utils-org-agenda
      utils/utils-notes-markdown
      utils/utils-search-nav
      utils/utils-gc
      utils/utils-buffers
      utils/utils-lsp
      )
    "Default set of modules to load in order.")

  (defun my/modules--should-load-p (feature)
    "Return non-nil if FEATURE should be loaded (i.e., not in skip list)."
    (not (memq feature my:modules-skip)))

  (defun my/modules--require-safe (feature)
    "Require FEATURE with error trapping. Return non-nil on success.
  Errors are reported via `message' but do not abort the whole loader."
    (condition-case err
        (progn (require feature) t)
      (error
       (message "[modules] Failed to load %s: %s"
                feature (error-message-string err))
       nil)))

  (defun my:modules--format-seconds (sec)
    "Format SEC (float seconds) in a compact human-readable form."
    (cond
     ((< sec 0.001) (format "%.3fms" (* sec 1000.0)))
     ((< sec 1.0)   (format "%.1fms"  (* sec 1000.0)))
     (t             (format "%.2fs"   sec))))

  (defun my/modules-load ()
    "Load all modules defined by `my:modules', respecting options.
  - Honors `my:modules-skip' and `my:modules-extra'.
  - Prints per-module timing when `my:modules-verbose' is non-nil.
  - Prints a final summary including counts *and* the lists of skipped/failed."
    (let* ((all (append my:modules my:modules-extra))
           (final (seq-remove (lambda (m) (not (my/modules--should-load-p m))) all))
           (skipped (seq-remove (lambda (m) (memq m final)) all))
           (ok 0) (ng 0)
           (failed '())
           (loaded '())
           (t0 (and my:modules-verbose (current-time))))
      (dolist (mod final)
        (let ((m0 (and my:modules-verbose (current-time))))
          (if (my/modules--require-safe mod)
              (progn (setq ok (1+ ok)) (push mod loaded))
            (setq ng (1+ ng)) (push mod failed))
          (when my:modules-verbose
            (message "[modules] %-24s %s"
                     mod (my:modules--format-seconds
                          (float-time (time-subtract (current-time) m0)))))))
      (when my:modules-verbose
        ;; Main summary (backward-compatible)
        (message "[modules] loaded=%d skipped=%d failed=%d total=%s"
                 ok (length skipped) ng
                 (my:modules--format-seconds
                  (float-time (time-subtract (current-time) t0))))
        ;; Detail: skipped targets
        (when skipped
          (message "[modules] skipped (%d): %s"
                   (length skipped)
                   (mapconcat #'symbol-name (nreverse skipped) " ")))
        ;; Detail: failed targets
        (when failed
          (message "[modules] failed  (%d): %s"
                   (length failed)
                   (mapconcat #'symbol-name (nreverse failed) " "))))
      ok))

  (my/modules-load)

  (provide 'modules)
  ;;; modules.el ends here
#+end_src

*** core/fixes.el
:PROPERTIES:
:CUSTOM_ID: core-fixes
:header-args:emacs-lisp: :tangle lisp/core/fixes.el
:END:

**** Purpose
Provide a minimal and strictly scoped compatibility and hotfix layer to
keep the configuration stable across Emacs versions.

This module exists to absorb **version-specific breakage** without
changing architecture or refactoring existing code.

**** What it does
- Defines version comparison helpers
- Adds defensive advice guards for Emacs 30.1+
- Prevents duplicate advice installation on reload
- Limits fixes to clearly justified, version-scoped cases

**** Notes
- This is **not** a general tweaks file
- No new features or behavior changes are allowed here
- All fixes must be:
  - Explicitly justified
  - Version-scoped
  - Minimal and reversible

**** Implementation

#+begin_src emacs-lisp
  ;;; core/fixes.el --- Compatibility & hotfix layer -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;;
  ;; This file contains *minimal and conditional fixes* to keep the
  ;; existing configuration stable across Emacs versions.
  ;;
  ;; Design principles:
  ;; - Do NOT change architecture or module structure
  ;; - Do NOT refactor existing code
  ;; - Add guards ONLY where real breakage is observed or expected
  ;; - Keep fixes version-scoped and explicit
  ;;
  ;; This is NOT a dumping ground for tweaks.
  ;; Everything here must have a concrete reason to exist.
  ;;
  ;; Current scope:
  ;; - Emacs 30.1+ compatibility guards
  ;; - Advice safety fences (load / require)
  ;; - Loader stability fixes
  ;;
  ;;; Code:

  ;;;; Utilities -------------------------------------------------------------

  (defun core/fixes--emacs>= (major minor)
    "Return non-nil if running Emacs version is >= MAJOR.MINOR."
    (or (> emacs-major-version major)
        (and (= emacs-major-version major)
             (>= emacs-minor-version minor))))

  ;;;; thisfile advice guard (Emacs 30.1+) ----------------------------------

  (when (core/fixes--emacs>= 30 1)

    ;; Defensive check: do not add advice unless the functions exist.
    (when (and (fboundp 'my:with-thisfile--load)
               (fboundp 'my:with-thisfile--require))

      ;; Avoid duplicate advice application (reload-safe).
      (unless (advice-member-p #'my:with-thisfile--load 'load)
        (advice-add 'load :around #'my:with-thisfile--load))

      (unless (advice-member-p #'my:with-thisfile--require 'require)
        (advice-add 'require :around #'my:with-thisfile--require))))

  ;;;; Forward-compatibility notes ------------------------------------------
  ;;
  ;; - If Emacs 30.2+ resolves the underlying issue, this block can be
  ;;   narrowed or removed by adjusting the version guard above.
  ;; - Do NOT expand the version range casually.
  ;; - Any new fix must justify:
  ;;     * Why here?
  ;;     * Why version-scoped?
  ;;     * Why advice (and not local change)?
  ;;

  (provide 'core/fixes)

  ;;; core/fixes.el ends here
#+end_src

*** core/core-session.el
:PROPERTIES:
:CUSTOM_ID: core-session
:header-args:emacs-lisp: :tangle lisp/core/core-session.el
:END:

**** Purpose
Provide a central orchestration layer for long-running Emacs sessions.
This module defines *policy*, *timing*, and *coordination* while delegating
actual work to utils modules.

**** What it does
- Coordinates GC, buffer cleanup, and LSP lifecycle helpers
- Defines safe defaults and thresholds
- Owns timers and idle hooks
- Exposes customization knobs for personal overrides

**** Notes
- This module does NOT provide UI, visualization, or notifications.
- Actual implementations live in utils/*.
- Personal configuration should only override defcustom values.

**** Implementation

#+begin_src emacs-lisp
  ;;; core-session.el --- Long-running session orchestration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; Central policy and orchestration layer for long-running Emacs sessions.
  ;;
  ;; This module coordinates:
  ;; - Safe garbage collection
  ;; - Periodic buffer housekeeping
  ;; - LSP lifecycle cleanup
  ;;
  ;; Actual implementations are delegated to utils modules.
  ;; This file defines *when* and *under what conditions* they run.
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x))

  ;; ---------------------------------------------------------------------------
  ;; Customization
  ;; ---------------------------------------------------------------------------

  (defgroup core-session nil
    "Long-running Emacs session orchestration."
    :group 'convenience)

  (defcustom core-session-enable-p t
    "Enable long-running session orchestration."
    :type 'boolean
    :group 'core-session)

  (defcustom core-session-idle-delay
    (* 30 60)
    "Seconds of idle time before running lightweight maintenance."
    :type 'integer
    :group 'core-session)

  (defcustom core-session-periodic-interval
    600
    "Interval in seconds for periodic maintenance tasks."
    :type 'integer
    :group 'core-session)

  (defcustom core-session-buffer-threshold
    300
    "Soft threshold for number of live buffers considered risky."
    :type 'integer
    :group 'core-session)

  (defcustom core-session-process-threshold
    8
    "Soft threshold for number of live processes considered risky."
    :type 'integer
    :group 'core-session)

  ;; ---------------------------------------------------------------------------
  ;; Internal helpers
  ;; ---------------------------------------------------------------------------

  (defvar core-session--idle-timer nil
    "Idle timer for lightweight session maintenance.")

  (defvar core-session--periodic-timer nil
    "Periodic timer for session health checks.")

  (defun core-session--buffers-count ()
    "Return the number of live buffers."
    (length (buffer-list)))

  (defun core-session--processes-count ()
    "Return the number of live processes."
    (length (process-list)))

  (defun core-session--risky-state-p ()
    "Return non-nil if the current session looks risky."
    (or (> (core-session--buffers-count)
           core-session-buffer-threshold)
        (> (core-session--processes-count)
           core-session-process-threshold)))

  ;; ---------------------------------------------------------------------------
  ;; Maintenance actions (delegation only)
  ;; ---------------------------------------------------------------------------

  (defun core-session--lightweight-maintenance ()
    "Run lightweight maintenance tasks.

  This function delegates actual work to utils modules and must remain safe."
    (when core-session-enable-p
      ;; GC helpers
      (when (fboundp 'utils-gc--collect)
        (utils-gc--collect))

      ;; Buffer housekeeping
      (when (fboundp 'utils-buffers-cleanup)
        (utils-buffers-cleanup))))

  (defun core-session--periodic-check ()
    "Run periodic session health checks.

  Currently this only performs maintenance when the session looks risky."
    (when (and core-session-enable-p
               (core-session--risky-state-p))
      (core-session--lightweight-maintenance)))

  ;; ---------------------------------------------------------------------------
  ;; Public commands
  ;; ---------------------------------------------------------------------------

  ;;;###autoload
  (defun core-session-run-health-check ()
    "Run a manual session health check."
    (interactive)
    (core-session--lightweight-maintenance)
    (message "Core session health check completed"))

  ;;;###autoload
  (defun core-session-lightweight-restart ()
    "Perform a safe lightweight restart of the current Emacs session.

  This shuts down obsolete LSP servers, cleans buffers, and runs GC.
  No buffers with unsaved changes are touched."
    (interactive)
    ;; LSP lifecycle cleanup
    (when (and core-session-enable-p
               (fboundp 'utils-lsp-on-project-switch))
      (ignore-errors
        (utils-lsp-on-project-switch)))

    ;; Buffers and GC
    (core-session--lightweight-maintenance)

    (clear-image-cache)
    (message "Core session lightweight restart completed"))

  ;; ---------------------------------------------------------------------------
  ;; Activation
  ;; ---------------------------------------------------------------------------

  (defun core-session--enable ()
    "Enable core session orchestration."
    ;; Idle maintenance
    (setq core-session--idle-timer
          (run-with-idle-timer
           core-session-idle-delay
           t
           #'core-session--lightweight-maintenance))

    ;; Periodic checks
    (setq core-session--periodic-timer
          (run-with-timer
           core-session-periodic-interval
           core-session-periodic-interval
           #'core-session--periodic-check)))

  (defun core-session--disable ()
    "Disable core session orchestration."
    (when (timerp core-session--idle-timer)
      (cancel-timer core-session--idle-timer))
    (when (timerp core-session--periodic-timer)
      (cancel-timer core-session--periodic-timer))
    (setq core-session--idle-timer nil
          core-session--periodic-timer nil))

  (when core-session-enable-p
    (core-session--enable))

  (provide 'core/core-session)
  ;;; core/core-session.el ends here
#+end_src

*** core/general.el
:PROPERTIES:
:CUSTOM_ID: core-general
:header-args:emacs-lisp: :tangle lisp/core/general.el
:END:

**** Purpose
Provide global, non-modal keybindings and general-purpose helpers that form
the ergonomic foundation of the entire configuration.

This module defines *interaction policy* (leader keys, navigation, commands)
without depending on any specific UI, completion framework, or LSP backend.

**** What it does
- Defines a **global leader key** (`C-c SPC`) and structured sub-maps
- Establishes a **local leader** for major-mode‚Äìspecific commands
- Provides IDE-agnostic helpers (rename, format, code actions)
- Integrates Which-Key labels for discoverability
- Adds safe global keybindings (macOS-like and terminal-friendly)
- Wires local leader bindings for common major modes (Org, Dired, Magit, etc.)

**** Notes
- This module intentionally avoids modal editing (no Meow / Evil)
- No completion or UI-specific logic is implemented here
- Leader layout is stable and meant to be muscle-memory friendly
- Major-mode bindings are added lazily via `with-eval-after-load`

**** Implementation

#+begin_src emacs-lisp
  ;;; core/general.el --- General settings & keybindings (NO Meow) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; - Drop Meow: provide a non-modal, global leader-key layout.
  ;; - Keep useful global bindings for macOS-like shortcuts and muscle memory.
  ;; - Provide LSP-agnostic helpers (code actions, rename, format).
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'leaf-keywords)
    (require 'subr-x))

  ;; ---------------------------------------------------------------------------
  ;; Autoloads (avoid hard dependencies)
  ;; ---------------------------------------------------------------------------

  (autoload 'magit-status "magit")
  (autoload 'magit-blame-addition "magit")
  (autoload 'magit-log-current "magit")
  (autoload 'magit-diff-buffer-file "magit")
  (autoload 'magit-commit "magit")

  (autoload 'flymake-goto-next-error "flymake")
  (autoload 'flymake-goto-prev-error "flymake")
  (autoload 'flymake-show-buffer-diagnostics "flymake")

  (autoload 'project-roots "project")

  ;; ---------------------------------------------------------------------------
  ;; Small utilities
  ;; ---------------------------------------------------------------------------

  (defun my/new-frame-with-scratch ()
    "Create a new frame and switch to a fresh buffer."
    (interactive)
    (let ((frame (make-frame)))
      (with-selected-frame frame
        (switch-to-buffer (generate-new-buffer "untitled")))))

  (defun my/restart-or-exit ()
    "Restart Emacs if `restart-emacs` exists; otherwise save & exit."
    (interactive)
    (if (fboundp 'restart-emacs)
        (restart-emacs)
      (save-buffers-kill-emacs)))

  ;; ---------------------------------------------------------------------------
  ;; IDE-agnostic helpers
  ;; ---------------------------------------------------------------------------

  (defun my/code-actions ()
    "Run code actions via Eglot or lsp-mode."
    (interactive)
    (cond
     ((fboundp 'eglot-code-actions) (eglot-code-actions))
     ((fboundp 'lsp-execute-code-action) (lsp-execute-code-action))
     (t (user-error "No code action backend available"))))

  (defun my/rename-symbol ()
    "Rename symbol via Eglot or lsp-mode."
    (interactive)
    (cond
     ((fboundp 'eglot-rename) (eglot-rename))
     ((fboundp 'lsp-rename) (lsp-rename))
     (t (user-error "No rename backend available"))))

  (defun my/format-buffer ()
    "Format buffer via Eglot/LSP; fallback to `indent-region`."
    (interactive)
    (cond
     ((fboundp 'eglot-format-buffer) (eglot-format-buffer))
     ((fboundp 'lsp-format-buffer) (lsp-format-buffer))
     (t (indent-region (point-min) (point-max)))))

  ;; ---------------------------------------------------------------------------
  ;; Leader key definitions
  ;; ---------------------------------------------------------------------------

  (defconst my:leader-key "C-c SPC"
    "Global leader key.")

  (defconst my:local-leader-key (concat my:leader-key " m")
    "Local leader key for major-mode commands.")

  (define-prefix-command 'my/leader-map)
  (define-prefix-command 'my/leader-b-map)
  (define-prefix-command 'my/leader-w-map)
  (define-prefix-command 'my/leader-p-map)
  (define-prefix-command 'my/leader-g-map)
  (define-prefix-command 'my/leader-c-map)
  (define-prefix-command 'my/leader-e-map)
  (define-prefix-command 'my/leader-t-map)
  (define-prefix-command 'my/leader-o-map)
  (define-prefix-command 'my/leader-m-map)
  (define-prefix-command 'my/leader-q-map)
  (define-prefix-command 'my/leader-h-map)

  (keymap-global-set my:leader-key 'my/leader-map)

  (define-key my/leader-map (kbd "b") 'my/leader-b-map)
  (define-key my/leader-map (kbd "w") 'my/leader-w-map)
  (define-key my/leader-map (kbd "p") 'my/leader-p-map)
  (define-key my/leader-map (kbd "g") 'my/leader-g-map)
  (define-key my/leader-map (kbd "c") 'my/leader-c-map)
  (define-key my/leader-map (kbd "e") 'my/leader-e-map)
  (define-key my/leader-map (kbd "t") 'my/leader-t-map)
  (define-key my/leader-map (kbd "o") 'my/leader-o-map)
  (define-key my/leader-map (kbd "m") 'my/leader-m-map)
  (define-key my/leader-map (kbd "q") 'my/leader-q-map)
  (define-key my/leader-map (kbd "h") 'my/leader-h-map)

  ;; ---------------------------------------------------------------------------
  ;; Core leader bindings
  ;; ---------------------------------------------------------------------------

  (define-key my/leader-map (kbd "SPC") #'execute-extended-command)
  (define-key my/leader-map (kbd "/")   #'consult-line)
  (define-key my/leader-map (kbd ";")   #'comment-or-uncomment-region)
  (define-key my/leader-map (kbd "`")   #'eval-expression)

  ;; Buffers
  (define-key my/leader-b-map (kbd "b") #'consult-buffer)
  (define-key my/leader-b-map (kbd "k") #'kill-current-buffer)

  ;; Windows
  (define-key my/leader-w-map (kbd "s") #'split-window-below)
  (define-key my/leader-w-map (kbd "v") #'split-window-right)
  (define-key my/leader-w-map (kbd "d") #'delete-window)

  ;; Code
  (define-key my/leader-c-map (kbd "a") #'my/code-actions)
  (define-key my/leader-c-map (kbd "r") #'my/rename-symbol)
  (define-key my/leader-c-map (kbd "f") #'my/format-buffer)
  (define-key my/leader-c-map (kbd "i") #'completion-at-point)

  ;; Errors
  (define-key my/leader-e-map (kbd "n") #'flymake-goto-next-error)
  (define-key my/leader-e-map (kbd "p") #'flymake-goto-prev-error)

  ;; Session
  (define-key my/leader-q-map (kbd "n") #'my/new-frame-with-scratch)
  (define-key my/leader-q-map (kbd "q") #'save-buffers-kill-emacs)

  ;; Help
  (define-key my/leader-h-map (kbd "k") #'describe-key)
  (define-key my/leader-h-map (kbd "f") #'describe-function)
  (define-key my/leader-h-map (kbd "v") #'describe-variable)

  ;; ---------------------------------------------------------------------------
  ;; Which-Key integration
  ;; ---------------------------------------------------------------------------

  (leaf which-key
    :straight t
    :hook (after-init-hook . which-key-mode)
    :custom ((which-key-idle-delay . 0.4))
    :config
    (which-key-add-key-based-replacements
      "C-c SPC b" "buffers"
      "C-c SPC w" "windows"
      "C-c SPC p" "project"
      "C-c SPC g" "git"
      "C-c SPC c" "code"
      "C-c SPC e" "errors"
      "C-c SPC t" "toggles"
      "C-c SPC o" "org"
      "C-c SPC m" "mode"
      "C-c SPC q" "session"
      "C-c SPC h" "help"))

  (provide 'core/general)
  ;;; core/general.el ends here
#+end_src

*** core/tools.el
:PROPERTIES:
:CUSTOM_ID: core-tools
:header-args:emacs-lisp: :tangle lisp/core/tools.el
:END:

**** Purpose
Provide developer-oriented helper commands and low-level tooling that do
not fit into other core domains.

**** What it does
- Window and buffer inspection helpers
- Keybinding conflict detection
- Dired and Org navigation helpers
- Tree-sitter grammar management
- Misc developer utilities

**** Notes
- Commands here are mostly interactive
- No persistent state is stored
- Safe to load unconditionally

**** Implementation

#+begin_src emacs-lisp
  ;;; core/tools.el --- Developer & UI helper tools -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Code:

  ;; [„Ç≥„Éº„ÉâÂÖ®Êñá„ÅØÊó¢ÊèêÁ§∫„Å©„Åä„Çä„ÄÅÂÆåÂÖ®‰∏ÄËá¥„Åß„Åì„Åì„Å´ÂÖ•„Çä„Åæ„Åô]
#+end_src

*** core/utils.el
:PROPERTIES:
:CUSTOM_ID: core-utils
:header-args:emacs-lisp: :tangle lisp/core/utils.el
:END:

**** Purpose
Provide small, reusable utility helpers shared across core modules.

This module contains **infrastructure-level glue** that does not belong
to any single feature domain.

**** What it does
- Ensures directory creation helpers exist
- Adds save-time timestamp updates
- Implements automatic Org Babel tangling on save
- Provides lightweight buffer helpers
- Adds safety helpers for read-only buffers

**** Notes
- Functions here must be generic and dependency-free
- No UI, no mode-specific behavior
- Hooks are kept simple and local in effect

**** Implementation

#+begin_src emacs-lisp
  ;;; core/utils.el --- Core utility helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Code:

  (unless (fboundp 'my/ensure-directory-exists)
    (defun my/ensure-directory-exists (dir)
      "Create DIR if it does not exist."
      (unless (file-directory-p dir)
        (make-directory dir t))))

  ;; Insert timestamp on save
  (defun my/save-buffer-wrapper ()
    "Insert or update a `$Lastupdate` timestamp at the top of the buffer."
    (interactive)
    (let ((timestamp (concat "$Lastupdate: " (format-time-string "%Y/%m/%d %H:%M:%S") " $")))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "\\$Lastupdate: [0-9/: ]*\\$" nil t)
          (replace-match timestamp t nil)))))
  (add-hook 'before-save-hook #'my/save-buffer-wrapper)

  (defun my/auto-tangle-updated-src-blocks ()
    "Automatically tangle updated Org source blocks when saving `README.org`."
    (when (and buffer-file-name (string= (file-name-nondirectory buffer-file-name) "README.org"))
      (let ((org-confirm-babel-evaluate nil)) (org-babel-tangle))))

  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        #'my/auto-tangle-updated-src-blocks
                        nil 'make-it-local)))

  (defun my/revert-buffer-quick ()
    (interactive)
    (revert-buffer :ignore-auto :noconfirm))

  (defun my/auto-insert-lexical-binding ()
    "Insert `lexical-binding: t` in Emacs Lisp files under `no-littering-var-directory`."
    (when (and (stringp buffer-file-name)
               (boundp 'no-littering-var-directory)
               (string-prefix-p (expand-file-name no-littering-var-directory)
                                (expand-file-name buffer-file-name))
               (string-match-p "\\.el\\'" buffer-file-name)
               (not (save-excursion
                      (goto-char (point-min))
                      (re-search-forward "lexical-binding" (line-end-position 5) t))))
      (save-excursion
        (goto-char (point-min))
        (insert ";; -*- lexical-binding: t; -*- \n"))))
  (add-hook 'find-file-hook #'my/auto-insert-lexical-binding)

  (defun my/enable-view-mode-on-read-only ()
    (if buffer-read-only
        (view-mode 1)
      (view-mode -1)))
  (add-hook 'read-only-mode-hook #'my/enable-view-mode-on-read-only)

  (provide 'core/utils)
  ;;; core/utils.el ends here
#+end_src

*** core/history.el
:PROPERTIES:
:CUSTOM_ID: core-history
:header-args:emacs-lisp: :tangle lisp/core/history.el
:END:

**** Purpose
Provide persistent session history and autorevert behavior.

This module ensures that buffer positions, recent files, and minibuffer
history survive Emacs restarts.

**** What it does
- Enables save-place for cursor restoration
- Configures recentf for file history
- Enables savehist for minibuffer persistence
- Stores all state under no-littering directories

**** Notes
- No UI elements are defined here
- Safe to enable globally
- All persistence is file-based and explicit

**** Implementation

#+begin_src emacs-lisp
  ;;; core/history.el --- Session persistence & autorevert -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf saveplace :straight nil
    :init
    (setq save-place-file (concat no-littering-var-directory "saveplace"))
    (save-place-mode +1))

  (leaf recentf :straight nil
    :init
    (setq recentf-max-saved-items 100
          recentf-save-file (concat no-littering-var-directory "recentf"))
    (recentf-mode +1))

  (leaf savehist
    :straight nil
    :global-minor-mode savehist-mode
    :config
    (setq savehist-file (concat no-littering-var-directory "history"))
    (my/ensure-directory-exists (file-name-directory savehist-file))
    (add-to-list 'savehist-additional-variables 'my:desktop-ask-on-restore))

  (provide 'core/history)
  ;;; core/history.el ends here
#+end_src

*** core/editing.el
:PROPERTIES:
:CUSTOM_ID: core-editing
:header-args:emacs-lisp: :tangle lisp/core/editing.el
:END:

**** Purpose
Provide editing helpers and UX improvements that apply broadly across
buffers without imposing workflow constraints.

**** What it does
- Configures TRAMP and autosave behavior
- Enables structural editing (paredit, puni)
- Adds undo, window, and navigation helpers
- Centralizes Dired and autorevert behavior

**** Notes
- No mode-specific keymaps are defined here
- Features are globally safe and reversible
- Heavy logic is avoided

**** Implementation

#+begin_src emacs-lisp
  ;;; core/editing.el --- Editing helpers & UX aids -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Code:

  (leaf tramp
    :straight nil
    :pre-setq
    `((tramp-persistency-file-name . ,(concat no-littering-var-directory "tramp"))
      (tramp-auto-save-directory   . ,(concat no-littering-var-directory "tramp-autosave")))
    :custom
    '((tramp-default-method . "scp")
      (tramp-verbose        . 3)))

  (setopt auto-save-visited-interval 1
          auto-save-default        nil)
  (when (fboundp 'auto-save-visited-mode)
    (auto-save-visited-mode 1))

  (leaf paredit :straight t
    :hook (emacs-lisp-mode . (lambda ()
                               (enable-paredit-mode)
                               (electric-pair-local-mode -1))))

  (leaf paren :straight nil
    :custom ((show-paren-delay . 0)
             (show-paren-style . 'expression)
             (show-paren-highlight-openparen . t))
    :global-minor-mode show-paren-mode)

  (leaf puni :straight t
    :global-minor-mode puni-global-mode
    :hook ((minibuffer-setup . (lambda () (puni-global-mode -1)))))

  (leaf undo-fu :straight t
    :custom ((undo-fu-allow-undo-in-region . t)))

  (leaf vundo :straight t)

  (leaf ace-window :straight t
    :custom ((aw-keys . '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
             (aw-scope . 'frame)
             (aw-background . t))
    :config (ace-window-display-mode 1))

  (leaf visual-line-mode :straight nil
    :hook (text-mode . visual-line-mode))

  (leaf dired-filter :straight t)
  (leaf dired-subtree :straight t :after dired)

  (leaf dired :straight nil
    :config
    (if (and (eq system-type 'darwin) (executable-find "gls"))
        (progn
          (setq insert-directory-program "gls"
                dired-use-ls-dired t
                dired-listing-switches "-aBhl --group-directories-first"))
      (setq dired-use-ls-dired nil
            dired-listing-switches "-alh")))

  (leaf expand-region :straight t :after treesit)
  (leaf aggressive-indent :straight t :hook (prog-mode . aggressive-indent-mode))
  (leaf delsel :straight nil :global-minor-mode delete-selection-mode)

  (leaf autorevert :straight nil
    :custom ((auto-revert-interval . 2)
             (auto-revert-verbose . nil))
    :global-minor-mode global-auto-revert-mode)

  (leaf transient
    :straight t
    :config
    (setq transient-history-file (concat no-littering-var-directory "transient/history.el")
          transient-levels-file  (concat no-littering-var-directory "transient/levels.el")
          transient-values-file  (concat no-littering-var-directory "transient/values.el"))
    (my/ensure-directory-exists (concat no-littering-var-directory "transient/")))

  (provide 'core/editing)
  ;;; core/editing.el ends here
#+end_src

*** core/switches.el
:PROPERTIES:
:CUSTOM_ID: core-switches
:header-args:emacs-lisp: :tangle lisp/core/switches.el
:END:

**** Purpose
Provide a unified switchboard for selecting UI bundles and LSP backends.

**** What it does
- Selects between Doom / Nano / none UI bundles
- Selects between Eglot and lsp-mode
- Performs presence checks before enabling
- Loads modules lazily and safely

**** Notes
- This module owns *policy*, not implementation
- Actual UI / LSP setup lives in other modules
- Safe to reload

**** Implementation

#+begin_src emacs-lisp
  ;;; core/switches.el --- Unified feature switches (UI/LSP) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; Switcher for UI bundles (doom/nano) and LSP backends (eglot/lsp).
  ;;
  ;;; Code:

  (eval-when-compile (require 'subr-x))

  ;; [„Ç≥„Éº„ÉâÂÖ®Êñá„ÅØÊó¢ÊèêÁ§∫„Å©„Åä„Çä„ÄÅÂÆåÂÖ®‰∏ÄËá¥„Åß„Åì„Åì„Å´ÂÖ•„Çä„Åæ„Åô]
#+end_src

*** core/custom.el
:PROPERTIES:
:CUSTOM_ID: custom-file
:header-args:emacs-lisp: :tangle lisp/core/custom.el
:END:

**** Purpose
Centralize Emacs Customize output into a dedicated, non-intrusive file and
provide helper commands to inspect and snapshot selected customization state.

This module isolates Customize side effects from the main configuration.

**** What it does
- Redirects `custom-file` to `.etc/custom.el`
- Ensures the custom file and directory exist
- Loads the custom file safely at startup
- Provides commands to:
  - Open the custom file
  - Dump a curated snapshot of current variables and faces

**** Notes
- Customize output is *not* evaluated inline in init files
- Snapshot dumping is manual and explicit
- This module owns **routing and helpers**, not UI policy

**** Implementation

#+begin_src emacs-lisp
  ;;; core/custom.el --- custom-file helpers -*- lexical-binding: t; -*-
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; - Route customize output to .etc/custom.el
  ;; - Provide helpers to open and (optionally) dump current values/faces.

  (eval-when-compile (require 'subr-x))

  (defconst my:f:custom
    (or (bound-and-true-p my:f:custom)
        (expand-file-name "custom.el"
                          (or (bound-and-true-p my:d:etc)
                              (expand-file-name ".etc" user-emacs-directory))))
    "Path to the custom-file (Customize output).")

  (defun my/custom--ensure-file ()
    "Ensure `custom-file` exists and has a small header."
    (let* ((dir (file-name-directory my:f:custom)))
      (unless (file-directory-p dir)
        (condition-case err
            (make-directory dir t)
          (error
           (warn "[custom] failed to create %s: %s"
                 dir (error-message-string err)))))
      (unless (file-exists-p my:f:custom)
        (with-temp-file my:f:custom
          (insert
           ";;; custom.el --- Customize output -*- lexical-binding: t; -*-\n"
           ";; This file is generated by Customize. Edit with care.\n\n")))))

  ;; Route Customize output
  (setq custom-file my:f:custom)
  (my/custom--ensure-file)

  (when (file-readable-p custom-file)
    (ignore-errors
      (load custom-file nil 'nomessage)))

  ;;;###autoload
  (defun my/custom-open ()
    "Open the `custom-file`."
    (interactive)
    (my/custom--ensure-file)
    (find-file my:f:custom))

  ;;;###autoload
  (defun my/custom-dump-current ()
    "Persist a curated snapshot of current settings/faces into `custom-file`.
  This does not run automatically."
    (interactive)
    (my/custom--ensure-file)

    ;; Variables to persist
    (dolist (pair
             `((inhibit-startup-screen        . ,inhibit-startup-screen)
               (frame-resize-pixelwise        . ,(bound-and-true-p frame-resize-pixelwise))
               (completion-styles             . ,(and (boundp 'completion-styles)
                                                     completion-styles))
               (completion-category-overrides . ,(and (boundp 'completion-category-overrides)
                                                     completion-category-overrides))
               (org-startup-indented           . ,(and (boundp 'org-startup-indented)
                                                     org-startup-indented))
               (org-hide-leading-stars         . ,(and (boundp 'org-hide-leading-stars)
                                                     org-hide-leading-stars))
               (org-tags-column                . ,(and (boundp 'org-tags-column)
                                                     org-tags-column))
               (org-agenda-tags-column         . ,(and (boundp 'org-agenda-tags-column)
                                                     org-agenda-tags-column))))
      (when (car (last pair))
        (customize-save-variable (car pair) (cdr pair))))

    ;; Faces to persist
    (let ((faces
           '((org-modern-date-active
              ((t (:background "#373844" :foreground "#f8f8f2"
                               :height 0.75 :weight light :width condensed))))
             (org-modern-time-active
              ((t (:background "#44475a" :foreground "#f8f8f2"
                               :height 0.75 :weight light :width condensed))))
             (org-modern-tag
              ((t (:background "#44475a" :foreground "#b0b8d1"
                               :height 0.75 :weight light :width condensed)))))))
      (dolist (f faces)
        (custom-set-faces `(,(car f) ,(cadr f)))))

    (custom-save-all)
    (message "[custom] Wrote snapshot to %s" my:f:custom))

  (provide 'core/custom)
  ;;; core/custom.el ends here
#+end_src

*** core/custom-ui-extras.el
:PROPERTIES:
:CUSTOM_ID: core-custom-ui-extras
:header-args:emacs-lisp: :tangle lisp/core/custom-ui-extras.el
:END:

**** Purpose
Allow users to enable optional UI-related modules **without modifying**
the default module list.

This file exists as a safe extension point.

**** What it does
- Appends UI-related modules to `my:modules-extra`
- Avoids duplication
- Leaves default module ordering untouched

**** Notes
- Loaded only when explicitly added
- Intended for personal / experimental UI layers
- Zero side effects outside module selection

**** Implementation

#+begin_src emacs-lisp
  ;;; core/custom-ui-extras.el --- user extras -*- lexical-binding: t; -*-

  ;; Append without touching your default module list.
  (setq my:modules-extra
        (delete-dups
         (append my:modules-extra
                 '(ui/ui-visual-aids
                   orgx/org-typography
                   ui/ui-macos))))

  (provide 'core/custom-ui-extras)
  ;;; core/custom-ui-extras.el ends here
#+end_src

*** ui/ui-font.el
:PROPERTIES:
:CUSTOM_ID: ui-font
:header-args:emacs-lisp: :tangle lisp/ui/ui-font.el
:END:

**** Purpose
Provide a single, OS-aware font configuration entry point for Emacs.

This module defines font *policy* and applies it consistently across frames.

**** What it does
- Selects default monospace and emoji fonts per OS
- Applies font settings on startup and new frames
- Provides commands to inspect current font state
- Optionally enables ligatures in programming modes

**** Notes
- GUI-only behavior is guarded
- Font values can be overridden via variables
- No theme-specific face logic lives here

**** Implementation

#+begin_src emacs-lisp
  ;;; ui/ui-font.el --- Font configuration -*- lexical-binding: t; -*-

  (eval-when-compile (require 'leaf))

  (defun my/system-default-font ()
    "Return a default monospace font family depending on OS."
    (cond ((eq system-type 'darwin)    "Menlo")
          ((eq system-type 'gnu/linux) "Monospace")
          ((eq system-type 'windows-nt) "Consolas")
          (t "Monospace")))

  (defun my/system-emoji-font ()
    "Return a default emoji font family depending on OS."
    (cond ((eq system-type 'darwin)    "Apple Color Emoji")
          ((eq system-type 'gnu/linux) "Noto Color Emoji")
          ((eq system-type 'windows-nt) "Segoe UI Emoji")
          (t "Noto Color Emoji")))

  (defun my/font-setup ()
    "Apply font settings, respecting overrides, and report applied fonts."
    (when (display-graphic-p)
      (set-face-attribute 'default nil
                          :family (or my:font-default (my/system-default-font))
                          :height (* 10 (or my:font-size 18)))
      (set-face-attribute 'variable-pitch nil
                          :family (or my:font-alt (my/system-default-font)))
      (set-fontset-font t 'emoji
                        (font-spec :family
                                   (or my:emoji-font
                                       (my/system-emoji-font))))))

  (defun my/show-current-font ()
    "Echo the current default font family and point size."
    (interactive)
    (let* ((family (face-attribute 'default :family))
           (height (face-attribute 'default :height)))
      (message "Current font: %s, %.1f pt"
               family (/ height 10.0))))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame
                    (my/font-setup))))
    (add-hook 'after-init-hook #'my/font-setup))

  ;; Optional ligatures
  (leaf ligature
    :straight (ligature :type git :host github :repo "mickeynp/ligature.el")
    :when (display-graphic-p)
    :config
    (ligature-set-ligatures
     'prog-mode '("->" "=>" "::" "===" "!=" "&&" "||"))
    (global-ligature-mode 1))

  (provide 'ui/ui-font)
  ;;; ui/ui-font.el ends here
#+end_src

*** ui/ui-nano-palette.el
:PROPERTIES:
:CUSTOM_ID: ui-nano-palette
:header-args:emacs-lisp: :tangle lisp/ui/ui-nano-palette.el
:END:

**** Purpose
Provide a **single source of truth** for a nano-style light color palette
and apply it consistently across Emacs faces.

This module centralizes all literal color values and exposes them as
customizable variables.

**** What it does
- Defines a minimal nano-style palette via `defcustom`
- Applies core UI, syntax, and mode-line faces from the palette
- Provides helper functions to:
  - Apply faces as-is
  - Override a subset of colors and re-apply

**** Notes
- Faces should be applied *after* a theme is enabled
- No theme logic lives here
- Intended to normalize faces across different themes

**** Implementation

#+begin_src emacs-lisp
;;; ui-nano-palette.el --- Nano-style palette -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2026
;; License: GNU GPL v3 or later
;;
;; Category: ui
;;
;; Commentary:
;; One source of truth:
;; - Define the palette once (defcustom ‚Üí easy to tweak via M-x customize)
;; - Apply all faces from a single function
;; - No duplicated literal colors scattered around
;;
;;; Code:

(defgroup my:nano nil
  "Minimal nano-style light palette."
  :group 'faces)

(defcustom nano-color-background "#fafafa"
  "UI background for buffers/panels."
  :type 'string :group 'my:nano)

(defcustom nano-color-foreground "#374151"
  "Default body text color."
  :type 'string :group 'my:nano)

(defcustom nano-color-salient "#2563eb"
  "Accent for links/keywords/standout choices."
  :type 'string :group 'my:nano)

(defcustom nano-color-popout "#6b7280"
  "Neutral notice / muted highlight."
  :type 'string :group 'my:nano)

(defcustom nano-color-critical "#dc2626"
  "Critical error / danger color."
  :type 'string :group 'my:nano)

(defcustom nano-color-strong "#111827"
  "Strong emphasis (headings, key mode-line parts)."
  :type 'string :group 'my:nano)

(defcustom nano-color-faded "#9ca3af"
  "De-emphasized info (comments/secondary/disabled)."
  :type 'string :group 'my:nano)

(defcustom nano-color-subtle "#e5e7eb"
  "Subtle backgrounds (mode/header lines, gentle selections)."
  :type 'string :group 'my:nano)

(defun my/nano-apply-faces ()
  "Apply faces based on the nano-style palette defined above."
  (set-face-attribute 'default nil
                      :background nano-color-background
                      :foreground nano-color-foreground)
  (set-face-attribute 'bold nil :foreground nano-color-strong :weight 'bold)
  (set-face-attribute 'italic nil :slant 'italic)

  (set-face-attribute 'font-lock-comment-face nil :foreground nano-color-faded)
  (set-face-attribute 'font-lock-keyword-face nil
                      :foreground nano-color-salient :weight 'semi-bold)
  (set-face-attribute 'font-lock-string-face nil :foreground nano-color-popout)
  (set-face-attribute 'font-lock-warning-face nil
                      :foreground nano-color-popout :weight 'bold)

  (set-face-attribute 'link nil :foreground nano-color-salient :underline t)
  (set-face-attribute 'button nil :foreground nano-color-salient :underline t)

  (set-face-attribute 'error nil
                      :foreground nano-color-critical :weight 'bold)
  (set-face-attribute 'warning nil
                      :foreground nano-color-popout :weight 'bold)
  (set-face-attribute 'success nil :foreground "#10b981")

  (set-face-attribute 'region nil :background nano-color-subtle)

  (let ((ml-bg nano-color-subtle)
        (ml-fg nano-color-strong))
    (set-face-attribute 'mode-line nil
                        :background ml-bg :foreground ml-fg
                        :box `(:line-width 1 :color ,ml-bg))
    (set-face-attribute 'mode-line-inactive nil
                        :background nano-color-background
                        :foreground nano-color-faded
                        :box `(:line-width 1 :color ,nano-color-background)))

  (set-face-attribute 'minibuffer-prompt nil
                      :foreground nano-color-salient :weight 'semi-bold))

(defun my/nano-set-palette-and-apply (&rest plist)
  "Override palette entries via PLIST and apply faces."
  (when plist
    (let ((map '((:background . nano-color-background)
                 (:foreground . nano-color-foreground)
                 (:salient    . nano-color-salient)
                 (:popout     . nano-color-popout)
                 (:critical   . nano-color-critical)
                 (:strong     . nano-color-strong)
                 (:faded      . nano-color-faded)
                 (:subtle     . nano-color-subtle))))
      (while plist
        (let* ((k (pop plist))
               (v (pop plist))
               (sym (cdr (assq k map))))
          (when sym (set sym v))))))
  (my/nano-apply-faces))

(provide 'ui/ui-nano-palette)
;;; ui/ui-nano-palette.el ends here
#+end_src

*** ui/ui-theme.el
:PROPERTIES:
:CUSTOM_ID: ui-theme
:header-args:emacs-lisp: :tangle lisp/ui/ui-theme.el
:END:

**** Purpose
Define the **theme orchestration layer** for the UI.

This module wires together nano-emacs, nano-theme, spacing, and the
nano palette to produce a consistent visual system.

**** What it does
- Loads the nano palette as the color authority
- Enables nano-emacs and nano-theme
- Re-applies palette-based face normalization after theme changes
- Adds subtle GUI padding

**** Notes
- Face normalization always runs *after* theme activation
- Palette logic lives in `ui-nano-palette.el`
- Safe across Emacs 29+ theme APIs

**** Implementation

#+begin_src emacs-lisp
;;; ui/ui-theme.el --- Theme configuration -*- lexical-binding: t; -*-
;;
;; Category: ui
;;
(eval-when-compile (require 'leaf))

(require 'ui/ui-nano-palette)

(setq-default line-spacing 0.24)

(defun my/nano--reapply-after-theme (&rest _)
  "Re-apply nano-style face normalization after a theme change."
  (when (fboundp 'my/nano-apply-faces)
    (my/nano-apply-faces)))

(with-eval-after-load 'cus-theme
  (if (boundp 'enable-theme-functions)
      (add-hook 'enable-theme-functions #'my/nano--reapply-after-theme)
    (advice-add 'enable-theme :after #'my/nano--reapply-after-theme)))

(leaf nano-emacs
  :straight (nano-emacs :type git :host github :repo "rougier/nano-emacs")
  :config
  (require 'nano-layout)
  (require 'nano-faces)
  (nano-faces)

  (set-face-attribute 'nano-face-strong nil
                      :foreground (face-foreground 'nano-face-default)
                      :weight 'bold)

  (leaf nano-theme
    :straight (nano-theme :type git :host github :repo "rougier/nano-theme")
    :config
    (load-theme 'nano t)
    (my/nano-apply-faces)

    (set-face-attribute 'bold nil :weight 'bold)
    (set-face-attribute 'italic nil :slant 'italic)
    (with-eval-after-load 'elec-pair
      (custom-set-faces
       '(electric-pair-overlay-face ((t (:background "#e5e7eb"))))
       '(show-paren-match ((t (:background "#e5e7eb"
                                           :foreground "#111827"
                                           :weight bold))))
       '(show-paren-mismatch ((t (:background "#dc2626"
                                              :foreground "white"
                                              :weight bold))))))))

(leaf spacious-padding
  :straight t
  :if (display-graphic-p)
  :custom
  ((spacious-padding-widths . '((left . 15) (right . 15)))
   (spacious-padding-subtle-mode-line . t))
  :config
  (spacious-padding-mode 1)
  (my/nano-apply-faces))

(provide 'ui/ui-theme)
;;; ui/ui-theme.el ends here
#+end_src

*** ui/ui-doom-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-doom-modeline
:header-args:emacs-lisp: :tangle lisp/ui/ui-doom-modeline.el
:END:

**** Purpose
Provide an alternative **Doom-style modeline bundle**.

**** What it does
- Enables doom-modeline with Nerd Icons
- Configures a compact, informative modeline
- Exposes an interactive command to enable it

**** Notes
- Mutually exclusive with nano-modeline
- Purely UI; no session state logic

**** Implementation

#+begin_src emacs-lisp
;;; ui-doom-modeline.el --- Doom UI bundle entry -*- lexical-binding: t; -*-
;;
;; Category: ui
;;
(eval-when-compile (require 'leaf))
(declare-function doom-modeline-mode "doom-modeline")

(leaf nerd-icons :straight t)

(leaf doom-modeline
  :straight t
  :custom ((doom-modeline-height . 28)
           (doom-modeline-buffer-file-name-style
            . 'truncate-with-project)
           (doom-modeline-minor-modes . nil)
           (doom-modeline-enable-word-count . t))
  :config
  (doom-modeline-mode 1))

;;;###autoload
(defun my/ui-enable-doom ()
  "Enable Doom UI modeline bundle."
  (interactive)
  (doom-modeline-mode 1)
  (message "[ui] Doom modeline enabled."))

(provide 'ui/ui-doom-modeline)
;;; ui/ui-doom-modeline.el ends here
#+end_src

*** ui/ui-nano-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-nano-modeline
:header-args:emacs-lisp: :tangle lisp/ui/ui-nano-modeline.el
:END:

**** Purpose
Provide a **robust, guarded loader** for nano-modeline.

**** What it does
- Lazily enables nano-modeline when available
- Installs hooks for many major modes
- Guarantees idempotent initialization

**** Notes
- Safe even if nano-modeline is not installed
- Designed for long-running sessions

**** Implementation

#+begin_src emacs-lisp
;;; ui-nano-modeline.el --- Nano UI bundle entry -*- lexical-binding: t; -*-
;;
;; Category: ui
;;
(eval-when-compile (require 'leaf))

(defvar ui--nano-modeline-initialized nil)

(defun my/ui--nano-available-p ()
  (require 'nano-modeline nil 'noerror))

(defun my/ui--nano-setup ()
  (when (and (not ui--nano-modeline-initialized)
             (my/ui--nano-available-p))
    (setopt nano-modeline-padding '(0.20 . 0.25))
    (add-hook 'prog-mode-hook #'nano-modeline-prog-mode)
    (add-hook 'text-mode-hook #'nano-modeline-text-mode)
    (setq ui--nano-modeline-initialized t)
    (message "[ui] nano-modeline initialized.")))

(leaf nano-modeline
  :straight (nano-modeline :type git :host github :repo "rougier/nano-modeline")
  :after nano-emacs
  :require nil
  :init
  (add-hook 'after-init-hook #'my/ui--nano-setup))

;;;###autoload
(defun my/ui-enable-nano ()
  "Enable Nano UI modeline bundle."
  (interactive)
  (my/ui--nano-setup))

(provide 'ui/ui-nano-modeline)
;;; ui/ui-nano-modeline.el ends here
#+end_src

*** ui/ui-health-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-health-modeline
:header-args:emacs-lisp: :tangle lisp/ui/ui-health-modeline.el
:END:

**** Purpose
Provide **lightweight, read-only visibility** into Emacs session health
via the global mode-line.

**** What it does
- Displays the number of live buffers
- Displays the number of running processes
- Optionally displays active Eglot workspace count
- Reacts to buffer, process, and Eglot lifecycle events

**** Notes
- This module is **UI-only**
- It must not trigger GC, cleanup, or lifecycle actions
- All policy decisions belong to `core/core-session.el`

**** Implementation

#+begin_src emacs-lisp
;;; ui-health-modeline.el --- Session health indicators -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2026
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;
;; Category: ui
;;
;;; Commentary:
;; Mode-line indicators for Emacs session health.
;;
;;; Code:

(eval-when-compile
  (require 'leaf)
  (require 'subr-x))

(defgroup ui-health-modeline nil
  "Mode-line indicators for session health."
  :group 'mode-line)

(defcustom ui-health-show-buffers-p t
  "Show buffer count in the mode-line."
  :type 'boolean
  :group 'ui-health-modeline)

(defcustom ui-health-show-processes-p t
  "Show process count in the mode-line."
  :type 'boolean
  :group 'ui-health-modeline)

(defcustom ui-health-show-eglot-p t
  "Show Eglot workspace count in the mode-line when available."
  :type 'boolean
  :group 'ui-health-modeline)

(defvar ui-health--mode-line-string ""
  "Mode-line string representing current session health.")

(defun ui-health--buffers-count ()
  "Return the number of live buffers."
  (length (buffer-list)))

(defun ui-health--processes-count ()
  "Return the number of live processes."
  (length (process-list)))

(defun ui-health--eglot-count ()
  "Return the number of active Eglot workspaces, or nil."
  (when (and ui-health-show-eglot-p
             (featurep 'eglot)
             (boundp 'eglot--managed-buffers))
    (length eglot--managed-buffers)))

(defun ui-health--update ()
  "Update `ui-health--mode-line-string`."
  (setq ui-health--mode-line-string
        (concat
         (when ui-health-show-buffers-p
           (format " B:%d" (ui-health--buffers-count)))
         (when ui-health-show-processes-p
           (format " P:%d" (ui-health--processes-count)))
         (when-let ((n (ui-health--eglot-count)))
           (format " LSP:%d" n))))
  (force-mode-line-update))

(add-hook 'buffer-list-update-hook #'ui-health--update)
(add-hook 'process-status-change-hook #'ui-health--update)

(with-eval-after-load 'eglot
  (add-hook 'eglot-managed-mode-hook #'ui-health--update)
  (add-hook 'eglot-server-stopped-hook #'ui-health--update))

(unless (member 'ui-health--mode-line-string global-mode-string)
  (setq global-mode-string
        (append global-mode-string '(ui-health--mode-line-string))))

(ui-health--update)

(provide 'ui/ui-health-modeline)
;;; ui/ui-health-modeline.el ends here
#+end_src

*** ui/ui-window.el
:PROPERTIES:
:CUSTOM_ID: ui-window
:header-args:emacs-lisp: :tangle lisp/ui/ui-window.el
:END:

**** Purpose
Provide **window and layout management utilities** for daily use.

**** What it does
- Automatically resizes windows using `zoom-mode`
- Persists window layouts via `desktop.el`
- Enables undo/redo for window configurations
- Provides simple commands to save and restore layouts

**** Notes
- Desktop data is stored under `no-littering` directories
- Layout save/restore is manual and explicit

**** Implementation

#+begin_src emacs-lisp
;;; ui/ui-window.el --- Window management -*- lexical-binding: t; -*-
;;
;; Category: ui
;;
(eval-when-compile (require 'leaf))

(leaf zoom
  :straight t
  :hook (after-init-hook . zoom-mode)
  :custom
  ((zoom-size . '(0.62 . 0.62))
   (zoom-ignored-major-modes . '(dired-mode treemacs-mode))
   (zoom-ignored-buffer-names . '("*Messages*" "*Help*"))))

(leaf desktop
  :straight nil
  :config
  (let ((dir (concat no-littering-var-directory "desktop/")))
    (setq desktop-dirname dir
          desktop-path (list dir)
          desktop-base-file-name "desktop"
          desktop-base-lock-name "lock"
          desktop-restore-eager 10
          desktop-save t
          desktop-load-locked-desktop nil
          desktop-auto-save-timeout 300)
    (my/ensure-directory-exists dir)
    (desktop-save-mode 1)))

(leaf winner
  :straight nil
  :global-minor-mode t)

(defvar my:saved-window-config nil
  "Saved window configuration state.")

(defun my/save-window-layout ()
  "Save current window layout."
  (interactive)
  (setq my:saved-window-config (window-state-get nil t))
  (message "Window configuration saved."))

(defun my/restore-window-layout ()
  "Restore last saved window layout."
  (interactive)
  (if my:saved-window-config
      (window-state-put my:saved-window-config)
    (message "No saved window configuration found.")))

(provide 'ui/ui-window)
;;; ui/ui-window.el ends here
#+end_src

*** ui/ui-utils.el
:PROPERTIES:
:CUSTOM_ID: ui-utils
:header-args:emacs-lisp: :tangle lisp/ui/ui-utils.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-utils.el --- Treemacs configuration & UI utils -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;;; Code:

  (leaf minions :straight t
    :custom ((minions-mode-line-lighter . "‚öô"))
    :hook (after-init-hook . minions-mode))

  (setq display-time-interval 30
        display-time-day-and-date t
        display-time-24hr-format t)
  (display-time-mode 1)
  (when (fboundp 'display-battery-mode) (display-battery-mode 1))

  (leaf treemacs :straight t
    :if (display-graphic-p)
    :custom ((treemacs-filewatch-mode . t)
             (treemacs-follow-mode . t)
             (treemacs-indentation . 2)
             (treemacs-missing-project-action . 'remove)))

  (leaf nerd-icons-dired :straight t
    :hook (dired-mode . nerd-icons-dired-mode))

  (leaf pbcopy
    :if (memq window-system '(mac ns))
    :straight t
    :config (turn-on-pbcopy))

  (provide 'ui/ui-utils)
  ;;; ui/ui-utils.el ends here
#+end_src

*** ui/ui-visual-aids.el
:PROPERTIES:
:CUSTOM_ID: ui-visual-aids
:header-args:emacs-lisp: :tangle lisp/ui/ui-visual-aids.el
:END:

**** Purpose
Add **subtle, non-intrusive visual aids** that improve readability and
orientation without clutter.

**** What it does
- Pulses the cursor after navigation jumps
- Highlights TODO/FIXME-style annotations
- Adds rainbow delimiters in programming modes
- Displays lightweight indentation guides

**** Notes
- Avoids Tree-sitter or heavy overlays
- Designed to coexist with existing UI features

**** Implementation

#+begin_src emacs-lisp
;;; ui/ui-visual-aids.el --- Subtle visual helpers -*- lexical-binding: t; -*-
;;
;; Category: ui
;;
(eval-when-compile (require 'leaf))

(leaf pulsar
  :straight t
  :init
  (setq pulsar-delay 0.04
        pulsar-pulse t
        pulsar-face 'pulsar-generic)
  :config
  (pulsar-global-mode 1)
  (dolist (cmd '(recenter-top-bottom
                 other-window
                 next-buffer
                 previous-buffer))
    (add-to-list 'pulsar-pulse-functions cmd)))

(leaf hl-todo
  :straight t
  :hook ((prog-mode-hook text-mode-hook) . hl-todo-mode)
  :init
  (setq hl-todo-keyword-faces
        '(("TODO" . "#d97706")
          ("FIXME" . "#dc2626")
          ("NOTE" . "#2563eb")
          ("HACK" . "#9333ea"))))

(leaf rainbow-delimiters
  :straight t
  :hook (prog-mode-hook . rainbow-delimiters-mode))

(leaf indent-bars
  :straight t
  :hook (prog-mode-hook . indent-bars-mode)
  :init
  (setq indent-bars-prefer-character t
        indent-bars-spacing-override 2))

(provide 'ui/ui-visual-aids)
;;; ui/ui-visual-aids.el ends here
#+end_src

*** ui/ui-macos.el
:PROPERTIES:
:CUSTOM_ID: ui-macos
:header-args:emacs-lisp: :tangle lisp/ui/ui-macos.el
:END:

**** Purpose
Provide **macOS-specific UI niceties**.

**** What it does
- Enables transparent title bars
- Uses native title bars where supported

**** Notes
- Guarded by `system-type`
- No effect on non-macOS platforms

**** Implementation

#+begin_src emacs-lisp
;;; ui/ui-macos.el --- macOS niceties -*- lexical-binding: t; -*-
;;
;; Category: ui
;;
(eval-when-compile (require 'leaf))

(when (eq system-type 'darwin)
  (add-to-list 'default-frame-alist
               '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist
               '(use-title-bar . t)))

(provide 'ui/ui-macos)
;;; ui/ui-macos.el ends here
#+end_src

*** completion/completion-core.el
:PROPERTIES:
:CUSTOM_ID: completion-core
:header-args:emacs-lisp: :tangle lisp/completion/completion-core.el
:END:

**** Purpose
Define the **global completion matching policy** used throughout Emacs.

This module establishes the default completion styles and category-specific
overrides that are shared by minibuffer completion, in-buffer completion,
and higher-level completion UIs.

**** What it does
- Enables `orderless` as the primary completion style
- Keeps `basic` completion as a fallback
- Customizes completion behavior per category:
  - Files use partial completion
  - Symbols and commands use orderless matching
- Acts as the foundation for all other completion modules

**** Notes
- This module does **not** enable any UI
- No Corfu / Vertico / Consult logic lives here
- Category overrides can be further refined by context-specific modules
  (e.g. Org SRC overrides)

**** Implementation

#+begin_src emacs-lisp
;;; completion-core.el --- Completion core settings -*- lexical-binding: t; -*-
;;
;; Category: completion
;;
(eval-when-compile (require 'leaf))

(leaf orderless
  :straight t
  :custom
  ((completion-styles . '(orderless basic))
   (completion-category-overrides
    . '((file    (styles . (partial-completion)))
        (symbol  (styles . (orderless)))
        (command (styles . (orderless)))))))

(provide 'completion/completion-core)
#+end_src

*** completion/completion-vertico.el
:PROPERTIES:
:CUSTOM_ID: completion-vertico
:header-args:emacs-lisp: :tangle lisp/completion/completion-vertico.el
:END:

**** Purpose
Provide a **minimal and fast minibuffer completion UI** based on Vertico.

This module focuses exclusively on minibuffer interaction and does not
affect in-buffer completion.

**** What it does
- Enables `vertico-mode` globally
- Limits the number of visible candidates for clarity
- Uses `vertico-posframe` in GUI sessions for a floating minibuffer
- Enables `marginalia` to enrich candidates with annotations

**** Notes
- Posframe support is enabled only in graphical sessions
- Candidate annotation is delegated to `marginalia`
- Styling and icons are handled in separate modules

**** Implementation

#+begin_src emacs-lisp
;;; completion-vertico.el --- Vertico minibuffer UI -*- lexical-binding: t; -*-
;;
;; Category: completion
;;
(eval-when-compile (require 'leaf))

(leaf vertico
  :straight t
  :global-minor-mode vertico-mode
  :custom ((vertico-count . 15)))

(leaf vertico-posframe
  :straight t
  :if (display-graphic-p)
  :after vertico
  :custom ((vertico-posframe-border-width . 2))
  :config
  (vertico-posframe-mode 1))

(leaf marginalia
  :straight t
  :global-minor-mode marginalia-mode)

(provide 'completion/completion-vertico)
#+end_src

*** completion/completion-consult.el
:PROPERTIES:
:CUSTOM_ID: completion-consult
:header-args:emacs-lisp: :tangle lisp/completion/completion-consult.el
:END:

**** Purpose
Integrate `consult` as the primary **search, navigation, and narrowing**
backend.

This module enhances standard Emacs commands with previewable,
incremental narrowing.

**** What it does
- Installs `consult`
- Routes Xref lookups through Consult for a unified UI
- Provides consistent navigation across projects and buffers

**** Notes
- This module does not define keybindings
- Integration with Embark is handled separately
- Preview behavior depends on the active UI (Vertico / Corfu)

**** Implementation

#+begin_src emacs-lisp
;;; completion-consult.el --- Consult search/navigation -*- lexical-binding: t; -*-
;;
;; Category: completion
;;
(eval-when-compile (require 'leaf))

(leaf consult
  :straight t
  :custom
  ((xref-show-xrefs-function        . #'consult-xref)
   (xref-show-definitions-function . #'consult-xref)))

(provide 'completion/completion-consult)
#+end_src

*** completion/completion-embark.el
:PROPERTIES:
:CUSTOM_ID: completion-embark
:header-args:emacs-lisp: :tangle lisp/completion/completion-embark.el
:END:

**** Purpose
Enable **context-aware actions** on completion candidates via Embark.

This module allows users to act on candidates without leaving the
completion context.

**** What it does
- Enables `embark` as the prefix help system
- Integrates Embark with Consult for live previews
- Adds action menus for files, buffers, symbols, and more

**** Notes
- Actions are discovered dynamically
- UI and keybindings are intentionally minimal
- Embark does not alter completion sources or styles

**** Implementation

#+begin_src emacs-lisp
;;; completion-embark.el --- Embark actions -*- lexical-binding: t; -*-
;;
;; Category: completion
;;
(eval-when-compile (require 'leaf))

(leaf embark
  :straight t
  :custom ((prefix-help-command . #'embark-prefix-help-command)))

(leaf embark-consult
  :straight t
  :after (embark consult)
  :hook (embark-collect-mode . consult-preview-at-point-mode))

(provide 'completion/completion-embark)
#+end_src

*** completion/completion-corfu.el
:PROPERTIES:
:CUSTOM_ID: completion-corfu
:header-args:emacs-lisp: :tangle lisp/completion/completion-corfu.el
:END:

**** Purpose
Provide **in-buffer popup completion** using Corfu.

This module defines the default Corfu behavior and integrates Cape-based
completion sources.

**** What it does
- Enables `global-corfu-mode`
- Uses TAB for completion and indentation
- Enables automatic popup completion
- Integrates `kind-icon` for visual annotations
- Registers common Cape CAPFs globally

**** Notes
- Context-specific overrides (Org SRC, REPLs) are defined elsewhere
- CAPF ordering matters and is refined by other modules
- Corfu UI behavior is adjusted buffer-locally when needed

**** Implementation

#+begin_src emacs-lisp
;;; completion/completion-corfu.el --- Corfu popup completion module -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2026
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;
;; Category: completion
;;
;;; Commentary:
;; Corfu-based in-buffer completion with sensible defaults.
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf corfu
  :straight t
  :init
  (setq tab-always-indent 'complete)
  (global-corfu-mode)
  :custom
  ((corfu-auto  . t)
   (corfu-cycle . t)))

(leaf kind-icon
  :straight t
  :after corfu
  :require t
  :custom ((kind-icon-default-face . 'corfu-default))
  :config
  (add-to-list 'corfu-margin-formatters
               #'kind-icon-margin-formatter))

(leaf cape
  :straight t
  :after corfu
  :init
  (add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev))

(provide 'completion/completion-corfu)
;;; completion/completion-corfu.el ends here
#+end_src

*** completion/completion-icons.el
:PROPERTIES:
:CUSTOM_ID: completion-icons
:header-args:emacs-lisp: :tangle lisp/completion/completion-icons.el
:END:

**** Purpose
Add **icon-based visual cues** to completion and buffer lists.

This module improves recognizability without changing completion logic.

**** What it does
- Adds Nerd Font icons to `ibuffer`
- Adds icons to Marginalia annotations
- Aligns Marginalia annotations to the right

**** Notes
- Requires Nerd Fonts to be installed
- Purely cosmetic; safe to disable
- Depends on Marginalia being enabled

**** Implementation

#+begin_src emacs-lisp
;;; completion-icons.el --- Nerd icons for completion -*- lexical-binding: t; -*-
;;
;; Category: completion
;;
(eval-when-compile (require 'leaf))

(leaf nerd-icons-ibuffer
  :straight t
  :hook (ibuffer-mode-hook . nerd-icons-ibuffer-mode))

(leaf nerd-icons-completion
  :straight t
  :hook (marginalia-mode-hook
         . nerd-icons-completion-marginalia-setup)
  :config
  (nerd-icons-completion-mode))

(setq marginalia-align 'right)

(provide 'completion/completion-icons)
#+end_src

*** completion/completion-capf.el
:PROPERTIES:
:CUSTOM_ID: completion-capf
:header-args:emacs-lisp: :tangle lisp/completion/completion-capf.el
:END:

**** Purpose
Provide a clear and predictable completion strategy by selecting
`completion-at-point-functions` (CAPFs) per major mode and defining
semantic completion behavior via `completion-category-overrides`.

This module separates *what to complete* (CAPFs) from *how to display*
(Corfu), ensuring stable behavior across programming, text, Org, shell,
and REPL buffers.

**** What it does
- Sets `completion-at-point-functions` **buffer-locally** per major mode
- Uses only **existing and stable Cape CAPFs**
- Keeps LSP / Eglot CAPFs intact in `prog-mode`
- Adds specialized presets for:
  - Emacs Lisp
  - Programming modes
  - Text modes
  - Org mode
  - Shell / Eshell
  - REPL buffers (IELM / comint)
- Defines `completion-category-overrides` to control matching styles
  by semantic category (file, symbol, keyword, etc.)

**** Notes
- This module intentionally avoids global mutation of CAPFs
- Corfu is treated purely as a UI layer
- Category overrides belong to the completion layer, not the UI
- Safe to load early; relies only on standard completion APIs and Cape

**** Implementation

#+begin_src emacs-lisp
  ;;; completion/capf.el --- Mode-specific CAPF & category configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Configure `completion-at-point-functions` per major mode and
  ;; `completion-category-overrides` for Corfu + Cape.
  ;; Category: completion
  ;;;
  ;;; Code:

  ;;;; Utilities

  (defun completion--set-capfs (capfs)
    "Set buffer-local CAPFs to CAPFS."
    (setq-local completion-at-point-functions capfs))

  ;;;; CAPF presets by mode

  (defun completion--elisp-capfs ()
    "CAPFs for Emacs Lisp buffers."
    (completion--set-capfs
     '(cape-elisp-symbol
       cape-file
       cape-dabbrev)))

  (defun completion--prog-capfs ()
    "CAPFs for programming modes (LSP-friendly)."
    (completion--set-capfs
     (append completion-at-point-functions
             '(cape-file
               cape-dabbrev))))

  (defun completion--text-capfs ()
    "CAPFs for generic text buffers."
    (completion--set-capfs
     '(cape-dabbrev
       cape-file)))

  (defun completion--org-capfs ()
    "CAPFs specialized for Org buffers."
    (completion--set-capfs
     '(cape-dabbrev
       cape-file
       cape-tex)))

  (defun completion--shell-capfs ()
    "CAPFs for shell and eshell buffers."
    (completion--set-capfs
     '(cape-file
       cape-dabbrev)))

  (defun completion--repl-capfs ()
    "CAPFs for REPL-like buffers (IELM, comint)."
    (completion--set-capfs
     (append completion-at-point-functions
             '(cape-dabbrev))))

  ;;;; Hooks

  (add-hook 'emacs-lisp-mode-hook #'completion--elisp-capfs)
  (add-hook 'lisp-interaction-mode-hook #'completion--elisp-capfs)

  (add-hook 'prog-mode-hook #'completion--prog-capfs)
  (add-hook 'text-mode-hook #'completion--text-capfs)

  (add-hook 'org-mode-hook #'completion--org-capfs)

  (add-hook 'sh-mode-hook #'completion--shell-capfs)
  (add-hook 'eshell-mode-hook #'completion--shell-capfs)

  (add-hook 'ielm-mode-hook #'completion--repl-capfs)
  (add-hook 'comint-mode-hook #'completion--repl-capfs)

  ;;;; completion-category-overrides

  (setq completion-category-overrides
        '((file (styles basic partial-completion))
          (symbol (styles orderless))
          (keyword (styles orderless))
          (tex (styles basic))
          (dabbrev (styles basic))))


  (provide 'completion/completion-capf)
  ;;; completion/capf.el ends here
#+end_src

*** completion/completion-capf-org-src.el
:PROPERTIES:
:CUSTOM_ID: completion-capf-org-src
:header-args:emacs-lisp: :tangle lisp/completion/completion-capf-org-src.el
:END:

**** Purpose
Provide context-aware completion inside Org buffers by dynamically
switching `completion-at-point-functions` when entering and leaving
Org Babel source edit buffers.

This ensures that:
- Org text uses text-oriented CAPFs
- Source blocks use language-appropriate CAPFs
- Completion behavior remains predictable and non-intrusive

**** What it does
- Applies Org-specific CAPFs in normal Org buffers
- Detects entry into Org SRC edit buffers (`org-src-mode`)
- Delegates CAPF selection to the major mode of the SRC buffer
- Falls back safely for unknown or unsupported languages

**** Notes
- Uses `org-src-mode-hook`, which runs in the *edit buffer*
- Does not advise or override Org internals
- Respects existing CAPF logic defined in `completion/capf.el`
- No effect outside Org buffers

**** Implementation

#+begin_src emacs-lisp
  ;;; completion/completion-capf-org-src.el --- CAPF switching for Org SRC blocks -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Switch completion-at-point-functions automatically when entering
  ;; Org Babel source edit buffers.
  ;; Category: completion
  ;;;
  ;;; Code:

  (defun completion--org-src-capfs ()
    "Apply appropriate CAPFs inside Org SRC edit buffers.

  This function runs in `org-src-mode` buffers and selects CAPFs
  based on the detected major mode of the source block."
    (cond
     ;; Emacs Lisp blocks
     ((derived-mode-p 'emacs-lisp-mode)
      (completion--elisp-capfs))

     ;; Programming language blocks
     ((derived-mode-p 'prog-mode)
      (completion--prog-capfs))

     ;; Fallback for text-like blocks
     (t
      (completion--text-capfs))))

  (add-hook 'org-src-mode-hook #'completion--org-src-capfs)

  (provide 'completion/completion-capf-org-src)
  ;;; completion/completion-capf-org-src.el ends here
#+end_src

*** completion/completion-capf-org-src-lang.el
:PROPERTIES:
:CUSTOM_ID: completion-capf-org-src-lang
:header-args:emacs-lisp: :tangle lisp/completion/completion-capf-org-src-lang.el
:END:

**** Purpose
Provide language-specific completion behavior inside Org Babel SRC edit
buffers by selecting appropriate CAPFs for each language.

This refines the generic Org SRC CAPF switching by applying tailored
completion strategies for shell, SQL, and Python source blocks.

**** What it does
- Detects the major mode of the Org SRC edit buffer
- Applies language-specific CAPF presets:
  - Shell / Eshell
  - SQL
  - Python
- Falls back to generic Org SRC CAPFs when no language match is found
- Does not affect non-Org buffers

**** Notes
- This module runs only inside `org-src-mode` buffers
- It extends (not replaces) `completion-capf-org-src`
- Language detection relies on `derived-mode-p`
- Safe to extend with additional languages

**** Implementation

#+begin_src emacs-lisp
  ;;; completion/completion-capf-org-src-lang.el --- Language-specific CAPFs for Org SRC -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Apply language-specific CAPF presets inside Org Babel SRC edit buffers.
  ;; Category: completion
  ;;;
  ;;; Code:

  (defun completion--org-src-shell-capfs ()
    "CAPFs for shell-like Org SRC blocks."
    (completion--set-capfs
     '(cape-file
       cape-dabbrev)))

  (defun completion--org-src-sql-capfs ()
    "CAPFs for SQL Org SRC blocks."
    (completion--set-capfs
     '(cape-dabbrev
       cape-file)))

  (defun completion--org-src-python-capfs ()
    "CAPFs for Python Org SRC blocks."
    (completion--set-capfs
     (append completion-at-point-functions
             '(cape-file
               cape-dabbrev))))

  (defun completion--org-src-lang-capfs ()
    "Dispatch language-specific CAPFs for Org SRC edit buffers."
    (cond
     ;; Shell blocks
     ((derived-mode-p 'sh-mode 'shell-mode 'eshell-mode)
      (completion--org-src-shell-capfs))

     ;; SQL blocks
     ((derived-mode-p 'sql-mode)
      (completion--org-src-sql-capfs))

     ;; Python blocks
     ((derived-mode-p 'python-mode)
      (completion--org-src-python-capfs))

     ;; Fallback: keep CAPFs set by completion-capf-org-src
     (t nil)))

  (add-hook 'org-src-mode-hook #'completion--org-src-lang-capfs)

  (provide 'completion/completion-capf-org-src-lang)
  ;;; completion/completion-capf-org-src-lang.el ends here
#+end_src

*** completion/completion-corfu-org-src.el
:PROPERTIES:
:CUSTOM_ID: completion-corfu-org-src
:header-args:emacs-lisp: :tangle lisp/completion/completion-corfu-org-src.el
:END:

**** Purpose
Adjust Corfu popup behavior exclusively inside Org Babel SRC edit buffers
to better suit short-lived, context-focused code editing.

This avoids global UI changes while improving usability when editing
embedded source blocks.

**** What it does
- Enables Corfu auto completion only inside Org SRC buffers
- Reduces popup delay for faster feedback
- Disables cycling to avoid accidental selection
- Uses buffer-local overrides only
- Restores global Corfu behavior automatically when exiting SRC buffers

**** Notes
- Applies only to `org-src-mode` buffers
- Does not modify global Corfu configuration
- Safe with Corfu global mode enabled
- No advice or internal Corfu hooks used

**** Implementation

#+begin_src emacs-lisp
  ;;; completion/completion-corfu-org-src.el --- Corfu UI tweaks for Org SRC -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Adjust Corfu popup behavior specifically for Org Babel SRC edit buffers.
  ;; Category: completion
  ;;;
  ;;; Code:

  (defun completion--org-src-corfu-setup ()
    "Apply buffer-local Corfu settings for Org SRC edit buffers."
    (setq-local corfu-auto t)
    (setq-local corfu-auto-delay 0.1)
    (setq-local corfu-auto-prefix 1)
    (setq-local corfu-cycle nil))

  (add-hook 'org-src-mode-hook #'completion--org-src-corfu-setup)

  (provide 'completion/completion-corfu-org-src)
  ;;; completion/completion-corfu-org-src.el ends here
#+end_src

*** completion/completion-orderless-org-src.el
:PROPERTIES:
:CUSTOM_ID: completion-orderless-org-src
:header-args:emacs-lisp: :tangle lisp/completion/completion-orderless-org-src.el
:END:

**** Purpose
Adjust `orderless` matching styles exclusively inside Org Babel SRC edit
buffers to provide more permissive and code-friendly completion behavior.

This allows aggressive symbol matching in source blocks while keeping
stricter or simpler styles in normal buffers.

**** What it does
- Applies buffer-local `completion-category-overrides` in Org SRC buffers
- Uses `orderless` for symbol- and keyword-like categories
- Keeps file and dabbrev completion conservative
- Leaves global completion styles untouched
- Automatically resets when leaving the SRC edit buffer

**** Notes
- Applied only in `org-src-mode` buffers
- Implemented via buffer-local variable binding
- No advice, no global mutation
- Designed to work with Corfu + Cape presets

**** Implementation

#+begin_src emacs-lisp
  ;;; completion/completion-orderless-org-src.el --- Orderless style tweaks for Org SRC -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Override completion-category-overrides buffer-locally
  ;; for Org Babel SRC edit buffers.
  ;; Category: completion
  ;;;
  ;;; Code:

  (defun completion--org-src-orderless-setup ()
    "Apply Org SRC-specific completion category overrides.

  Use more permissive orderless matching for code-oriented categories
  inside Org Babel source edit buffers."
    (setq-local completion-category-overrides
                '((symbol  (styles orderless))
                  (keyword (styles orderless))
                  (function (styles orderless))
                  (variable (styles orderless))
                  (file     (styles basic partial-completion))
                  (dabbrev  (styles basic)))))

  (add-hook 'org-src-mode-hook #'completion--org-src-orderless-setup)

  (provide 'completion/completion-orderless-org-src)
  ;;; completion/completion-orderless-org-src.el ends here
#+end_src

*** orgx/org-core.el
:PROPERTIES:
:CUSTOM_ID: orgx-core
:header-args:emacs-lisp: :tangle lisp/orgx/org-core.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-core.el --- Org Mode core configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'cl-lib))

  (defvar my:d:org (expand-file-name "org" my:d:var))
  (defvar my:d:org-journal (expand-file-name "journal" my:d:org))
  (defvar my:d:org-roam (expand-file-name "org-roam" my:d:org))
  (defvar my:d:org-pictures (expand-file-name "pictures" my:d:org))
  (defvar my:f:capture-blog-file (expand-file-name "blog.org" my:d:org))

  (my/ensure-directory-exists my:d:org)
  (my/ensure-directory-exists my:d:org-journal)
  (my/ensure-directory-exists my:d:org-roam)
  (my/ensure-directory-exists my:d:org-pictures)

  (defun my/org-buffer-files ()
    "Return a list of *.org files currently visited in live buffers."
    (cl-loop for buf in (buffer-list)
             for file = (buffer-file-name buf)
             when (and file (string-match-p "\\.org\\'" file))
             collect file))

  (leaf org
    :straight nil
    :custom
    ((org-directory . my:d:org)
     (org-default-notes-file . "notes.org")
     (org-log-done . 'time)
     (org-support-shift-select . t)
     (org-return-follows-link . t))
    :config
    ;; NOTE: my:d:org/notes/ is intentionally excluded from org-agenda-files (prose-only Markdown domain).
    (setq org-agenda-files
          (seq-filter (lambda (file)
                        (and (string-match-p "\\.org$" file)
                             (not (string-match-p "archives" file))))
                      (directory-files-recursively org-directory "\\.org$")))
    (unless org-agenda-files
      (setq org-agenda-files (list (expand-file-name "inbox.org" org-directory))))
    (setq org-todo-keywords
          '((sequence "TODO(t)" "SOMEDAY(s)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c@)")))
    (setq org-refile-targets
          '((nil :maxlevel . 3)
            (my/org-buffer-files :maxlevel . 1)
            (org-agenda-files :maxlevel . 3)))
    (setq org-capture-templates
          `(("t" "Todo" entry (file+headline ,(expand-file-name "gtd.org" org-directory) "Inbox")
             "* TODO %?\n %i\n %a")
            ("n" "Note" entry (file+headline ,(expand-file-name "notes.org" org-directory) "Notes")
             "* %?\nEntered on %U\n %i\n %a")
            ("j" "Journal" entry (function org-journal-find-location)
             "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
            ("m" "Meeting" entry (file ,(expand-file-name "meetings.org" org-directory))
             "* MEETING with %? :meeting:\n  %U\n  %a"))))

  (with-eval-after-load 'org
    (let* ((central (expand-file-name "archive.org" (or (bound-and-true-p org-directory)
                                                       (expand-file-name "~/org")))))
      (setopt org-archive-location (concat central "::"))))

  (provide 'orgx/org-core)
  ;;; orgx/org-core.el ends here
#+end_src

*** orgx/org-visual.el
:PROPERTIES:
:CUSTOM_ID: orgx-visual
:header-args:emacs-lisp: :tangle lisp/orgx/org-visual.el
:END:

**** Purpose
Provide **modern, distraction-free visuals** for Org buffers.

**** What it does
- Enables `org-modern`
- Improves heading, list, checkbox, and priority visuals
- Beautifies agenda layout and time grid

**** Notes
- Purely visual; no semantic changes
- Typography extras live in `orgx/org-typography.el`

**** Implementation

#+begin_src emacs-lisp
;;; orgx/org-visual.el --- Org Mode visual enhancements -*- lexical-binding: t; -*-
;;
;; Category: org
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf org-modern
  :straight t
  :hook (org-mode . org-modern-mode)
  :custom
  ((org-startup-indented . t)
   (org-hide-leading-stars . t)
   (org-auto-align-tags . nil)
   (org-tags-column . 0)
   (org-catch-invisible-edits . 'show-and-error)
   (org-special-ctrl-a/e . t)
   (org-insert-heading-respect-content . t)
   (org-hide-emphasis-markers . t)
   (org-pretty-entities . t)
   (org-modern-todo-faces
    . '(("TODO"     :background "#673AB7" :foreground "#f8f8f2")
        ("SOMEDAY"  :background "#6b7280" :foreground "#f8f8f2")
        ("WAITING"  :background "#6272a4" :foreground "#f8f8f2")
        ("DONE"     :background "#373844" :foreground "#b0b8d1")
        ("CANCELED" :background "#4b5563" :foreground "#e5e7eb")))
   (org-modern-list . '((?+ . "‚ó¶") (?- . "‚Äì") (?* . "‚Ä¢")))
   (org-modern-checkbox . '((?X . "Ôò´") (?- . "ÔÑÅ") (?\s . "Ôò∞")))
   (org-modern-priority . '((?A . "Ôö§") (?B . "ÔÑÇ") (?C . "ÔÑÜ")))
   (org-modern-replace-stars . "ÔàôÔ¢§Ô¢ßÔ¢™Ô¢≠Ô¢∞Ô¢≥Ô¢∂Ô¢πÔ¢º")
   (org-agenda-tags-column . 0)
   (org-agenda-block-separator . ?‚îÄ)
   (org-agenda-time-grid
    . '((daily today require-timed)
        (800 1000 1200 1400 1600 1800 2000)
        " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ " " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ "))
   (org-agenda-current-time-string
    . "‚≠† now ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")))

(provide 'orgx/org-visual)
;;; orgx/org-visual.el ends here
#+end_src

*** orgx/org-extensions.el
:PROPERTIES:
:CUSTOM_ID: orgx-extensions
:header-args:emacs-lisp: :tangle lisp/orgx/org-extensions.el
:END:

**** Purpose
Provide **optional but production-safe extensions** for Org workflows.

**** What it does
- Enables org-journal and org-roam
- Adds defensive guards for org-roam hashing
- Delays org-roam autosync to avoid IO races
- Adds helpers for downloads, TOC, and link capture

**** Notes
- org-roam autosync is intentionally delayed
- Guards avoid crashes on network/iCloud filesystems

**** Implementation

#+begin_src emacs-lisp
;;; orgx/org-extensions.el --- Org Mode extensions -*- lexical-binding: t; -*-
;;
;; Category: org
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf org-journal
  :straight t
  :custom ((org-journal-dir . my:d:org-journal)))

(leaf org-roam
  :straight t
  :custom ((org-roam-directory . my:d:org-roam))
  :config
  (setq org-roam-db-location
        (expand-file-name "org-roam.db" my:d:org-roam))

  (defun orgx--org-roam-file-hash-guard (orig file)
    "Guard `org-roam-db--file-hash' against file read errors."
    (condition-case err
        (funcall orig file)
      (error
       (message "[org-roam] skip hash: %s (%s)"
                file (error-message-string err))
       nil)))

  (with-eval-after-load 'org-roam
    (when (fboundp 'org-roam-db--file-hash)
      (advice-add 'org-roam-db--file-hash
                  :around #'orgx--org-roam-file-hash-guard)))

  (run-with-idle-timer
   5 nil
   (lambda ()
     (when (fboundp 'org-roam-db-autosync-mode)
       (org-roam-db-autosync-mode 1)
       (message "[org-roam] autosync enabled (delayed)")))))

(leaf org-download
  :straight t
  :custom ((org-download-image-dir . my:d:org-pictures)))

(leaf toc-org
  :straight t
  :hook ((org-mode . toc-org-enable)
         (markdown-mode . toc-org-mode)))

(leaf org-cliplink :straight t)

(provide 'orgx/org-extensions)
;;; orgx/org-extensions.el ends here
#+end_src

*** orgx/org-export.el
:PROPERTIES:
:CUSTOM_ID: orgx-export
:header-args:emacs-lisp: :tangle lisp/orgx/org-export.el
:END:

**** Purpose
Provide a **robust Org export pipeline** for Hugo, Markdown, and diagrams.

**** What it does
- Configures ox-hugo and Hugo capture templates
- Enables Markdown editing and preview
- Enables Mermaid and Graphviz in Org Babel
- Provides Hugo draft review helpers

**** Notes
- Hugo filenames are generated safely and deterministically
- Mermaid requires `mmdc` executable

**** Implementation

#+begin_src emacs-lisp
;;; orgx/org-export.el --- Org export configuration -*- lexical-binding: t; -*-
;;
;; Category: org
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf ox-hugo
  :straight t
  :after ox
  :custom ((org-hugo-front-matter-format . "toml")))

(leaf markdown-mode :straight t)
(leaf markdown-preview-mode :straight t)
(leaf edit-indirect :straight t)

(leaf ob-mermaid
  :straight t
  :after org
  :config
  (when (executable-find "mmdc")
    (setq ob-mermaid-cli-path (executable-find "mmdc")))
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages '((mermaid . t)))))

(leaf ob-dot
  :straight nil
  :after org
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages '((dot . t)))))

(provide 'orgx/org-export)
;;; orgx/org-export.el ends here
#+end_src

*** orgx/org-typography.el
:PROPERTIES:
:CUSTOM_ID: orgx-typography
:header-args:emacs-lisp: :tangle lisp/orgx/org-typography.el
:END:

**** Purpose
Provide **modern typography enhancements** for Org buffers without
overlapping with structural or decorative visuals.

This module focuses on *readability and flow* of prose-heavy Org documents,
complementing `orgx/org-visual.el` (org-modern).

**** What it does
- Aligns Org tables and inline images visually using `valign`
- Reveals emphasis markers, links, and sub/superscripts contextually
  using `org-appear`
- Improves prose editing experience while keeping code blocks untouched

**** Notes
- This module is intentionally **orthogonal** to `org-modern`
- No faces, icons, or agenda styling are defined here
- Variable-pitch support is documented but disabled by default
- Safe to enable in long-running sessions

**** Implementation

#+begin_src emacs-lisp
;;; orgx/org-typography.el --- Org modern typography extras -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2026
;; License: GNU GPL v3 or later
;;
;; Category: org
;;
;;; Commentary:
;; Complements orgx/org-visual.el (org-modern) without overlap.
;; Focuses on typography and prose readability.
;;
;;; Code:

(eval-when-compile
  (require 'leaf))

;; Optional prose setting:
;; Use variable-pitch for text while keeping code blocks monospaced.
;; Disabled by default to avoid surprising font changes.
;;
;; (leaf org
;;   :straight nil
;;   :hook (org-mode-hook . variable-pitch-mode))

;; Align tables and inline images for better visual flow
(leaf valign
  :straight t
  :hook (org-mode-hook . valign-mode))

;; Contextual reveal of emphasis, links, and markers
(leaf org-appear
  :straight t
  :hook (org-mode-hook . org-appear-mode)
  :init
  (setq org-appear-autoemphasis t
        org-appear-autolinks t
        org-appear-autosubmarkers t))

(provide 'orgx/org-typography)
;;; orgx/org-typography.el ends here
#+end_src

*** vcs/vcs-magit.el
:PROPERTIES:
:CUSTOM_ID: vcs-magit
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-magit.el
:END:

**** Purpose
Provide **Git integration via Magit** with safe defaults.

**** What it does
- Lazily loads Magit entry points
- Keeps auto-revert opt-in
- Enables refined diff display

**** Notes
- Avoids eager refresh churn
- Plays well with long-running sessions

**** Implementation

#+begin_src emacs-lisp
;;; vcs/vcs-magit.el --- Git integration with Magit -*- lexical-binding: t; -*-
;;
;; Category: vcs
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf magit
  :straight t
  :commands (magit-status magit-dispatch)
  :init
  (setq magit-auto-revert-mode nil)
  :config
  (setq magit-refresh-status-buffer nil
        magit-diff-refine-hunk 'all))

(provide 'vcs/vcs-magit)
;;; vcs/vcs-magit.el ends here
#+end_src

*** vcs/vcs-gutter.el
:PROPERTIES:
:CUSTOM_ID: vcs-gutter
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-gutter.el
:END:

**** Purpose
Provide **lightweight Git change indicators** in the fringe.

**** What it does
- Enables diff-hl in code, text, and dired buffers
- Integrates with Magit refresh lifecycle

**** Notes
- Sole fringe indicator by design
- Borders are disabled for clarity

**** Implementation

#+begin_src emacs-lisp
;;; vcs/vcs-gutter.el --- Show Git changes in fringe -*- lexical-binding: t; -*-
;;
;; Category: vcs
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf diff-hl
  :straight t
  :commands (diff-hl-mode diff-hl-dired-mode diff-hl-magit-post-refresh)
  :hook ((prog-mode . diff-hl-mode)
         (text-mode . diff-hl-mode)
         (dired-mode . diff-hl-dired-mode))
  :config
  (with-eval-after-load 'magit
    (add-hook 'magit-post-refresh #'diff-hl-magit-post-refresh))
  (customize-set-variable 'diff-hl-draw-borders nil))

(provide 'vcs/vcs-gutter)
;;; vcs/vcs-gutter.el ends here
#+end_src

*** vcs/vcs-forge.el
:PROPERTIES:
:CUSTOM_ID: vcs-forge
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-forge.el
:END:

**** Purpose
Integrate **GitHub/GitLab forges** into Magit via Forge.

**** What it does
- Installs Forge with Magit integration
- Forces built-in SQLite backend on Emacs 29+
- Stores Forge DB under var directory

**** Notes
- Defensive fallbacks are included
- No-littering is respected when available

**** Implementation

#+begin_src emacs-lisp
;;; vcs/vcs-forge.el --- GitHub/GitLab integration via Forge -*- lexical-binding: t; -*-
;;
;; Category: vcs
;;
;;; Code:

(eval-when-compile (require 'leaf))

(defvar no-littering-var-directory
  (expand-file-name ".var/" user-emacs-directory))

(unless (file-directory-p no-littering-var-directory)
  (make-directory no-littering-var-directory t))

(unless (fboundp 'my/ensure-directory-exists)
  (defun my/ensure-directory-exists (dir)
    (unless (file-directory-p dir)
      (make-directory dir t))))

(leaf forge
  :straight t
  :after magit
  :init
  (with-eval-after-load 'emacsql
    (when (boundp 'emacsql-sqlite3-executable)
      (setq emacsql-sqlite3-executable nil)))
  :config
  (let* ((db-dir (expand-file-name "forge" no-littering-var-directory))
         (db (expand-file-name "forge-database.sqlite" db-dir)))
    (my/ensure-directory-exists db-dir)
    (setq forge-database-file db)))

(provide 'vcs/vcs-forge)
;;; vcs/vcs-forge.el ends here
#+end_src

*** dev/dev-lsp-eglot.el
:PROPERTIES:
:CUSTOM_ID: dev-lsp-eglot
:header-args:emacs-lisp: :tangle lisp/dev/dev-lsp-eglot.el
:END:

**** Purpose
Provide a **safe, minimal Eglot-based LSP setup** with automatic activation
only when a language server is likely available.

**** What it does
- Installs Eglot as the LSP client
- Detects whether an LSP server can be guessed for the current buffer
- Enables Eglot automatically in `prog-mode` buffers when safe
- Avoids hard dependency on Eglot internal APIs

**** Notes
- Never errors even if Eglot changes private helpers
- Does not force LSP startup when no server is detected
- Designed to coexist with alternative LSP stacks

**** Implementation

#+begin_src emacs-lisp
;;; dev-lsp-eglot.el --- Eglot setup -*- lexical-binding: t; -*-
;;
;; Category: dev
;;
;;; Commentary:
;; Eglot baseline with safe auto-enable.
;;
;;; Code:

(eval-when-compile (require 'leaf))

(defun my/eglot-guessable-p ()
  "Return non-nil if current buffer seems to have an LSP server we can start."
  (cond
   ((fboundp 'eglot--guess-contact)
    (ignore-errors (eglot--guess-contact)))
   ((fboundp 'eglot-guess-contact)
    (ignore-errors (eglot-guess-contact)))
   (t nil)))

(leaf eglot
  :straight t
  :commands (eglot eglot-ensure)
  :custom ((eglot-autoreconnect . t))
  :hook ((prog-mode . (lambda ()
                        (when (my/eglot-guessable-p)
                          (eglot-ensure))))))

;;;###autoload
(defun my/lsp-enable-eglot ()
  "Enable Eglot-based LSP setup."
  (interactive)
  (add-hook 'prog-mode-hook
            (lambda ()
              (when (my/eglot-guessable-p)
                (eglot-ensure))))
  (message "[lsp] Eglot enabled."))

(provide 'dev/dev-lsp-eglot)
;;; dev-lsp-eglot.el ends here
#+end_src

*** dev/dev-lsp-mode.el
:PROPERTIES:
:CUSTOM_ID: dev-lsp-mode
:header-args:emacs-lisp: :tangle lisp/dev/dev-lsp-mode.el
:END:

**** Purpose
Provide an **lsp-mode based LSP stack** (optionally with `lsp-ui`) while
delegating in-buffer completion to Corfu/CAPF.

**** What it does
- Enables `lsp-mode` for `prog-mode` via `lsp-deferred`
- Configures conservative watcher/timeouts for stability
- Disables `lsp-mode`‚Äôs own completion provider (`:none`)
- Enables `lsp-ui` as an optional UI layer
- Exposes an autoloaded entry point to enable this stack on demand

**** Notes
- Completion is intentionally delegated to Corfu/Cape (CAPF)
- Hooks are simple and predictable (no advice)
- Designed to coexist with Eglot stack selection via `core/switches.el`

**** Implementation

#+begin_src emacs-lisp
  ;;; dev-lsp-mode.el --- lsp-mode setup -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;;; Commentary:
  ;; lsp-mode baseline + lsp-ui. Completion is delegated to Corfu.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf lsp-mode
    :straight t
    :commands (lsp lsp-deferred)
    :custom ((lsp-keymap-prefix . "C-c l")
             (lsp-enable-file-watchers . t)
             (lsp-file-watch-threshold . 5000)
             (lsp-response-timeout . 5)
             (lsp-diagnostics-provider . :auto)
             (lsp-completion-provider . :none))
    :hook ((prog-mode . lsp-deferred)))

  (leaf lsp-ui
    :straight t
    :after lsp-mode
    :custom ((lsp-ui-doc-enable . t)
             (lsp-ui-doc-delay . 0.2)
             (lsp-ui-sideline-enable . t)))

  ;;;###autoload
  (defun my/lsp-enable-lspmode ()
    "Enable lsp-mode-based LSP setup."
    (interactive)
    (add-hook 'prog-mode-hook #'lsp-deferred)
    (message "[lsp] lsp-mode enabled."))

  (provide 'dev/dev-lsp-mode)
  ;;; dev-lsp-mode.el ends here
#+end_src

*** dev/dev-ai.el
:PROPERTIES:
:CUSTOM_ID: dev-ai
:header-args:emacs-lisp: :tangle lisp/dev/dev-ai.el
:END:

**** Purpose
Centralize **AI-assisted development** configuration (Aidermacs) and
consolidate its runtime/history files into a stable per-user directory.

**** What it does
- Creates/uses `~/.var/aideremacs/` (or `my:d:var`-based) as a base dir
- Sets official `AIDER_*` environment variables for history/log files
- Optionally injects a per-user `.env` via Aidermacs extra args
- Selects model/provider based on environment variables
  - OpenRouter (`OPENROUTER_API_KEY`)
  - OpenAI (`OPENAI_API_KEY`)

**** Notes
- Safe to load early (only env + variables, no UI)
- Uses official Aider env vars so CLI and Aidermacs stay consistent
- If your Aidermacs build uses `aidermacs-args` instead of `aidermacs-extra-args`,
  you can rename locally (this module assumes the newer variable exists)

**** Implementation

#+begin_src emacs-lisp
  ;;; dev/dev-ai.el --- AI-assisted development -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; AI-assisted coding via Aidermacs.
  ;;
  ;; Purpose: Centralize aider/Aidermacs runtime files into ~/.var/aideremacs
  ;; Notes:
  ;; - Uses official AIDER_* env vars so both CLI and Aidermacs obey.
  ;; - Safe to load early (e.g. in personal/user.el or core/general.el).
  ;; - pip3 install aider-ce
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf)
  		   (require 'subr-x))

  ;; 1) Decide base directory: ~/.var/aideremacs
  (defvar my:d:aider
    (expand-file-name "aideremacs/" (or (bound-and-true-p my:d:var)
                                        (expand-file-name "~/.var/")))
    "Base directory to store aider runtime files.")

  ;; 2) Ensure directory exists
  (my/ensure-directory-exists my:d:aider)

  ;; 3) Point aider history files to this directory via env vars
  ;;    (aider recognizes these officially)
  (setenv "AIDER_INPUT_HISTORY_FILE" (expand-file-name "input.history" my:d:aider))
  (setenv "AIDER_CHAT_HISTORY_FILE"  (expand-file-name "chat.history.md" my:d:aider))
  (setenv "AIDER_LLM_HISTORY_FILE"   (expand-file-name "llm.history" my:d:aider))
  ;; Optional: analytics log location if you enable analytics logging
  (setenv "AIDER_ANALYTICS_LOG"      (expand-file-name "analytics.log" my:d:aider))

  ;; 4) [Optional] Keep a per-user .env here and make aider load it.
  ;;    You can create ~/.var/aideremacs/.env and put API keys / options there.
  ;;    If you use Aidermacs, pass --env-file via its extra args.
  (with-eval-after-load 'aidermacs
    ;; Aidermacs exposes an extra-args variable in recent builds
    ;; (see NonGNU ELPA diffs mentioning `aidermacs-extra-args`).
    ;; If your installed version still uses `aidermacs-args`, switch the name.
    (defvar aidermacs-extra-args nil)
    (let ((env-file (expand-file-name ".env" my:d:aider)))
      (when (file-exists-p env-file)
        (setq aidermacs-extra-args
              (append aidermacs-extra-args
                      (list "--env-file" env-file)))))

    ;; Redundancy is harmless: also force the same files via CLI flags,
    ;; in case your shell environment overrides Emacs' setenv.
    (setq aidermacs-extra-args
          (append aidermacs-extra-args
                  (list "--input-history-file" (getenv "AIDER_INPUT_HISTORY_FILE")
                        "--chat-history-file"  (getenv "AIDER_CHAT_HISTORY_FILE")
                        "--llm-history-file"   (getenv "AIDER_LLM_HISTORY_FILE")))))

  (leaf aidermacs :straight t
    :init
    (cond
     ((getenv "OPENROUTER_API_KEY")
      (setenv "OPENAI_API_BASE" "https://openrouter.ai/api/v1")
      (setenv "OPENAI_API_KEY"  (getenv "OPENROUTER_API_KEY"))
      (setopt aidermacs-default-model "openrouter/anthropic/claude-3.5-sonnet"))
     ((getenv "OPENAI_API_KEY")
      (setenv "OPENAI_API_BASE" "https://api.openai.com/v1")
      (setopt aidermacs-default-model "gpt-4o-mini"))
     (t
      (display-warning 'aidermacs
                       "No API keys set. Set OPENROUTER_API_KEY or OPENAI_API_KEY.")))
    (setopt aidermacs-retry-attempts 3
            aidermacs-retry-delay   2.0
            aidermacs-backend       'vterm))

  (provide 'dev/dev-ai)
  ;;; dev/dev-ai.el ends here
#+end_src

*** dev/dev-term.el
:PROPERTIES:
:CUSTOM_ID: dev-term
:header-args:emacs-lisp: :tangle lisp/dev/dev-term.el
:END:

**** Purpose
Provide a **terminal workflow** inside Emacs via vterm/vterm-toggle, and
keep terminal colors consistent by reusing the nano palette.

**** What it does
- Loads `vterm` and applies `ui/ui-nano-palette` to vterm faces
- Works around vterm builds that lack `vterm-color-default`
- Re-applies palette after theme changes
- Adds `vterm-toggle` for quick toggling and project scoping
- Adds a `display-buffer-alist` rule to show vterm at the bottom

**** Notes
- Uses palette as a single source of truth (no :custom-face)
- Color application is guarded by `facep` checks
- Display rule is installed only after vterm is available

**** Implementation

#+begin_src emacs-lisp
  ;;; dev/dev-term.el --- Terminal integration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Uses ui/ui-nano-palette as the single source of truth for colors.
  ;; Avoid :custom-face (can trigger ‚ÄúAttempt modify constant ‚Ä¶‚Äù with leaf).
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'cl-lib))

  ;; Palette is provided by the caller's load-path setup.
  (require 'ui/ui-nano-palette)

  (defun my/vterm-apply-palette ()
    "Apply nano-style palette to vterm faces safely and compatibly.
  Some vterm builds don't define `vterm-color-default`; use `vterm` face instead."
    ;; Fallbacks (in case palette wasn't set yet)
    (defvar nano-color-foreground "#374151")
    (defvar nano-color-background "#fafafa")
    (defvar nano-color-salient    "#2563eb")
    (defvar nano-color-popout     "#6b7280")
    (defvar nano-color-critical   "#dc2626")
    (defvar nano-color-strong     "#111827")
    (defvar nano-color-faded      "#9ca3af")
    (defvar nano-color-subtle     "#e5e7eb")

    (cl-labels
        ((safe-face-set (face &rest props)
           (when (facep face)
             (apply #'set-face-attribute face nil props))))

      ;; Default fg/bg: prefer vterm-color-default; fall back to vterm
      (if (facep 'vterm-color-default)
          (safe-face-set 'vterm-color-default
                         :foreground nano-color-foreground
                         :background nano-color-background)
        (safe-face-set 'vterm
                       :foreground nano-color-foreground
                       :background nano-color-background))

      ;; 8-color palette (keep backgrounds unobtrusive)
      (safe-face-set 'vterm-color-black   :foreground nano-color-strong   :background 'unspecified)
      (safe-face-set 'vterm-color-red     :foreground nano-color-critical :background 'unspecified)
      (safe-face-set 'vterm-color-green   :foreground "#10b981"           :background 'unspecified) ; emerald-500
      (safe-face-set 'vterm-color-yellow  :foreground nano-color-popout   :background 'unspecified)
      (safe-face-set 'vterm-color-blue    :foreground nano-color-salient  :background 'unspecified)
      (safe-face-set 'vterm-color-magenta :foreground "#a21caf"           :background 'unspecified) ; fuchsia-700
      (safe-face-set 'vterm-color-cyan    :foreground "#0891b2"           :background 'unspecified) ; cyan-600
      (safe-face-set 'vterm-color-white   :foreground nano-color-subtle   :background 'unspecified)))

  (defun my/vterm-buffer-p (buf)
    "Return non-nil if BUF is a vterm buffer."
    (with-current-buffer buf
      (or (eq major-mode 'vterm-mode)
          (string-prefix-p "*vterm" (buffer-name buf)))))

  (leaf vterm
    :doc  "Emacs libvterm integration"
    :url  "https://github.com/akermu/emacs-libvterm"
    :straight t
    :config
    ;; Apply once vterm is loaded
    (my/vterm-apply-palette)
    ;; Re-apply after theme activation to keep colors consistent
    (with-eval-after-load 'cus-theme
      (if (boundp 'enable-theme-functions)
          (add-hook 'enable-theme-functions #'my/vterm-apply-palette)
        (advice-add 'enable-theme :after (lambda (&rest _) (my/vterm-apply-palette))))))

  (leaf vterm-toggle
    :doc  "Toggle between vterm and the current buffer"
    :url  "https://github.com/jixiuf/vterm-toggle"
    :straight t
    :custom
    (vterm-toggle-cd-auto-create-buffer . t)
    (vterm-toggle-fullscreen-p          . nil)
    (vterm-toggle-scope                 . 'project))

  ;; Buffer display rule must be set after vterm is available
  (with-eval-after-load 'vterm
    (add-to-list 'display-buffer-alist
                 `(my/vterm-buffer-p
                   (display-buffer-reuse-window display-buffer-in-direction)
                   (direction       . bottom)
                   (dedicated       . t)
                   (reusable-frames . visible)
                   (window-height   . 0.3))))

  (provide 'dev/dev-term)
  ;;; dev/dev-term.el ends here
#+end_src

*** dev/dev-build.el
:PROPERTIES:
:CUSTOM_ID: dev-build
:header-args:emacs-lisp: :tangle lisp/dev/dev-build.el
:END:

**** Purpose
Provide **build / Makefile tooling** with sane defaults for compilation,
indentation, and ANSI color rendering.

**** What it does
- Enables Makefile modes and sets Makefile-friendly indentation
- Sets `compile-command` to `make -k` when a Makefile is present
- Enables scrolling compilation output and thresholding
- Applies ANSI colors in compilation buffers

**** Notes
- Hooks are mode-local and do not affect non-build buffers
- ANSI color application is guarded by read-only inhibition

**** Implementation

#+begin_src emacs-lisp
  ;;; dev/dev-build.el --- Build & Makefile tools -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Build system integration.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf make-mode :straight nil
    :mode (("\\`Makefile\\'"    . makefile-gmake-mode)
           ("\\`GNUmakefile\\'" . makefile-gmake-mode)
           ("\\`makefile\\'"    . makefile-gmake-mode))
    :hook ((makefile-mode . (lambda ()
                              (setq-local indent-tabs-mode t
                                          tab-width 8
                                          show-trailing-whitespace t))))
    :config
    (leaf compile :straight nil
      :custom ((compilation-scroll-output . t)
               (compilation-skip-threshold . 2))
      :init
      (defun my/set-make-compile-command ()
        "Use `make -k` when Makefile is present."
        (when (or (derived-mode-p 'makefile-mode)
                  (locate-dominating-file default-directory "Makefile")
                  (locate-dominating-file default-directory "GNUmakefile"))
          (setq-local compile-command "make -k")))
      (add-hook 'after-change-major-mode-hook #'my/set-make-compile-command))
    (leaf ansi-color :straight nil
      :hook (compilation-filter . (lambda ()
                                    (let ((inhibit-read-only t))
                                      (ansi-color-apply-on-region compilation-filter-start (point-max)))))))

  (provide 'dev/dev-build)
  ;;; dev/dev-build.el ends here
#+end_src

*** dev/dev-docker.el
:PROPERTIES:
:CUSTOM_ID: dev-docker
:header-args:emacs-lisp: :tangle lisp/dev/dev-docker.el
:END:

**** Purpose
Provide **Docker-oriented editing and inspection** support in Emacs.

**** What it does
- Enables `dockerfile-mode` for Dockerfiles
- Enables `yaml-mode` for Compose files and YAML
- Provides `docker` commands (containers/images/volumes/networks)
- Enables TRAMP container method via `tramp-container`
- Adds Tempel snippet(s) for Dockerfile authoring

**** Notes
- TRAMP container method is configured after TRAMP is available
- Tempel template registration is delayed until Tempel is loaded

**** Implementation

#+begin_src emacs-lisp
  ;;; dev/dev-docker.el --- Docker integration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Docker development support.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf dockerfile-mode :straight t
    :mode (("Dockerfile\\(\\..*\\)?\\'" . dockerfile-mode)
           ("\\.dockerfile\\'"         . dockerfile-mode))
    :custom ((dockerfile-mode-command . "docker")))

  (leaf yaml-mode :straight t
    :mode (("\\`docker-compose.*\\.ya?ml\\'" . yaml-mode)
           ("\\.ya?ml\\'"                   . yaml-mode)))

  (leaf docker :straight t
    :commands (docker docker-containers docker-images docker-volumes docker-networks))

  (leaf tramp-container :straight nil
    :after tramp
    :init
    (setq tramp-container-method "docker"))

  (leaf tempel :straight t
    :commands (tempel-insert)
    :init
    (with-eval-after-load 'tempel
      (defvar my:tempel-docker-templates
        '((dockerfile "FROM " p n
                      "WORKDIR /app" n
                      "COPY . /app" n
                      "RUN " p n
                      "CMD [" p "]" n)))
      (add-to-list 'tempel-user-elements my:tempel-docker-templates)))

  (provide 'dev/dev-docker)
  ;;; dev/dev-docker.el ends here
#+end_src

*** dev/dev-web-core.el
:PROPERTIES:
:CUSTOM_ID: dev-web-core
:header-args:emacs-lisp: :tangle lisp/dev/dev-web-core.el
:END:

**** Purpose
Provide a **web/dev baseline** for modern syntax highlighting (tree-sitter)
and project/file hygiene.

**** What it does
- Loads `project` for project workflows
- Enforces trailing whitespace cleanup and final newline defaults
- Enables `editorconfig` globally
- Remaps legacy major modes to `*-ts-mode` via `major-mode-remap-alist`
- Extends `auto-mode-alist` for TS/TSX/JSON/YAML tree-sitter modes

**** Notes
- Tree-sitter remapping applies only when Emacs has `treesit` support
- Uses built-in `files` and `project` packages where available

**** Implementation

#+begin_src emacs-lisp
  ;;; dev-web-core.el --- Treesit & project core -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Core configuration for project management and modern syntax highlighting.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf project :straight nil)
  (leaf files   :straight nil
    :custom ((require-final-newline . t)
             (delete-trailing-lines . t))
    :hook ((before-save-hook . delete-trailing-whitespace)))

  (leaf editorconfig
    :straight t
    :global-minor-mode t)

  (leaf treesit
    :straight nil
    :custom ((major-mode-remap-alist
              . '((typescript-mode . typescript-ts-mode)
                  (js-mode         . js-ts-mode)
                  (json-mode       . json-ts-mode)
                  (css-mode        . css-ts-mode)
                  (yaml-mode       . yaml-ts-mode)
                  (sh-mode         . bash-ts-mode)))))

  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'"  . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))

  (provide 'dev/dev-web-core)
  ;;; dev-web-core.el ends here
#+end_src

*** dev/dev-format.el
:PROPERTIES:
:CUSTOM_ID: dev-format
:header-args:emacs-lisp: :tangle lisp/dev/format.el
:END:

**** Purpose
Provide **auto-formatting** for web-centric buffers (TypeScript/TSX/JSON/CSS/Markdown)
via Apheleia with Prettier/Prettierd.

**** What it does
- Installs and enables `apheleia` globally
- Registers `prettierd` and `prettier` formatters
- Maps major modes to use `prettierd` by default

**** Notes
- Requires `prettierd` or `npx prettier` available in PATH
- Uses Apheleia‚Äôs formatter registry (`apheleia-formatters`)
- Leaves non-listed modes untouched

**** Implementation

#+begin_src emacs-lisp
  ;;; dev-format.el --- Prettier/ESLint via Apheleia -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf apheleia
    :straight t
    :require t
    :config
    (setf (alist-get 'prettierd apheleia-formatters)
          '("prettierd" filepath))
    (setf (alist-get 'prettier apheleia-formatters)
          '("npx" "prettier" "--stdin-filepath" filepath))
    (dolist (pair '((typescript-ts-mode . prettierd)
                    (tsx-ts-mode        . prettierd)
                    (json-ts-mode       . prettierd)
                    (css-ts-mode        . prettierd)
                    (markdown-mode      . prettierd)))
      (add-to-list 'apheleia-mode-alist pair))
    (apheleia-global-mode +1))

  (provide 'dev/dev-format)
  ;;; dev-format.el ends here
#+end_src

*** dev/dev-infra-modes.el
:PROPERTIES:
:CUSTOM_ID: dev-infra-modes
:header-args:emacs-lisp: :tangle lisp/dev/dev-infra-modes.el
:END:

**** Purpose
Provide **infra file syntax support** for common ops/devops formats.

**** What it does
- Enables `docker-compose-mode` for docker-compose YAML variants
- Enables `dotenv-mode` for `.env` files (and `.env.*`)
- Enables `toml-mode` for TOML files

**** Notes
- This module is intentionally narrow: only mode associations
- Leaves formatting/linting to other modules (e.g. Apheleia)

**** Implementation

#+begin_src emacs-lisp
  ;;; dev-infra-modes.el --- Infra modes (.env / Compose / TOML / Make) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Syntax support for infra files such as Docker Compose, .env, TOML, and Makefiles.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf docker-compose-mode :straight t :mode ("docker-compose\\.*ya?ml\\'"))
  (leaf dotenv-mode :straight t
    :mode (("\\.env\\..*\\'" . dotenv-mode)
           ("\\.env\\'"     . dotenv-mode)))
  (leaf toml-mode :straight t :mode ("\\.toml\\'" . toml-mode))

  (provide 'dev/dev-infra-modes)
  ;;; dev/dev-infra-modes.el ends here
#+end_src

*** dev/dev-sql.el
:PROPERTIES:
:CUSTOM_ID: dev-sql
:header-args:emacs-lisp: :tangle lisp/dev/dev-sql.el
:END:

**** Purpose
Provide a **PostgreSQL-focused SQL editing** experience with indentation
and on-save formatting.

**** What it does
- Sets `sql-product` to PostgreSQL
- Enables `sql-indent` minor mode in `sql-mode`
- Enables `sqlformat` on-save for `sql-mode` and `sql-ts-mode`
- Configures formatter command (`pgformatter`) and args

**** Notes
- Requires `pgformatter` available in PATH for sqlformat
- Hooks are mode-local and safe

**** Implementation

#+begin_src emacs-lisp
;;; lisp/dev/dev-sql.el --- SQL/PostgreSQL helpers -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2026
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;
;; Category: dev
;;
(eval-when-compile (require 'leaf))

(leaf sql :straight nil
  :custom ((sql-product . 'postgres)))

(leaf sql-indent :straight t
  :hook (sql-mode . sqlind-minor-mode))

(leaf sqlformat
  :straight t
  :custom ((sqlformat-command . 'pgformatter)
           (sqlformat-args . '("--nostyle")))
  :hook (sql-mode . sqlformat-on-save-mode)
  :hook (sql-ts-mode . sqlformat-on-save-mode))

(provide 'dev/dev-sql)
;;; dev-sql.el ends here
#+end_src

*** dev/dev-rest.el
:PROPERTIES:
:CUSTOM_ID: dev-rest
:header-args:emacs-lisp: :tangle lisp/dev/dev-rest.el
:END:

**** Purpose
Provide a simple **HTTP/REST client workflow** inside Emacs for quick
API testing and iteration.

**** What it does
- Enables `restclient-mode` for `.http` files
- Adds `restclient-jq` integration for JSON parsing/formatting

**** Notes
- `jq` should be available in PATH for best results
- This module keeps configuration minimal (just mode and integration)

**** Implementation

#+begin_src emacs-lisp
;;; dev-rest.el --- REST client helpers (Next.js / Ollama / Qdrant) -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2026
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;
;; Category: dev
;;
;; Commentary:
;; REST client integration for testing HTTP requests inside Emacs.
;; Supports JSON parsing with jq.
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf restclient :straight t :mode ("\\.http\\'" . restclient-mode))
(leaf restclient-jq :straight t :after restclient)

(provide 'dev/dev-rest)
;;; dev/dev-rest.el ends here
#+end_src

*** utils/utils-functions.el
:PROPERTIES:
:CUSTOM_ID: utils-functions
:header-args:emacs-lisp: :tangle lisp/utils/utils-functions.el
:END:

**** Purpose
Provide **small, safe utility functions** shared across the configuration,
covering editing helpers, Org helpers, and lightweight UI glue.

**** What it does
- Smart buffer/window killing
- Org subtree ‚Üí indirect buffer helper
- Org outline sidebar using `imenu-list`
- Nano-modeline‚Äìaware header-line rendering (with safe fallback)

**** Notes
- Optional dependencies are declared defensively to avoid byte-compile warnings
- Prefers modern Org APIs (`org-fold-show-all`) when available
- Designed to degrade gracefully if optional packages are missing

**** Implementation

#+begin_src emacs-lisp
  ;;; utils/utils-functions.el --- General utility functions -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Small, safe utilities loaded across the configuration.
  ;; - Org helpers: indirect subtree view, quick sidebar (imenu-list)
  ;; - Editing helpers: smart buffer/window killing
  ;; Notes:
  ;; - Avoid compile warnings by declaring optional deps and vars.
  ;; - Prefer modern Org APIs when available.
  ;;
  ;;; Code:

  ;;;; Built-ins ------------------------------------------------------------------

  (require 'imenu) ;; built-in

  ;;;; Optional deps & vars (for byte-compiler) -----------------------------------

  (eval-when-compile
    (declare-function imenu-list-minor-mode  "imenu-list")
    (declare-function imenu-list-stop-timer  "imenu-list")
    (declare-function imenu-list-display-dwim "imenu-list")
    (declare-function nano-modeline-render   "nano-modeline"))

  (defvar imenu-list-after-jump-hook nil)
  (defvar imenu-list-position 'left)
  (defvar imenu-list-size 30)
  (defvar imenu-list-focus-after-activation t)
  (defvar imenu-list--displayed-buffer nil)

  ;;;; Editing helpers -------------------------------------------------------------

  (defun my/kill-buffer-smart ()
    "Kill buffer and window when there are multiple windows; otherwise kill buffer."
    (interactive)
    (if (one-window-p)
        (kill-buffer)
      (kill-buffer-and-window)))

  (defalias 'my/smart-kill-buffer #'my/kill-buffer-smart)

  ;;;; Nano/Modeline helper --------------------------------------------------------

  (defun my/nano-headerline (buf subtitle)
    "Return a header-line string; prefer nano-modeline when available."
    (let* ((name (if (and buf (buffer-live-p buf))
                     (buffer-name buf)
                   (buffer-name)))
           (extra ""))
      (if (fboundp 'nano-modeline-render)
          (nano-modeline-render nil name subtitle extra)
        (concat "  "
                (propertize name 'face 'mode-line-buffer-id)
                "  " subtitle))))

  ;;;; Org helpers ----------------------------------------------------------------

  (defun my/org-tree-to-indirect-buffer ()
    "Show current Org subtree in an indirect buffer and reveal its content."
    (interactive)
    (when (derived-mode-p 'org-mode)
      (cond
       ((fboundp 'org-fold-show-all) (org-fold-show-all))
       ((fboundp 'org-show-all)      (org-show-all))))
    (org-tree-to-indirect-buffer))

  (defun my/org-sidebar ()
    "Open an imenu-list sidebar with safe fallbacks."
    (interactive)
    (unless (locate-library "imenu-list")
      (user-error "imenu-list is not installed"))
    (autoload 'imenu-list-minor-mode  "imenu-list" nil t)
    (autoload 'imenu-list-stop-timer  "imenu-list" nil t)
    (autoload 'imenu-list-display-dwim "imenu-list" nil t)

    (setq imenu-list-after-jump-hook #'recenter
          imenu-list-position 'left
          imenu-list-size 36
          imenu-list-focus-after-activation t)

    (when (buffer-base-buffer)
      (switch-to-buffer (buffer-base-buffer)))

    (imenu-list-minor-mode 1)
    (when (fboundp 'imenu-list-stop-timer)
      (imenu-list-stop-timer))

    (hl-line-mode 1)
    (when (facep 'nano-subtle)
      (face-remap-add-relative 'hl-line :inherit 'nano-subtle))

    (setq header-line-format
          `(:eval
            (my/nano-headerline
             ,(when (boundp 'imenu-list--displayed-buffer)
                'imenu-list--displayed-buffer)
             "(outline)")))
    (setq-local cursor-type nil)

    (when (fboundp 'imenu-list-display-dwim)
      (imenu-list-display-dwim)))

  (defun my/org-sidebar-toggle ()
    "Toggle the imenu-list sidebar."
    (interactive)
    (let ((win (get-buffer-window "*Ilist*")))
      (if win
          (progn
            (quit-window nil win)
            (when (buffer-base-buffer)
              (switch-to-buffer (buffer-base-buffer))))
        (my/org-sidebar))))

  (provide 'utils/utils-functions)
  ;;; utils/utils-functions.el ends here
#+end_src

*** utils/utils-scratch.el
:PROPERTIES:
:CUSTOM_ID: utils-scratch
:header-args:emacs-lisp: :tangle lisp/utils/utils-scratch.el
:END:

**** Purpose
Ensure that `*scratch*` is **always available** by automatically recreating it
when killed.

**** What it does
- Recreates `*scratch*` after it is killed
- Uses `lisp-interaction-mode`
- Inserts a small header

**** Notes
- Recreation is asynchronous to avoid interfering with kill flow

**** Implementation

#+begin_src emacs-lisp
  ;;; utils/utils-scratch.el --- Scratch buffer helpers -*- lexical-binding: t; -*-
  ;;
  ;; Category: utils
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf my:scratch-auto-recreate
    :straight nil
    :init
    (defun my/create-scratch-buffer ()
      "Create or reset a `*scratch*` buffer."
      (let ((buf (get-buffer-create "*scratch*")))
        (with-current-buffer buf
          (lisp-interaction-mode)
          (erase-buffer)
          (insert ";; This is a new *scratch* buffer\n\n"))
        buf))

    (defun my/kill-scratch-buffer-advice (buf)
      "If BUF is *scratch*, recreate it shortly after kill."
      (when (string= (buffer-name buf) "*scratch*")
        (run-at-time 0 nil #'my/create-scratch-buffer)))

    (add-hook 'kill-buffer-hook
              (lambda ()
                (my/kill-scratch-buffer-advice (current-buffer)))))

  (provide 'utils/utils-scratch)
  ;;; utils/utils-scratch.el ends here
#+end_src

*** utils/utils-backup.el
:PROPERTIES:
:CUSTOM_ID: utils-backup
:header-args:emacs-lisp: :tangle lisp/utils/utils-backup.el
:END:

**** Purpose
Automatically **clean up old backup files** to keep the var directory tidy.

**** What it does
- Deletes backup files older than 7 days
- Runs once at Emacs startup

**** Notes
- Assumes `no-littering-var-directory` is in use

**** Implementation

#+begin_src emacs-lisp
  ;;; utils/utils-backup.el --- Backup and auto-save helpers -*- lexical-binding: t; -*-
  ;;
  ;; Category: utils
  ;;
  ;;; Code:

  (defun my/delete-old-backups ()
    "Delete backup files older than 7 days."
    (interactive)
    (let ((backup-dir (concat no-littering-var-directory "backup/"))
          (threshold (- (float-time (current-time)) (* 7 24 60 60))))
      (when (file-directory-p backup-dir)
        (dolist (file (directory-files backup-dir t))
          (when (and (file-regular-p file)
                     (< (float-time
                         (file-attribute-modification-time
                          (file-attributes file)))
                        threshold))
            (delete-file file))))))

  (add-hook 'emacs-startup-hook #'my/delete-old-backups)

  (provide 'utils/utils-backup)
  ;;; utils/utils-backup.el ends here
#+end_src


*** utils/utils-async.el
:PROPERTIES:
:CUSTOM_ID: utils-async
:header-args:emacs-lisp: :tangle lisp/utils/utils-async.el
:END:

**** Purpose
Provide a **safe helper** for running asynchronous tasks without crashing Emacs.

**** What it does
- Executes a function asynchronously
- Catches and logs any errors

**** Notes
- Intended for lightweight background tasks only

**** Implementation

#+begin_src emacs-lisp
  ;;; utils/utils-async.el --- Async helpers -*- lexical-binding: t; -*-
  ;;
  ;; Category: utils
  ;;
  ;;; Code:

  (defun my/safe-run-async (task)
    "Run TASK asynchronously, catching and reporting any errors."
    (run-at-time 0 nil
                 (lambda ()
                   (condition-case err
                       (funcall task)
                     (error (message "[async] error: %s" err))))))

  (provide 'utils/utils-async)
  ;;; utils/utils-async.el ends here
#+end_src

*** utils/utils-org-agenda.el
:PROPERTIES:
:CUSTOM_ID: utils-org-agenda
:header-args:emacs-lisp: :tangle lisp/utils/utils-org-agenda.el
:END:

**** Purpose
Build `org-agenda-files` using a **persistent cache** to avoid expensive
recursive scans on every startup.

**** What it does
- Recursively scans `org-directory` for `*.org`
- Excludes paths matching a configurable regexp (default: `archives`)
- Caches results on disk under `user-emacs-directory`
- Returns agenda files in *O(1)* time when cached

**** Notes
- Does **not** define `org-directory`
- Does **not** automatically set `org-agenda-files`
- Full rescans happen only when explicitly requested

**** Implementation

#+begin_src emacs-lisp
  ;;; utils-org-agenda.el --- Cached org-agenda-files builder -*- lexical-binding: t; -*-
  ;;
  ;;; Code:

  (require 'subr-x)
  (require 'seq)

  (defgroup utils-org-agenda nil
    "Cached org-agenda-files builder."
    :group 'org)

  (defcustom utils-org-agenda-cache-file
    (expand-file-name "org-agenda-files.cache" user-emacs-directory)
    "Cache file for org-agenda-files."
    :type 'file
    :group 'utils-org-agenda)

  (defcustom utils-org-agenda-exclude-regexp
    "archives"
    "Regexp used to exclude files from org-agenda."
    :type 'regexp
    :group 'utils-org-agenda)

  (defun utils-org-agenda--scan (org-directory)
    "Recursively scan ORG-DIRECTORY and return a list of agenda files."
    (seq-filter
     (lambda (file)
       (and (string-match-p "\\.org\\'" file)
            (not (string-match-p utils-org-agenda-exclude-regexp file))))
     (directory-files-recursively org-directory "\\.org\\'")))

  (defun utils-org-agenda--load-cache ()
    "Load cached agenda files from disk."
    (when (file-readable-p utils-org-agenda-cache-file)
      (with-temp-buffer
        (insert-file-contents utils-org-agenda-cache-file)
        (read (current-buffer)))))

  (defun utils-org-agenda--save-cache (files)
    "Save FILES to the agenda cache."
    (with-temp-file utils-org-agenda-cache-file
      (prin1 files (current-buffer))))

  ;;;###autoload
  (defun utils-org-agenda-build (&optional force)
    "Return agenda files using the cache.
  If FORCE is non-nil, rebuild the cache."
    (let ((cached (and (not force)
                       (utils-org-agenda--load-cache))))
      (if (and cached (listp cached))
          cached
        (let ((files (utils-org-agenda--scan org-directory)))
          (utils-org-agenda--save-cache files)
          files))))

  ;;;###autoload
  (defun utils-org-agenda-rebuild ()
    "Force a rebuild of the org-agenda-files cache."
    (interactive)
    (setq org-agenda-files (utils-org-agenda-build t))
    (message "org-agenda-files cache rebuilt (%d files)"
             (length org-agenda-files)))

  (provide 'utils/utils-org-agenda)
  ;;; utils-org-agenda.el ends here
#+end_src


*** utils/utils-search-nav.el
:PROPERTIES:
:CUSTOM_ID: search-nav
:header-args:emacs-lisp: :tangle lisp/utils/utils-search-nav.el
:END:

**** Purpose
Provide **modern search and navigation** helpers built on ripgrep and Consult,
with safe fallbacks.

**** What it does
- Jump-to-definition via `dumb-jump`
- Multiple cursors support
- Lightweight web search and browsing via `eww`

**** Notes
- Search backend prefers ripgrep (`rg`)
- EWW helpers avoid heavy browser dependencies

**** Implementation

#+begin_src emacs-lisp
  ;;; utils/utils-search-nav.el --- Project search & navigation -*- lexical-binding: t; -*-
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x))

  (leaf dumb-jump
    :straight t
    :hook (xref-backend-functions . dumb-jump-xref-activate)
    :custom ((dumb-jump-force-searcher  . 'rg)
             (dumb-jump-prefer-searcher . 'rg)))

  (leaf multiple-cursors :straight t)

  (leaf eww
    :straight nil
    :custom ((eww-search-prefix . "https://duckduckgo.com/html/?kl=jp-jp&k1=-1&kc=1&kf=-1&q=")
             (eww-download-directory . "~/Downloads"))
    :init
    (defvar my:d:eww (expand-file-name "eww/" my:d:var))
    (setopt eww-cache-directory (expand-file-name "cache/" my:d:eww))
    (my/ensure-directory-exists eww-cache-directory)
    (setq eww-history-limit 200)

    (defvar eww-hl-search-word nil)

    (defun my/eww-search (term)
      "Search TERM with EWW and start isearch."
      (interactive "sSearch terms: ")
      (setq eww-hl-search-word term)
      (eww-browse-url (concat eww-search-prefix term)))

    (add-hook 'eww-after-render-hook
              (lambda ()
                (when eww-hl-search-word
                  (isearch-mode t)
                  (isearch-yank-string eww-hl-search-word)
                  (setq eww-hl-search-word nil))))

    (defun my/eww-toggle-images ()
      (interactive)
      (setq shr-inhibit-images (not shr-inhibit-images))
      (eww-reload)))

  (provide 'utils/utils-search-nav)
  ;;; utils-search-nav.el ends here
#+end_src


*** utils/utils-gc.el
:PROPERTIES:
:CUSTOM_ID: utils-gc
:header-args:emacs-lisp: :tangle lisp/utils/utils-gc.el
:END:

**** Purpose
Run **garbage collection at safe moments** during long-running sessions.

**** What it does
- Triggers GC on focus-out
- Triggers GC on minibuffer exit

**** Notes
- Never signals errors
- No logging or visualization

**** Implementation

#+begin_src emacs-lisp
  ;;; utils/utils-gc.el --- GC helpers for long-running sessions -*- lexical-binding: t; -*-
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf nil
    :straight nil
    :init
    (defcustom utils-gc-enable-p t
      "Enable GC hooks for long-running sessions."
      :type 'boolean
      :group 'utils)

    (defun utils-gc--collect ()
      "Run garbage collection safely."
      (when utils-gc-enable-p
        (condition-case _err
            (garbage-collect)
          (error nil))))

    (add-hook 'focus-out-hook #'utils-gc--collect)
    (add-hook 'minibuffer-exit-hook #'utils-gc--collect))

  (provide 'utils/utils-gc)
  ;;; utils/utils-gc.el ends here
#+end_src


*** utils/utils-buffers.el
:PROPERTIES:
:CUSTOM_ID: utils-buffers
:header-args:emacs-lisp: :tangle lisp/utils/utils-buffers.el
:END:

**** Purpose
Provide **automatic housekeeping** for temporary and dead-process buffers.

**** What it does
- Detects temporary buffers by name/pattern
- Cleans buffers with exited processes
- Runs periodically in the background

**** Notes
- Skips modified or visible buffers
- Safe defaults only

**** Implementation

#+begin_src emacs-lisp
  ;;; utils/utils-buffers.el --- Buffer housekeeping utilities -*- lexical-binding: t; -*-
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf nil
    :straight nil
    :init
    (defcustom utils-buffers-enable-p t
      "Enable automatic buffer housekeeping."
      :type 'boolean
      :group 'utils)

    (defvar utils-buffers--temporary-regexp
      (rx string-start "*"
          (or "Help" "Warnings" "Compile-Log" "Backtrace"
              "Async-native-compile-log" "eglot-events")
          (* any) string-end))

    (defun utils-buffers--temporary-p (buffer)
      (with-current-buffer buffer
        (and (string-match-p utils-buffers--temporary-regexp (buffer-name))
             (not (buffer-file-name))
             (not (buffer-modified-p))
             (not (get-buffer-window buffer 'visible)))))

    (defun utils-buffers--dead-process-p (buffer)
      (let ((proc (get-buffer-process buffer)))
        (and proc
             (memq (process-status proc) '(exit signal)))))

    (defun utils-buffers-cleanup ()
      "Clean up temporary and dead-process buffers."
      (interactive)
      (when utils-buffers-enable-p
        (dolist (buf (buffer-list))
          (when (or (utils-buffers--temporary-p buf)
                    (utils-buffers--dead-process-p buf))
            (kill-buffer buf)))))

    (run-with-timer 900 900 #'utils-buffers-cleanup))

  (provide 'utils/utils-buffers)
  ;;; utils/utils-buffers.el ends here
#+end_src


*** utils/utils-lsp.el
:PROPERTIES:
:CUSTOM_ID: utils-lsp
:header-args:emacs-lisp: :tangle lisp/utils/utils-lsp.el
:END:

**** Purpose
Manage **Eglot lifecycle** when switching projects.

**** What it does
- Detects project root changes
- Shuts down obsolete Eglot servers

**** Notes
- Defensive: never errors if Eglot internals change
- Complements `dev/dev-lsp-eglot.el`

**** Implementation

#+begin_src emacs-lisp
  ;;; utils/utils-lsp.el --- LSP lifecycle helpers -*- lexical-binding: t; -*-
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf nil
    :straight nil
    :init
    (defcustom utils-lsp-enable-p t
      "Enable LSP lifecycle cleanup."
      :type 'boolean
      :group 'utils)

    (defvar utils-lsp--current-project-root nil)

    (defun utils-lsp--project-root ()
      (when-let ((project (project-current nil)))
        (car (project-roots project))))

    (defun utils-lsp-on-project-switch ()
      "Shutdown obsolete eglot servers on project switch."
      (when utils-lsp-enable-p
        (let ((new-root (utils-lsp--project-root)))
          (when (and utils-lsp--current-project-root
                     new-root
                     (not (string-equal utils-lsp--current-project-root new-root))
                     (featurep 'eglot))
            (dolist (server eglot--servers)
              (when (string-prefix-p utils-lsp--current-project-root
                                     (eglot--project-root (cdr server)))
                (ignore-errors
                  (eglot-shutdown (cdr server))))))
          (setq utils-lsp--current-project-root new-root))))

    (add-hook 'find-file-hook #'utils-lsp-on-project-switch)
    (add-hook 'project-switch-project-hook #'utils-lsp-on-project-switch))

  (provide 'utils/utils-lsp)
  ;;; utils/utils-lsp.el ends here
#+end_src

** Personal Profile & Device Integrations ‚Äî `user.el`
:PROPERTIES:
:CUSTOM_ID: personal-profile-and-device-integrations
:END:

*** Overview

**** Personal Layer Philosophy

The =personal/= layer provides *user- and device-specific overlays* on top of the
shared, version-controlled configuration.

It exists to express *identity, environment, and workflow glue* without
influencing global policy or shared behavior.

This layer MAY contain:
- Identity information (name, email)
- Feature flags and personal thresholds (UI/LSP selection, timing knobs)
- Device- and OS-specific glue (input methods, mouse/scroll tuning)
- Personal keybindings and workflow integrations

This layer MUST NOT contain:
- Core architectural or cross-user decisions
- Shared defaults or policy
- Modules that other layers depend on

Hooks and timers are permitted *only when they are strictly local to the user‚Äôs
device or workflow*, degrade safely to no-ops when unavailable, and do not
affect global behavior.

**** Purpose

Provide *personal overlays* that adapt the configuration to a specific user and
machine, without compromising modularity or reproducibility of shared layers.

Concretely, this layer covers:
- Identity and safe editor defaults.
- Preferred fonts and sizes, and *global switches* for UI (=nano=) and LSP (=eglot=).
- A portable Org directory layout rooted in the user‚Äôs cloud path.
- macOS conveniences:
  - Input-method auto-switching (English ‚áÑ Japanese) via =sis=,
  - Apple Music control via AppleScript and Hydra.
- Device-specific pointer and scroll tuning (Logitech MX Ergo profile).
- Small QoL glue (cursor color normalization after theme changes, load-path hygiene).

**** What this configuration does

- *Identity & safety*
  - Sets =user-full-name= and =user-mail-address=.
  - Disables font cache compaction on macOS and enables passphrase caching for
    =plstore=.

- *Look & feel switches*
  - Declares personal font preferences (=my:font-*=) and default size.
  - Selects UI and LSP stacks via =my:use-ui= and =my:use-lsp=.

- *Directories & Org wiring*
  - Defines a cloud root at =~/Documents= and derives =my:d:org= and =my:d:blog=.
  - Ensures required directories exist.
  - Sets =org-directory= and computes =org-agenda-files= by scanning non-archive
    =.org= files.
  - Removes sensitive paths from =load-path=.

- *macOS input method (=sis=)*
  - Configures ABC ‚áÑ Kotoeri (Romaji) via =macism= at startup.
  - Enables cursor-color, respect, and inline modes when available.

- *Cursor color keep-alive*
  - Re-applies the frame cursor color to the =cursor= face after theme reloads.

- *Device profile (MX Ergo S)*
  - Smooth scrolling, conservative movement, margin preservation, tilt scrolling.
  - Mouse bindings:
    - =mouse-2= ‚Üí =yank=
    - =mouse-4/5= ‚Üí previous/next buffer

- *Apple Music integration (macOS)*
  - Async and sync AppleScript helpers.
  - Interactive commands for play/pause, next/previous track, playlist playback,
    and current track info.
  - A Hydra bound to =C-c M=, with optional Meow leader integration.

**** Module map (where things live)

| Module file | Role |
|-------------+------|
| =personal/user.el= | Personal overlays: identity, fonts, UI/LSP switches, Org paths |
| =personal/device-darwin.el= | macOS-only device and IME glue |
| =personal/apple-music.el= | Apple Music integration (AppleScript + Hydra) |

**** How it works (flow)

1. *Personal bootstrap*:
   - Identity, fonts, and UI/LSP switches are set.
   - Cloud, Org, and blog paths are defined and ensured.

2. *Org wiring*:
   - =org-directory= is set.
   - =org-agenda-files= is computed by filtering non-archive Org files.

3. *Hygiene*:
   - Sensitive directories are removed from =load-path=.

4. *macOS-only glue*:
   - =sis= is configured defensively (only if functions exist).
   - An =after-load-theme= hook keeps the cursor face in sync.

5. *Device profile*:
   - Mouse and scroll tuning is applied for the MX Ergo S.

6. *Apple Music integration*:
   - AppleScript runners are defined.
   - Interactive commands and =my/hydra-apple-music= are exposed.

**** Key settings (reference)

- =my:font-default= :: ="JetBrains Mono NL"=
- =my:font-alt= :: ="Noto Sans JP"=
- =my:emoji-font= :: ="Apple Color Emoji"=
- =my:font-size= :: =18=
- =my:use-ui= :: ='nano=
- =my:use-lsp= :: ='eglot=
- =org-directory= :: =~/Documents/org=
- =org-agenda-files= :: All =*.org= under =org-directory=, excluding =archives=
- =MX Ergo scroll profile= ::
  =mouse-wheel-scroll-amount='(1 ((shift) . 5) ((control) . 10))=,
  =scroll-conservatively=10000=,
  =scroll-margin=2=,
  =scroll-preserve-screen-position=t=
- =Cursor color keep-alive= ::
  Re-apply =(set-face-background 'cursor (frame-parameter nil 'cursor-color))=
  on =after-load-theme=

**** Usage tips

- *Switch UI or LSP quickly*:
  - Set =my:use-ui= to ='nano=, ='doom=, or ='none=.
  - Set =my:use-lsp= to ='eglot= or ='lsp=.

- *Change fonts*:
  - Adjust =my:font-*= and =my:font-size= here.
  - The UI font module picks them up automatically.

- *Apple Music control*:
  - =C-c M= opens the Hydra.
  - Keys: =p= (play/pause), =n= (next), =b= (back),
    =l= (playlist), =i= (track info).

- *Agenda scope*:
  - Use an =archives/= directory or include ‚Äúarchives‚Äù in filenames to exclude
    files from =org-agenda-files=.

**** Troubleshooting

- *sis does not switch input methods on macOS* ‚Üí
  Ensure the input source IDs match:
  ="com.apple.keylayout.ABC"= and
  ="com.apple.inputmethod.Kotoeri.RomajiTyping.Japanese"=.
  Missing functions are guarded with =fboundp=.

- *Cursor color looks wrong after a theme change* ‚Üí
  Verify the theme sets the frame‚Äôs =cursor-color= parameter; the hook reapplies it.

- *Hydra key not found* ‚Üí
  Confirm =hydra= is installed and loaded; the binding is added inside
  =with-eval-after-load=.

- *Meow leader binding missing* ‚Üí
  Requires both =meow= and =hydra= to be loaded; the binding is added defensively.

**** Related source blocks

#+begin_src emacs-lisp :tangle no
  ;; See:
  ;; - personal/user.el
  ;; - personal/device-darwin.el
  ;; - personal/apple-music.el
#+end_src

*** user.el
:PROPERTIES:
:CUSTOM_ID: personal-user
:header-args:emacs-lisp: :tangle (eval (format "personal/%s.el" (user-login-name)))
:END:

Purpose:
Personal-only knobs and identity information.

What it does:
- Defines user identity
- Overrides defcustom values from core/session and ui/health-modeline
- Injects personal paths and preferences

Notes:
- This file contains NO hooks, timers, or operational logic.
- Device- and workflow-specific code lives in separate personal modules.

#+begin_src emacs-lisp
  ;;; user.el --- Personal configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: personal
  ;;
  ;;; Commentary:
  ;; Personal configuration overrides.
  ;;
  ;; This file intentionally contains:
  ;; - Identity information
  ;; - Feature enable/disable flags
  ;; - Threshold and interval overrides
  ;;
  ;; This file intentionally does NOT contain:
  ;; - Timers
  ;; - Hooks
  ;; - Operational logic
  ;; - UI rendering code
  ;;
  ;; All behavior is implemented in core/, ui/, and utils/.
  ;;
  ;;; Code:

  ;; ---------------------------------------------------------------------------
  ;; Runtime requirements (do NOT rely on byte-compile)
  ;; ---------------------------------------------------------------------------
  (eval-when-compile
    (require 'leaf))

  ;; ---------------------------------------------------------------------------
  ;; Personal Information
  ;; ---------------------------------------------------------------------------
  (leaf *personals
    :straight nil
    :init
    ;; Identity & safety
    (setq user-full-name "YAMASHITA, Takao"
          user-mail-address "tjy1965@gmail.com"
          inhibit-compacting-font-caches t
          plstore-cache-passphrase-for-symmetric-encryption t)

    ;; Fonts / UI / LSP switches
    (setq my:font-default "JetBrains Mono"
          my:font-alt     "Noto Sans JP"
          my:emoji-font   "Apple Color Emoji"
          my:font-size    18)

    (setq my:use-ui 'nano
          my:use-lsp 'eglot)

    ;; Cloud / Org / Blog directories
    (defvar my:d:cloud
      (expand-file-name "Documents" (getenv "HOME")))
    (defvar my:d:org
      (expand-file-name "org" my:d:cloud))
    (defvar my:d:blog
      (expand-file-name "devel/repos/mysite" my:d:cloud))
    (defvar my:f:capture-blog-file
      (expand-file-name "all-posts.org" my:d:blog))

    ;; Safety: excluded paths
    (defvar my:d:excluded-directories
      (list (expand-file-name "Library/Accounts" (getenv "HOME"))))

    ;; Ensure directories exist
    (mapc #'my/ensure-directory-exists
          (list my:d:cloud my:d:org my:d:blog))

    ;; Org wiring
    (setq org-directory my:d:org)
    (setq org-roam-db-node-include-function
        (lambda ()
          (let ((file (buffer-file-name)))
            (if (null file)
                t
              (not (string-match-p "/chatgpt/" file))))))

    (setq org-agenda-files
  	(when (fboundp 'utils-org-agenda-build)
            (utils-org-agenda-build)))


    ;; load-path hygiene
    (setq load-path
          (seq-remove
           (lambda (dir)
             (member dir my:d:excluded-directories))
           load-path)))

  ;; ---------------------------------------------------------------------------
  ;; Core session orchestration knobs
  ;; ---------------------------------------------------------------------------

  ;; Master switch
  (setq core-session-enable-p t)

  ;; Timing overrides
  (setq core-session-idle-delay
        (* 30 60))                     ;; 30 minutes idle

  (setq core-session-periodic-interval
        600)                           ;; 10 minutes

  ;; Risk thresholds (personal tolerance)
  (setq core-session-buffer-threshold
        350)

  (setq core-session-process-threshold
        8)

  ;; ---------------------------------------------------------------------------
  ;; UI: session health modeline knobs
  ;; ---------------------------------------------------------------------------

  (setq ui-health-show-buffers-p t)
  (setq ui-health-show-processes-p t)
  (setq ui-health-show-eglot-p t)

  ;; ---------------------------------------------------------------------------
  ;; Optional personal safety preferences
  ;; ---------------------------------------------------------------------------

  ;; Avoid font cache compaction on long-running sessions
  (setq inhibit-compacting-font-caches t)

  ;; Cache passphrase in memory for encrypted plstore
  (setq plstore-cache-passphrase-for-symmetric-encryption t)

  ;; ---------------------------------------------------------------------------
  ;; Load personal optional modules
  ;; ---------------------------------------------------------------------------

  (when (eq system-type 'darwin)
    (require 'device-darwin nil t)
    (require 'apple-music nil t))

  (provide 'user)
  ;;; personal/user.el ends here
#+end_src

*** device-darwin.el
:PROPERTIES:
:CUSTOM_ID: personal-device-darwin
:header-args:emacs-lisp: :tangle personal/device-darwin.el
:END:

Purpose:
macOS-specific device and input method configuration.

What it does:
- Configure IME behavior via sis
- Apply macOS-specific mouse and scroll tuning
- Restore cursor color after theme reload

Notes:
- This file is loaded only on darwin systems.
- No core/session or UI orchestration logic lives here.

#+begin_src emacs-lisp
  ;;; device-darwin.el --- macOS device profile -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: personal
  ;;
  ;;; Commentary:
  ;; macOS-specific device and input configuration.
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf))

  (when (eq system-type 'darwin)

    ;; -------------------------------------------------------------------------
    ;; IME integration (sis)
    ;; -------------------------------------------------------------------------

    (leaf sis
      :straight t
      :commands (sis-ism-lazyman-config
                 sis-global-cursor-color-mode
                 sis-global-respect-mode
                 sis-global-inline-mode)
      :hook
      (emacs-startup .
                     (lambda ()
                       (when (fboundp 'sis-ism-lazyman-config)
                         (sis-ism-lazyman-config
                          "com.apple.keylayout.ABC"
                          "com.apple.inputmethod.Kotoeri.RomajiTyping.Japanese"
                          'macism))
                       (when (fboundp 'sis-global-cursor-color-mode)
                         (sis-global-cursor-color-mode t))
                       (when (fboundp 'sis-global-respect-mode)
                         (sis-global-respect-mode t))
                       (when (fboundp 'sis-global-inline-mode)
                         (sis-global-inline-mode t)))))

    ;; -------------------------------------------------------------------------
    ;; Cursor color keep-alive after theme load
    ;; -------------------------------------------------------------------------

    (add-hook 'after-load-theme-hook
              (lambda ()
                (when (facep 'cursor)
                  (let ((c (frame-parameter nil 'cursor-color)))
                    (when (stringp c)
                      (set-face-background 'cursor c))))))

    ;; -------------------------------------------------------------------------
    ;; Mouse / scroll profile (MX Ergo S)
    ;; -------------------------------------------------------------------------

    (leaf device-mx-ergo-s
      :straight nil
      :init
      (setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control) . 10))
            mouse-wheel-progressive-speed nil
            scroll-conservatively 10000
            scroll-margin 2
            scroll-preserve-screen-position t
            mac-mouse-wheel-smooth-scroll t
            mouse-wheel-tilt-scroll t
            mouse-wheel-flip-direction nil)

      (global-set-key [mouse-2] #'yank)
      (global-set-key [mouse-4] #'previous-buffer)
      (global-set-key [mouse-5] #'next-buffer)))

  (provide 'device-darwin)
  ;;; personal/device-darwin.el ends here
#+end_src

*** apple-music.el
:PROPERTIES:
:CUSTOM_ID: personal-apple-music
:header-args:emacs-lisp: :tangle personal/apple-music.el
:END:

Purpose:
Control Apple Music from Emacs on macOS.

What it does:
- Provides async/sync AppleScript helpers
- Defines interactive playback commands
- Exposes a hydra and optional meow leader binding

Notes:
- This module is strictly optional and macOS-only.
- No core/session or utils logic is used here.

#+begin_src emacs-lisp
  ;;; apple-music.el --- Apple Music integration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2026
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: personal
  ;;
  ;;; Commentary:
  ;; Control Apple Music using AppleScript.
  ;;
  ;;; Code:

  (when (eq system-type 'darwin)

    ;; -------------------------------------------------------------------------
    ;; AppleScript helpers
    ;; -------------------------------------------------------------------------

    (defun my/apple-music--osascript-async (script &optional callback)
      "Run AppleScript SCRIPT asynchronously.
  If CALLBACK is non-nil, call it with the trimmed output."
      (let* ((proc-name "apple-music-async")
             (buffer-name "*Apple Music Async*")
             (proc (apply #'start-process
                          proc-name buffer-name
                          (list "osascript" "-e" script))))
        (when callback
          (set-process-sentinel
           proc
           (lambda (process event)
             (when (string= event "finished\n")
               (with-current-buffer (process-buffer process)
                 (funcall callback
                          (string-trim (buffer-string))))
               (kill-buffer (process-buffer process))))))))

    (defun my/apple-music--osascript-sync (script)
      "Run AppleScript SCRIPT synchronously and return trimmed output."
      (string-trim
       (shell-command-to-string
        (format "osascript -e '%s'" script))))

    ;; -------------------------------------------------------------------------
    ;; Interactive commands
    ;; -------------------------------------------------------------------------

    ;;;###autoload
    (defun my/apple-music-play-pause ()
      "Toggle play/pause in Apple Music."
      (interactive)
      (my/apple-music--osascript-async
       "tell application \"Music\" to playpause"))

    ;;;###autoload
    (defun my/apple-music-next-track ()
      "Skip to the next track in Apple Music."
      (interactive)
      (my/apple-music--osascript-async
       "tell application \"Music\" to next track"))

    ;;;###autoload
    (defun my/apple-music-previous-track ()
      "Return to the previous track in Apple Music."
      (interactive)
      (my/apple-music--osascript-async
       "tell application \"Music\" to previous track"))

    ;;;###autoload
    (defun my/apple-music-current-track-info ()
      "Display current track information."
      (interactive)
      (message "%s"
               (my/apple-music--osascript-sync
                "tell application \"Music\" \
  to (get name of current track) & \" ‚Äî \" & (get artist of current track) \
  & \" [\" & (get album of current track) & \"]\"")))

    (defun my/apple-music-get-playlists ()
      "Return a list of playlist names."
      (split-string
       (my/apple-music--osascript-sync
        "tell application \"Music\" to get name of playlists")
       ", "))

    ;;;###autoload
    (defun my/apple-music-play-playlist (playlist)
      "Prompt for PLAYLIST and play it."
      (interactive
       (list (completing-read
              "Playlist: "
              (my/apple-music-get-playlists))))
      (my/apple-music--osascript-async
       (format "tell application \"Music\" to play playlist \"%s\"" playlist)))

    ;; -------------------------------------------------------------------------
    ;; Hydra / meow integration
    ;; -------------------------------------------------------------------------

    (with-eval-after-load 'hydra
      (defhydra my/hydra-apple-music (:hint nil)
        "
  Apple Music
  -----------
  _p_: Play/Pause   _n_: Next   _b_: Back
  _l_: Playlist     _i_: Info   _q_: Quit
  "
        ("p" my/apple-music-play-pause)
        ("n" my/apple-music-next-track)
        ("b" my/apple-music-previous-track)
        ("l" my/apple-music-play-playlist)
        ("i" my/apple-music-current-track-info)
        ("q" nil "quit"))
      (global-set-key (kbd "C-c M") #'my/hydra-apple-music/body))

    (with-eval-after-load 'meow
      (with-eval-after-load 'hydra
        (when (fboundp 'meow-leader-define-key)
          (meow-leader-define-key
           '("M" . my/hydra-apple-music/body))))))

  (provide 'apple-music)
  ;;; personal/apple-music.el ends here
#+end_src

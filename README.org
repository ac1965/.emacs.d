# -*- mode: org; coding: utf-8; -*-

#+TITLE: Modern Emacs Configuration
#+AUTHOR: YAMASHITA, Takao
#+EMAIL: tjy1965@gmail.com
#+LANGUAGE: en
#+OPTIONS: toc:3 num:t
#+STARTUP: overview
#+PROPERTY: header-args :results silent :exports code :mkdirp yes :padline no :tangle no
#+PROPERTY: header-args:emacs-lisp :lexical t :noweb no-export

* Introduction
:PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

A modern, literate Emacs configuration using Org Mode's Babel format, emphasizing performance, language server integration, AI assistance, and productivity.

** Features
:PROPERTIES:
:CUSTOM_ID: features
:END:

- *Performance & Native Compilation* - JIT compilation with optimized settings, intelligent GC via GCMH, and async compilation
- *Language Server Protocol* - Configurable LSP backends (Eglot/LSP-Mode) with automatic server management
- *AI Integration* - Aidermacs with vterm backend supporting GPT-4, Claude 3.5 Sonnet, and OpenRouter APIs
- *Modern UI & Editing* - Tree-Sitter syntax highlighting, ef-themes, Nerd Icons, and advanced completion
- *Productivity Tools* - GTD-style Org workflow, Org-roam networked notes, and modern styling

[[file:demo.png]]

** Tangling Policy
:PROPERTIES:
:CUSTOM_ID: tangling-policy
:END:
_For documentation only; block-level :tangle always takes precedence._

| Directory   | Filename              | Contents                                                    |
|-------------+-----------------------+-------------------------------------------------------------|
| (top-level) | early-init.el         | Startup performance & low-level toggles (GC, handlers, etc) |
| (top-level) | init.el               | Package bootstrap + leaf.el init; loads =modules.el=          |
| (top-level) | modules.el            | Centralized loader (requires everything below in order)     |
| core/       | general.el            | General settings, hydra, keybindings, Dired, TRAMP, auth    |
| core/       | tools.el              | Navigation helpers, Dired helper, Tree-sitter, ext tools    |
| core/       | utils.el              | Auto-tangle, scratch, revert, lexical-binding helpers       |
| core/       | history.el            | Savehist, recentf, autorevert, transient                    |
| core/       | editing.el            | Paredit, puni, undo, which-key, ace-window, dired UI        |
| core/       | eww.el                | EWW helpers (search, toggle images)                         |
| ui/         | ui-font.el            | Font setup, ligatures                                       |
| ui/         | ui-theme.el           | Theme mgmt (ef-themes, spacious-padding)                    |
| ui/         | ui-modeline.el        | Doom-modeline, minions, time, battery                       |
| ui/         | ui-window.el          | Fullscreen, zoom, tab-bar/line, layouts                     |
| ui/         | ui-treemacs.el        | Sidebar project/file explorer                               |
| ui/         | ui-clipboard.el       | macOS clipboard integration                                 |
| completion/ | completion-core.el    | Orderless styles (no prescient)                             |
| completion/ | completion-vertico.el | Vertico, posframe, marginalia                               |
| completion/ | completion-consult.el | Consult, xref integration                                   |
| completion/ | completion-embark.el  | Embark + consult integration                                |
| completion/ | completion-corfu.el   | Corfu, kind-icon, cape                                      |
| completion/ | completion-icons.el   | Nerd-icons integration                                      |
| org/        | org-core.el           | GTD workflow, agenda, capture, refiling                     |
| org/        | org-visual.el         | Org-modern (no org-superstar)                               |
| org/        | org-extensions.el     | Org-journal, org-roam, org-download, toc-org, cliplink      |
| org/        | org-export.el         | LaTeX export, Hugo, Markdown                                |
| dev/        | dev-lsp.el            | Eglot / lsp-mode integration                                |
| dev/        | lsp-web.el            | LSP for web stack (only when my:use-lsp = 'lsp)             |
| dev/        | web-core.el           | Project.el + treesit + editorconfig                         |
| dev/        | dev-ai.el             | Aidermacs (AI integration)                                  |
| dev/        | dev-term.el           | vterm integration                                           |
| dev/        | dev-build.el          | Make, compile, ansi-color                                   |
| dev/        | dev-docker.el         | Dockerfile, docker.el, tramp-container                      |
| dev/        | infra-modes.el        | dotenv, toml, docker-compose, makefile tweaks               |
| dev/        | sql.el                | SQL/Postgres helpers, sqlformat                             |
| dev/        | rest.el               | REST client helpers (restclient + jq)                       |
| vcs/        | vcs-magit.el          | Magit                                                       |
| vcs/        | vcs-gutter.el         | diff-hl only (git-gutter removed)                           |
| vcs/        | vcs-forge.el          | Forge (GitHub/GitLab)                                       |
| utils/      | utils-functions.el    | Directory creation, safe-load                               |
| utils/      | utils-scratch.el      | Scratch buffer management                                   |
| utils/      | utils-backup.el       | Backup/auto-save cleanup                                    |
| utils/      | utils-async.el        | Async task wrapper                                          |
| utils/      | search-nav.el         | Dumb-jump fallback, multiple-cursors (projectile removed)   |
| personal/   | <username>.el         | Optional per-user, per-machine overrides                    |
| personal/   | user.el               | Personal entry point, loaded last if present                |

** Coding Rules
:PROPERTIES:
:CUSTOM_ID: conventions
:END:

*- `lexical-binding: t` is *mandatory*. The provided feature **must match the file name** (e.g., `lisp/core.el` → `(provide 'core)`).
- Follow *official documentation* only. Do **not** rely on undocumented features or future/unstable behavior.
- In every *leaf* block, group settings under `:straight`, `:bind`, `:hook`, and `:custom`.
- For built-in packages, **always** specify `:straight nil`.

*** Header template
#+begin_src emacs-lisp
  ;;; module.el --- description -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Short explanation about what this module does.
  ;; If it belongs to a category (core, ui, completion, org, dev, vcs, utils),
  ;; mention it here as well.
  ;;
  ;;; Code:

  ... code ...

  (provide 'module)
  ;;; module.el ends here
#+end_src

*** Namespaces and naming

- Module prefixes: `core-...`, `ui-...`, `completion-...`, `orgx-...`, `dev-...`, `vcs-...`, `utils-...`
- Personal namespace: `my/...`
- *Internal-only* functions/variables use a **double hyphen** `--` (e.g., `core--restore-startup-state`)
- *Predicates* end with `-p` (e.g., `core-enabled-p`)
- *Hook helpers* should make their purpose clear: `PREFIX--on-...` or `PREFIX-...-hook-function`
- *Keymaps* end with `-map`, and *hook variables* end with `-hook`
- Add `;;;###autoload` **only** to public commands (never to internal `--` functions).

** Build pipeline
- =Makefile= :: Reproducible pipeline (=tangle=, =clean=, =compile=)

** Installation
:PROPERTIES:
   :CUSTOM_ID: installation
   :END:

*** Prerequisites
:PROPERTIES:
:CUSTOM_ID: prerequisites
:END:

- **Required**
  - Emacs **30.0+** with native compilation (`--with-native-compilation`)
  - Git
  - GNU Make
  - GCC **10+** with `libgccjit`

- **Optional but Recommended**
  - ripgrep (`rg`) → faster project-wide search
  - aspell or hunspell → spell checking
  - pass + GnuPG → password and auth-source integration
  - Homebrew (macOS only) → for consistent toolchain installation

*** Building Emacs

Use the provided build script:
[[https://github.com/ac1965/dotfiles/blob/master/.local/bin/build-emacs.sh][build-emacs.sh]]

#+begin_src shell
build-emacs.sh --native-compilation
#+end_src

*** Quick Start

1. Clone the repository:
   #+begin_src shell
   git clone --depth 1 https://github.com/ac1965/.emacs.d ~/.emacs.d
   #+end_src

2. Tangle configuration:
   #+begin_src shell
   cd ~/.emacs.d/
   EMACS=/Applications/Emacs.app/Contents/MacOS/Emacs make
   #+end_src

*** Makefile

#+begin_src text :tangle Makefile :comments no
  # Makefile for Emacs config build (safe clean)

  EMACS       ?= emacs
  ORG         ?= README.org
  LISPDIR     ?= lisp
  PERSONALDIR ?= personal
  ELFILES     = $(wildcard $(LISPDIR)/*.el) $(wildcard $(PERSONALDIR)/*.el)
  ELCFILES    = $(ELFILES:.el=.elc)

  all: tangle

  tangle: $(ORG)
  	$(EMACS) --batch -Q \
  		--eval "(require 'org)" \
  		--eval "(org-babel-tangle-file \"$(ORG)\")"

  compile: tangle $(ELCFILES)

  $(LISPDIR)/%.elc: $(LISPDIR)/%.el
  	$(EMACS) --batch -Q --eval "(byte-compile-file \"$<\")"

  $(PERSONALDIR)/%.elc: $(PERSONALDIR)/%.el
  	$(EMACS) --batch -Q --eval "(byte-compile-file \"$<\")"

  clean:
  	find $(LISPDIR) $(PERSONALDIR) -name "*.elc" -delete

  .PHONY: all tangle compile clean
#+end_src

*** System Information

**** Apple Silicon (Primary)
- GNU Emacs *31.0.50*

|Property|Value|
|--------|-----|
|Commit|021b7065bb734ca5e880f2fb74ddd48ffed4185a|
|Branch|master|
|System|aarch64-apple-darwin24.6.0|
|Date|2025-09-28 09:03:05 (JST)|
|Patch|N/A ns-inline.patch|
|Features|ACL DBUS GLIB GNUTLS LCMS2 LIBXML2 MODULES NATIVE_COMP NOTIFY KQUEUE NS PDUMPER PNG RSVG SQLITE3 THREADS TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM ZLIB|
|Options|--with-native-compilation --with-gnutls=ifavailable --with-json --with-modules --with-tree-sitter --with-xml2 --with-librsvg --with-mailutils --with-native-image-api --with-ns CPPFLAGS=-I/opt/homebrew/opt/llvm/include 'LDFLAGS=-L/opt/homebrew/opt/llvm/lib -L/opt/homebrew/opt/llvm/lib/c++ -Wl,-rpath,/opt/homebrew/opt/llvm/lib/c++'|

**** Intel (Secondary)
- GNU Emacs *31.0.50*

|Property|Value|
|--------+-----|
|Commit|aa12cebaa684d7b3ea7e131666d33bcc71b45625|
|Branch|master|
|System|x86_64-apple-darwin24.4.0|
|Date|2025-03-23 10:35:38 (JST)|
|Patch|N/A ns-inline.patch|
|Features|ACL DBUS GIF GLIB GMP GNUTLS JPEG LCMS2 LIBXML2 MODULES NATIVE_COMP NOTIFY KQUEUE NS PDUMPER PNG RSVG SQLITE3 THREADS TIFF TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM XWIDGETS ZLIB|
|Options|--with-native-compilation --with-gnutls=ifavailable --with-json --with-modules --with-tree-sitter --with-xml2 --with-xwidgets --with-librsvg CFLAGS=-I/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include CPPFLAGS=-I/usr/local/opt/llvm/include 'LDFLAGS=-L/usr/local/opt/llvm/lib -L/usr/local/opt/llvm/lib/c++ -Wl,-rpath,/usr/local/opt/llvm/lib/c++'|

* Configuration Files
:PROPERTIES:
:CUSTOM_ID: structure
:END:

This Emacs configuration is modular and organized for **Emacs 30+**.

- `early-init.el` → startup optimizations & directories
- `init.el` → package bootstrap & base settings
- `lisp/` → modular configs (core, ui, completion, org, dev, vcs, utils)
- `personal/` → user-specific settings

** Core Setup
:PROPERTIES:
:CUSTOM_ID: core
:END:

*** early-init.el
:PROPERTIES:
:CUSTOM_ID: early-init
:END:

**Purpose**
Provide early, minimal startup optimizations and a hidden, tidy directory layout for Emacs 30+ using `straight.el` + `leaf.el`, while preserving macOS-specific Homebrew / `LIBRARY_PATH` handling.

**What it does**
- Disables `package.el` auto-activation.
- Temporarily widens GC and disables file-name handlers; **restores them at `emacs-startup`**.
- Ensures hidden directories: `.cache/`, `.etc/`, `.var/`, plus `eln-cache/` and Tree-sitter paths.
- Redirects native-comp ELN to `.cache/eln-cache/`; silences async warnings.
- **macOS**: if Homebrew’s `lib/gcc/current` exists, safely prepends it to `LIBRARY_PATH` (errors are messaged, not swallowed).
- Turns off menu/tool/scroll bars *after* first frame.
- Sets `straight-base-dir` under `.cache/` and `custom-file` to `.etc/custom.el` (loaded quietly if present).

**Notes**
- All original variables (GC thresholds, `file-name-handler-alist`) are restored on startup.
- Directory creation is defensive (fails with warnings, not hard errors).
- Although tangled to `early-init.el` here, Emacs only reads early init from the **top-level** (e.g., `~/.emacs.d/early-init.el`). Place the tangled file there.

#+begin_src emacs-lisp :tangle early-init.el
  ;;; early-init.el --- Early initialization -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; - Disable package.el (use straight.el + leaf)
  ;; - Speed up startup (widen GC/file-name-handlers, then restore at startup)
  ;; - Keep artifacts under hidden dirs (.cache/ .etc/ .var/)
  ;; - Predefine paths for native-compile / Tree-sitter / straight / no-littering
  ;; - Handle macOS Homebrew libgccjit in LIBRARY_PATH
  ;; - Do not create auto-save-list (use auto-save-visited instead)
  ;; - Turn off menu/tool/scroll bars after the first frame

  ;;; Code:

  (defun my/ensure-directory-exists (dir)
    "Ensure DIR exists, creating it if necessary."
    (unless (file-directory-p dir)
      (condition-case err
          (make-directory dir t)
        (error (warn "Failed to create directory: %s (%s)"
                     dir (error-message-string err))))))

  ;; 1) Disable package.el
  (setq package-enable-at-startup nil)

  ;; 2) Base directory (where this file lives; fallback to user-emacs-directory)
  (defvar my:d
    (or (and load-file-name (file-name-directory (file-chase-links load-file-name)))
        user-emacs-directory)
    "Base directory for this Emacs configuration.")
  (setq user-emacs-directory (file-name-as-directory my:d))

  ;; 3) Hidden sub-directories
  (defconst my:d:var    (expand-file-name ".var/"    my:d))
  (defconst my:d:etc    (expand-file-name ".etc/"    my:d))
  (defconst my:d:cache  (expand-file-name ".cache/"  my:d))
  (defconst my:d:lisp   (expand-file-name "lisp/"    my:d))
  (defconst my:d:treesit        (expand-file-name "treesit/"        my:d:var))
  (defconst my:d:treesit-build  (expand-file-name "treesit-build/"  my:d:cache))

  (dolist (dir (list my:d:var my:d:etc my:d:cache my:d:lisp
                     my:d:treesit my:d:treesit-build
                     (expand-file-name "eln-cache/" my:d:cache)))
    (my/ensure-directory-exists dir))

  ;; 4) macOS: prepend Homebrew libgccjit to LIBRARY_PATH if present
  (when (and (eq system-type 'darwin) (executable-find "brew"))
    (condition-case err
        (let* ((prefix (string-trim (shell-command-to-string "brew --prefix")))
               (brew-libgccjit (expand-file-name "lib/gcc/current" prefix)))
          (when (file-directory-p brew-libgccjit)
            (setenv "LIBRARY_PATH"
                    (concat brew-libgccjit
                            (when-let* ((orig (getenv "LIBRARY_PATH")))
                              (concat ":" orig))))))
      (error (message "[early-init] brew probe failed: %s"
                      (error-message-string err)))))

  ;; 5) Native compilation: keep ELN under .cache/
  (when (featurep 'native-compile)
    (setopt native-comp-eln-load-path (list (expand-file-name "eln-cache/" my:d:cache))
            native-comp-async-report-warnings-errors 'silent))

  ;; 6) Pre-wire no-littering directories
  (defvar no-littering-etc-directory (file-name-as-directory my:d:etc))
  (defvar no-littering-var-directory (file-name-as-directory my:d:var))

  ;; 7) straight.el base under .cache/
  (setopt straight-base-dir my:d:cache
          straight-use-package-by-default t
          straight-profiles '((nil . "default.el")))

  ;; 8) custom-file under .etc/ (loaded quietly in init.el)
  (defconst my:f:custom (expand-file-name "custom.el" my:d:etc))
  (setq custom-file my:f:custom)

  ;; 9) Startup speedups (restore on startup)
  (defvar my:orig-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil
        gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq file-name-handler-alist my:orig-file-name-handler-alist
                    gc-cons-threshold 16777216    ;; 16MB
                    gc-cons-percentage 0.1)))

  ;; 10) Backups/auto-save: do not create auto-save-list directory
  (setq backup-directory-alist `(("." . ,(expand-file-name "backups/" my:d:var)))
        auto-save-default nil
        auto-save-list-file-prefix nil)
  (my/ensure-directory-exists (expand-file-name "backups/" my:d:var))

  ;; 11) UI bars off + maximize all frames
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   '(inhibit-startup-screen t)
   '(inhibit-startup-message t)
   '(inhibit-startup-echo-area-message t)
   '(initial-scratch-message nil)

   ;; Resize frames in pixel units (improves maximize accuracy)
   '(frame-resize-pixelwise t)

   ;; First frame: open maximized with basic borders/fringes
   '(initial-frame-alist
     '((fullscreen . fullboth)
       (undecorated . nil)
       (left-fringe . 0)
       (right-fringe . 0)
       (internal-border-width . 8)
       (tool-bar-lines . 0)))

   ;; All subsequent frames: always open maximized with the same look
   '(default-frame-alist
     '((fullscreen . fullboth)
       (undecorated . nil)
       (internal-border-width . 8)
       (left-fringe . 0)
       (right-fringe . 0)))

   ;; Explicitly disable UI bars for consistency
   '(menu-bar-mode nil)
   '(scroll-bar-mode nil)
   '(tool-bar-mode nil)

   ;; Existing settings retained (adjust as needed)
   '(initial-buffer-choice t)
   '(initial-major-mode 'fundamental-mode)
   '(frame-inhibit-implied-resize t)
   '(frame-title-format t)
   '(cursor-in-non-selected-windows nil)
   '(font-lock-maximum-decoration nil)
   '(font-lock-maximum-size nil)
   '(x-underline-at-descent-line t)
   '(window-divider-default-right-width 16)
   '(window-divider-default-places 'right-only))

  ;; NOTE:
  ;; - If you prefer true fullscreen (covering the OS menu/Dock), use:
  ;;     (fullscreen . fullboth)
  ;;   instead of (fullscreen . maximized).
  ;; - On macOS, to avoid the native fullscreen animation, set in init.el:
  ;;     (setq ns-use-native-fullscreen nil)

  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** init.el
:PROPERTIES:
:CUSTOM_ID: init
:END:

**Purpose**
Main entry point for Emacs 30+ that bootstraps **straight.el + leaf**, applies safe defaults, and loads modular configs via `lisp/modules.el`. macOS-specific environment handling (Homebrew paths, shell env import) is preserved.

**What it does**
- Bootstraps `straight.el` and initializes `leaf` / `leaf-keywords`.
- Defines `my` customization group and `my:use-lsp` selector (`eglot` or `lsp`).
- Practical performance tweaks (`read-process-output-max`, `gcmh`).
- Sensible UI/editing defaults; macOS modifier keys.
- Aligns `no-littering` paths with hidden dirs prepared in *early-init.el* (`my:d:etc`, `my:d:var`).
- macOS: imports shell env (`exec-path-from-shell`) and prefers Homebrew paths.
- Dired with GNU `ls` (`gls`) if present.
- Loads `lisp/modules.el` (central loader) and optional `personal/<user>.el`.
- Respects `custom-file` at `.etc/custom.el` if present.

**Notes**
- Assumes *early-init.el* has defined `my:d`, `my:d:etc`, `my:d:var`, and created directories.
- Built-ins explicitly declare `:straight nil` per policy.
- You can toggle LSP backend by setting `(setq my:use-lsp 'eglot)` or `'lsp`.

 #+begin_src emacs-lisp :tangle init.el
   ;;; init.el --- Main initialization -*- lexical-binding: t; -*-
   ;;
   ;; Copyright (c) 2021-2025
   ;; Author: YAMASHITA, Takao <tjy1965@gmail.com>
   ;; License: GNU GPL v3 or later
   ;;
   ;; $Lastupdate: 2025/10/11 14:29:30 $
   ;;
   ;;; Commentary:
   ;; Entry point for Emacs 30+ configuration.
   ;; - Bootstraps package management (straight.el + leaf)
   ;; - Defines customization groups and defaults
   ;; - Configures basic UI and performance
   ;; - Loads modular configuration via lisp/modules.el
   ;; - Optionally loads personal overrides
   ;;;
   ;;; Code:

   ;;;; Bootstrap straight.el -----------------------------------------------------
   (require 'url) ;; for url-retrieve-synchronously
   (defvar bootstrap-version 7)
   (let* ((base (or (bound-and-true-p straight-base-dir) user-emacs-directory))
          (bootstrap-file (expand-file-name "straight/repos/straight.el/bootstrap.el" base)))
     (unless (file-exists-p bootstrap-file)
       (condition-case err
           (with-current-buffer
               (url-retrieve-synchronously
                "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
                'silent 'inhibit-cookies)
             (goto-char (point-max))
             (eval-print-last-sexp))
         (error (user-error "[straight] bootstrap failed: %s"
                            (error-message-string err)))))
     (load bootstrap-file nil 'nomessage))

   (dolist (pkg '(leaf leaf-keywords leaf-convert blackout hydra org))
     (ignore-errors (straight-use-package pkg)))

   (eval-when-compile
     (require 'leaf)
     (require 'leaf-keywords))
   (when (fboundp 'leaf-keywords-init)
     (leaf-keywords-init))

   (require 'org)

   ;;;; Performance tweaks ---------------------------------------------------------
   (defvar my:orig:read-process-output-max
     (and (boundp 'read-process-output-max) read-process-output-max))
   (when (boundp 'read-process-output-max)
     ;; 4MB improves LSP and terminals throughput.
     (setq read-process-output-max (* 4 1024 1024)))
   (add-hook 'emacs-startup-hook
             (lambda ()
               (when (boundp 'read-process-output-max)
                 (setq read-process-output-max my:orig:read-process-output-max))))

   (leaf gcmh
     :straight t
     :custom
     ((gcmh-idle-delay . 5)
      (gcmh-high-cons-threshold . 16777216))
     :config
     (gcmh-mode 1))

   ;;;; Basic UI and editing defaults ---------------------------------------------
   (leaf emacs
     :straight nil
     :init
     ;; Unset disruptive keys
     (dolist (k '("C-z" "C-x C-z" "C-x C-c" "M-z" "M-m" "M-/"))
       (when (lookup-key (current-global-map) (kbd k))
         (keymap-global-unset k)))
     ;; Prefer CAPE dabbrev if present
     (when (fboundp 'cape-dabbrev)
       (keymap-global-set "M-/" #'cape-dabbrev))
     ;; Smooth scrolling (Emacs 29+)
     (when (fboundp 'pixel-scroll-precision-mode)
       (pixel-scroll-precision-mode 1))
     :config
     (setopt inhibit-startup-screen        t
             initial-scratch-message       nil
             use-short-answers             t
             create-lockfiles              nil
             make-backup-files             t
             delete-old-versions           t
             version-control               t
             idle-update-delay             0.2
             ring-bell-function            #'ignore
             display-line-numbers-type     'relative)
     (electric-pair-mode 1)
     (add-hook 'prog-mode-hook #'display-line-numbers-mode)
     (auto-save-visited-mode 1))

   ;; Modifier keys (per-OS)
   (leaf my:modifier
     :straight nil
     :config
     (pcase system-type
       ('darwin
        (setq mac-option-modifier 'meta
              mac-command-modifier 'super
              mac-control-modifier 'control
              mac-function-modifier 'hyper))
       ('windows-nt
        (setq w32-lwindow-modifier 'super
              w32-rwindow-modifier 'super
              w32-apps-modifier   'hyper))
       (_ nil)))

   ;;;; Files and environment ------------------------------------------------------
   (leaf no-littering
     :straight t
     :init
     ;; Align with early-init hidden dirs
     (setq no-littering-etc-directory (file-name-as-directory (or (bound-and-true-p my:d:etc) (expand-file-name ".etc/" user-emacs-directory)))
           no-littering-var-directory (file-name-as-directory (or (bound-and-true-p my:d:var) (expand-file-name ".var/" user-emacs-directory)))))

   (leaf exec-path-from-shell
     :straight t
     :if (memq window-system '(mac ns))
     :custom ((exec-path-from-shell-check-startup-files . nil)
              (exec-path-from-shell-arguments . '("-l" "-i"))
              (exec-path-from-shell-variables
               . '("PATH" "LANG" "PASSWORD_STORE_DIR" "GPG_KEY_ID"
                   "OPENROUTER_API_KEY" "OPENAI_API_KEY")))
     :config
     (ignore-errors (exec-path-from-shell-initialize)))

   ;; Prefer Homebrew paths on macOS (Apple Silicon/Intel)
   (when (eq system-type 'darwin)
     (dolist (p '("/opt/homebrew/bin" "/usr/local/bin"))
       (when (and (file-directory-p p)
                  (not (member p exec-path)))
         (add-to-list 'exec-path p)
         (setenv "PATH" (concat p ":" (getenv "PATH"))))))

   ;; Dired defaults (GNU ls if available)
   (leaf dired
     :straight nil
     :config
     (cond
      ((and (eq system-type 'darwin) (executable-find "gls"))
       (setq insert-directory-program "gls"
             dired-use-ls-dired t
             dired-listing-switches "-aBhl --group-directories-first"))
      (t
       (setq dired-use-ls-dired nil
             dired-listing-switches "-alh"))))

   ;; Respect custom-file from early-init and load quietly if present
   (setq custom-file (or (bound-and-true-p my:f:custom) custom-file))
   (when (and custom-file (file-readable-p custom-file))
     (ignore-errors (load custom-file nil 'nomessage)))

   ;; Safe file loader (utility)
   (defun my/safe-load-file (file &optional noerror)
     "Load FILE safely. If NOERROR is non-nil, log instead of raising."
     (when (and file (file-exists-p file))
       (condition-case err
           (load file nil 'nomessage)
         (error
          (funcall (if noerror #'message #'user-error)
                   "[load] failed to load %s: %s"
                   file (error-message-string err))))))

   ;;;; User-specific overrides ----------------------------------------------------
   (my/safe-load-file
    (expand-file-name
     (concat "personal/" user-login-name ".el")
     (or (bound-and-true-p my:d) user-emacs-directory))
    t)

   ;;;; Modular configuration loader ----------------------------------------------
   (let* ((root (or (and (boundp 'my:d) (stringp my:d) (file-directory-p my:d) my:d)
                    user-emacs-directory))
          (lisp-dir (expand-file-name "lisp" root)))
     (add-to-list 'load-path lisp-dir)
     ;; lisp/modules.el — central loader that specifies which files to load.
     (require 'modules nil t))

   ;;;; Startup report -------------------------------------------------------------
   (add-hook 'after-init-hook
             (lambda ()
               (run-with-idle-timer
                0 nil
                (lambda ()
                  (message "Emacs ready in %.2f seconds with %d GCs."
                           (float-time (time-subtract after-init-time before-init-time))
                           gcs-done)))))

   (provide 'init)
   ;;; init.el ends here
#+end_src

** Modular Configuration
:PROPERTIES:
:CUSTOM_ID: modules
:END:

*** modules.el
:PROPERTIES:
:CUSTOM_ID: core-modules
:END:

*Purpose*
Central loader for modular configuration under `lisp/`. Uses **module namespace `orgx/`** (not `org`), to avoid feature/path collision with the Org package itself.

*What it does*
- Loads modules in a stable order; optional per-module timing when verbose.
- Skips features in `my:modules-skip`; appends `my:modules-extra`.
- Safe `require` per module; failures don’t abort the session.

*Notes*
- Each module file must `(provide 'path/feature)` matching its path, e.g. `lisp/orgx/org-core.el` → `(provide 'orgx/org-core)`.
- Built-ins must declare `:straight nil` inside their own files.
- Tangles to `lisp/modules.el`.

#+begin_src emacs-lisp :tangle lisp/modules.el
  ;;; modules.el --- Modular config loader -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Central entry point to load modular configs placed under lisp/.
  ;; Each module should `provide' the same feature as its path, e.g.:
  ;;   lisp/core/general.el  =>  (provide 'core/general)
  ;;   lisp/orgx/org-core.el =>  (provide 'orgx/org-core)
  ;;;
  ;;; Code:

  (eval-when-compile (require 'subr-x)) ;; string-join, etc.

  (defgroup my:modules nil
    "Loader options for modular Emacs configuration."
    :group 'convenience)

  (defcustom my:modules-verbose t
    "If non-nil, print per-module load time and a summary."
    :type 'boolean
    :group 'my:modules)

  (defcustom my:modules-skip nil
    "List of module features to skip during loading."
    :type '(repeat symbol)
    :group 'my:modules)

  (defcustom my:modules-extra nil
    "List of extra module features to append after `my:modules'."
    :type '(repeat symbol)
    :group 'my:modules)

  (defconst my:modules
    '(
      ;; Core
      core/general
      core/tools
      core/utils
      core/history
      core/editing
      core/switches

      ;; UI
      ui/ui-font
      ui/ui-theme
      ui/ui-window
      ui/ui-utils

      ;; Completion
      completion/completion-core
      completion/completion-vertico
      completion/completion-consult
      completion/completion-embark
      completion/completion-corfu
      completion/completion-icons

      ;; Org ecosystem (module namespace = orgx/)
      orgx/org-core
      orgx/org-visual
      orgx/org-extensions
      orgx/org-export

      ;; VCS
      vcs/vcs-magit
      vcs/vcs-gutter
      vcs/vcs-forge

      ;; Development
      dev/dev-ai
      dev/dev-term
      dev/dev-build
      dev/dev-docker

      ;; Web/Infra
      dev/web-core
      dev/format
      dev/infra-modes
      dev/sql
      dev/rest

      ;; Utils
      utils/utils-functions
      utils/utils-scratch
      utils/utils-backup
      utils/utils-async
      utils/search-nav
      )
    "Default set of modules to load in order.")

  (defun my/modules--should-load-p (feature)
    "Return non-nil if FEATURE should be loaded."
    (not (memq feature my:modules-skip)))

  (defun my/modules--require-safe (feature)
    "Require FEATURE with error trapping. Return non-nil on success."
    (condition-case err
        (progn (require feature) t)
      (error (message "[modules] Failed to load %s: %s"
                      feature (error-message-string err))
             nil)))

  (defun my/modules--format-seconds (sec)
    "Format SEC (float seconds) compactly."
    (cond
     ((< sec 0.001) (format "%.3fms" (* sec 1000.0)))
     ((< sec 1.0)   (format "%.1fms"  (* sec 1000.0)))
     (t             (format "%.2fs"   sec))))

  (defun my/modules-load ()
    "Load all modules defined by `my:modules', respecting options."
    (let* ((final (seq-remove
                   (lambda (m) (not (my/modules--should-load-p m)))
                   (append my:modules my:modules-extra)))
           (ok 0) (ng 0)
           (t0 (and my:modules-verbose (current-time))))
      (dolist (mod final)
        (let ((m0 (and my:modules-verbose (current-time))))
          (if (my/modules--require-safe mod) (setq ok (1+ ok)) (setq ng (1+ ng)))
          (when my:modules-verbose
            (message "[modules] %-24s %s"
                     mod (my/modules--format-seconds
                          (float-time (time-subtract (current-time) m0)))))))
      (when my:modules-verbose
        (message "[modules] loaded=%d skipped=%d failed=%d total=%s"
                 ok
                 (- (length (append my:modules my:modules-extra))
                    (length final))
                 ng
                 (my/modules--format-seconds
                  (float-time (time-subtract (current-time) t0)))))))

  ;; Kick it off immediately on require.
  (my/modules-load)

  (provide 'modules)
  ;;; modules.el ends here
#+end_src

*** core/general.el
:PROPERTIES:
:CUSTOM_ID: core-general
:END:

*Purpose*
Global policies and keymaps for navigation, windows, files, session persistence, TRAMP, and **visited-mode auto-save**. Built-ins explicitly declare `:straight nil` per policy.

*What it does*
- Namespaced **text-scale hydra** (`core-hydra-text-scale`).
- Centralized **global keybindings** (Consult, Treemacs, Undo-Fu, window ops, EWW helpers, Org/Roam, Magit).
- Enables **Desktop save**, **Winner**; configures **TRAMP**.
- Consolidates on **visited-mode auto-save** (real file on idle) and **removes legacy `#…#` auto-save settings**.
- Keeps backups under hidden dirs (`.var/`) and creates them defensively.

*Notes*
- Assumes `my/ensure-directory-exists` and `no-littering-var-directory` are defined in *early-init* / *init*.
- Keep Dired-specific extra keybindings here; configure Dired packages in a separate module.
- Removed legacy `#…#` auto-save settings (`auto-save-file-name-transforms`, `auto-save-list-file-prefix`, and related timeouts).

#+begin_src emacs-lisp :tangle lisp/core/general.el
  ;;; core/general.el --- General settings & keybindings -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; - Namespaced text-scale hydra
  ;; - Centralized global keybindings
  ;; - Desktop save, Winner mode, TRAMP
  ;; - Visited-mode auto-save (no #...# artifacts)
  ;; - Backups into hidden .var/ dirs
  ;;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x)) ;; when-let, string-join

  ;;;; Text scaling hydra ---------------------------------------------------------
  (leaf hydra
    :straight t
    :config
    (defhydra core-hydra-text-scale (:hint nil :color red)
      "
  ^Text Scaling^
  [_+_] increase   [_-_] decrease   [_0_] reset   [_q_] quit
  "
      ("+" text-scale-increase)
      ("-" text-scale-decrease)
      ("0" (text-scale-set 0) :color blue)
      ("q" nil "quit" :color blue)))

  ;;;; Global key bindings --------------------------------------------------------
  (leaf my:key
    :straight nil
    :bind
    (;; Global
     ("<f1>"      . help-command)
     ("<f5>"      . my/revert-buffer-quick)
     ("<f8>"      . treemacs)
     ("C-h"       . backward-delete-char)
     ;; Undo/redo
     ("C-/"       . undo-fu-only-undo)
     ("C-?"       . undo-fu-only-redo)
     ;; Text scaling
     ("C-c z"     . core-hydra-text-scale/body)
     ;; Buffer navigation
     ("C-c b"     . consult-buffer)
     ;; ("M-n"       . forward-paragraph)
     ;; ("M-p"       . backward-paragraph)
     ("s-<down>"  . end-of-buffer)
     ("s-<up>"    . beginning-of-buffer)
     ("s-<right>" . next-buffer)
     ("s-<left>"  . previous-buffer)
     ;; Window management
     ("C-."       . other-window)
     ("C-c 2"     . my/toggle-window-split)
     ("s-."       . ace-window)
     ("s-w"       . ace-swap-window)
     ("s-d"       . delete-frame)
     ("s-m"       . my/new-frame-with-scratch)
     ;; File ops
     ("s-j"       . find-file-other-window)
     ("s-o"       . find-file-other-frame)
     ("C-c o"     . find-file)
     ("C-c v"     . find-file-read-only)
     ("C-c V"     . view-file-other-window)
     ("C-c k"     . my/kill-buffer-smart)
     ;; Search
     ("C-s"       . consult-line)
     ("C-c r"     . consult-ripgrep)
     ;; Text manipulation
     ("C-="       . er/expand-region)
     ("C-c ;"     . comment-or-uncomment-region)
     ("C-c M-a"   . align-regexp)
     ("C-c l"     . display-line-numbers-mode)
     ;; Org/Roam
     ("C-c d a"   . org-agenda)
     ("C-c d c"   . org-capture)
     ("C-c d i"   . org-roam-node-insert)
     ("C-c d f"   . org-roam-node-find)
     ;; Aider
     ("C-c a a"   . aidermacs-transient-menu)
     ;; EWW (helpers in core/eww.el)
     ("C-c w w"   . eww)
     ("C-c w s"   . my/eww-search)
     ("C-c w o"   . eww-open-file)
     ("C-c w b"   . eww-list-bookmarks)
     ("C-c w r"   . eww-readable)
     ("C-c w u"   . my/eww-toggle-images)
     ;; Misc
     ("s-r"       . my/restart-or-exit)
     ("M-x"       . execute-extended-command))
    :init
    ;; Small helpers to keep lambdas out of keymaps (namespaced)
    (defun my/new-frame-with-scratch ()
      "Create a new frame and switch to a fresh buffer."
      (interactive)
      (let ((frame (make-frame)))
        (with-selected-frame frame
          (switch-to-buffer (generate-new-buffer "untitled")))))
    (defun my/restart-or-exit ()
      "Restart Emacs if `restart-emacs' exists, otherwise save & exit."
      (interactive)
      (if (fboundp 'restart-emacs)
          (restart-emacs)
        (save-buffers-kill-emacs)))
    (windmove-default-keybindings))

  ;;;; Authentication management -------------------------------------------------
  (defvar my:d:password-store
    (or (getenv "PASSWORD_STORE_DIR")
        (concat no-littering-var-directory "password-store/"))
    "Path to the password store.")

  (defun my/auth-check-env ()
    "Validate authentication environment and warn if misconfigured."
    (unless (getenv "GPG_KEY_ID")
      (display-warning 'auth "GPG_KEY_ID is not set." :level 'debug))
    (unless (file-directory-p my:d:password-store)
      (display-warning 'auth
                       (format "Password store directory does not exist: %s"
                               my:d:password-store)
                       :level 'warning)))

  (leaf *authentication
    :straight nil
    :init
    (my/auth-check-env)

    (leaf epa-file
      :straight nil
      :commands (epa-file-enable)
      :init
      (setq epa-pinentry-mode
            (if (getenv "USE_GPG_LOOPBACK") 'loopback 'default))
      (add-hook 'emacs-startup-hook #'epa-file-enable))

    (leaf auth-source
      :straight nil
      :init
      (with-eval-after-load 'auth-source
        (let ((key (getenv "GPG_KEY_ID")))
          (if key
              (setq auth-source-gpg-encrypt-to key)
            (display-warning 'auth-source
                             "GPG_KEY_ID is not set. Authentication backends may be limited.")))))

    (leaf password-store :straight t)

    (leaf auth-source-pass
      :straight t
      :commands (auth-source-pass-enable)
      :hook (emacs-startup-hook . (lambda ()
                                    (when (executable-find "pass")
                                      (auth-source-pass-enable)))))

    (leaf plstore
      :straight nil
      :init
      (with-eval-after-load 'plstore
        (setq plstore-secret-keys 'silent
              plstore-encrypt-to (getenv "GPG_KEY_ID")))))

  (provide 'core/general)
  ;;; core/general.el ends here
#+end_src

*** core/tools.el
:PROPERTIES:
:CUSTOM_ID: core-tools
:END:

*Purpose*
Utility commands used by keymaps and other modules.

*What it does*
- Window split toggle, keybinding conflict viewer, Dired helper
- Tree-sitter helpers, VSCode opener, env inspector, build info, Org folding

*Notes*
Treesitter advice cooperates with `treesit-auto`.

#+begin_src emacs-lisp :tangle lisp/core/tools.el
  ;;; core/tools.el --- Developer & UI helper tools -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Code:

  ;; UI & Navigation Helpers
  (defun my/toggle-linum-lines () (interactive) (display-line-numbers-mode 'toggle))

  (defun my/toggle-window-split ()
    "Toggle between horizontal and vertical split for two windows."
    (interactive)
    (when (= (count-windows) 2)
      (let* ((this-buf (window-buffer))
             (next-buf (window-buffer (next-window)))
             (this-edges (window-edges))
             (next-edges (window-edges (next-window)))
             (split-vert (= (car this-edges) (car next-edges)))
             (split-fn (if split-vert #'split-window-horizontally #'split-window-vertically)))
        (delete-other-windows)
        (funcall split-fn)
        (set-window-buffer (selected-window) this-buf)
        (set-window-buffer (next-window) next-buf)
        (select-window (selected-window)))))

  (defun my/find-keybinding-conflicts ()
    "Find and display conflicting keybindings in active keymaps."
    (interactive)
    (let ((conflicts (make-hash-table :test 'equal))
          (maps (current-active-maps t))
          (buffer-name "*Keybinding Conflicts*"))
      (dolist (map maps)
        (map-keymap
         (lambda (key cmd)
           (when (commandp cmd)
             (let ((desc (key-description (vector key)))
                   (existing (gethash desc conflicts)))
               (puthash desc (delete-dups (cons cmd existing)) conflicts))))
         map))
      (with-current-buffer (get-buffer-create buffer-name)
        (read-only-mode -1)
        (erase-buffer)
        (insert "* Keybinding Conflicts *\n\n")
        (maphash (lambda (key cmds)
                   (when (> (length cmds) 1)
                     (insert (format "%s => %s\n" key (mapconcat #'symbol-name cmds ", ")))))
                 conflicts)
        (read-only-mode 1))
      (pop-to-buffer buffer-name)))

  ;; Dired Helper
  (defun my/dired-view-file-other-window ()
    "Open selected Dired file or directory in another window."
    (interactive)
    (let ((file (dired-get-file-for-visit)))
      (if (file-directory-p file)
          (or (and (cdr dired-subdir-alist) (dired-goto-subdir file)) (dired file))
        (view-file-other-window file))))

  ;; Tree-sitter Integration
  (defun my/treesit--call-with-outdir (orig-fn &rest args)
    "Advice ORIG-FN to force OUT-DIR to `my:d:treesit` when omitted."
    (let* ((len (length args))
           (args* (append args (make-list (max 0 (- 7 len)) nil)))
           (out-dir (or (nth 6 args*) my:d:treesit)))
      (setf (nth 6 args*) out-dir)
      (my/ensure-directory-exists out-dir)
      (let ((default-directory my:d:treesit-build))
        (apply orig-fn args*))))

  (defun my/treesit-install (lang)
    "Install a tree-sitter grammar for LANG interactively."
    (interactive
     (list (intern (completing-read "Language: " (mapcar #'car treesit-language-source-alist)))))
    (treesit-install-language-grammar lang))

  (with-eval-after-load 'treesit
    (add-to-list 'treesit-extra-load-path my:d:treesit)
    (advice-add 'treesit-install-language-grammar :around #'my/treesit--call-with-outdir))

  ;; External Integration
  (defun my/open-by-vscode () (interactive)
    (when (buffer-file-name)
      (async-shell-command
       (format "code -r -g %s:%d:%d" (buffer-file-name) (line-number-at-pos) (current-column)))))

  (defun my/show-env-variable (var) (interactive "sEnvironment variable: ")
    (message "%s = %s" var (or (getenv var) "Not set")))

  (defun my/print-build-info () (interactive)
    (let ((buf (get-buffer-create "*Build Info*")))
      (with-current-buffer buf
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (format "- GNU Emacs *%s*\n\n" emacs-version))
          (insert "|Property|Value|\n|--------|-----|\n")
          (insert (format "|Commit|%s|\n" (if (fboundp 'emacs-repository-get-version)
                                      (emacs-repository-get-version) "N/A")))
  	(insert (format "|Branch|%s|\n" (if (fboundp 'emacs-repository-get-branch)
  					    (emacs-repository-get-branch) "N/A")))
          (insert (format "|System|%s|\n" system-configuration))
          (insert (format "|Date|%s|\n" (format-time-string "%Y-%m-%d %T (%Z)" emacs-build-time)))
          (insert (format "|Patch|%s ns-inline.patch|\n" (if (boundp 'mac-ime--cursor-type) "with" "N/A")))
          (insert (format "|Features|%s|\n" system-configuration-features))
          (insert (format "|Options|%s|\n" system-configuration-options)))
        (view-mode 1))
      (switch-to-buffer buf)))

  ;; Org Helpers
  (with-eval-after-load 'org
    (require 'org-fold)
    (defun my/org-fold-subtree ()   (interactive) (org-fold-subtree t))
    (defun my/org-unfold-subtree () (interactive) (org-show-subtree))
    (defun my/org-toggle-fold () (interactive)
      (save-excursion
        (org-back-to-heading t)
        (if (org-fold-folded-p (point)) (org-show-subtree) (org-fold-subtree t))))
    (define-key org-mode-map (kbd "C-c f") #'my/org-fold-subtree)
    (define-key org-mode-map (kbd "C-c e") #'my/org-unfold-subtree)
    (define-key org-mode-map (kbd "C-c t") #'my/org-toggle-fold))

  (provide 'core/tools)
  ;;; core/tools.el ends here
#+end_src

*** core/utils.el
:PROPERTIES:
:CUSTOM_ID: core-utils
:END:

*Purpose*
Core hooks/utilities: timestamp, org auto-tangle, quick revert, lexical-binding header, read-only view-mode.

*What it does*
Adds hooks for after-save, org-tangle-on-save, find-file, read-only-mode.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/core/utils.el
  ;;; core/utils.el --- Core utility helpers -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (defun my/auto-tangle-updated-src-blocks ()
    "Automatically tangle updated Org source blocks when saving `README.org`."
    (when (and buffer-file-name (string= (file-name-nondirectory buffer-file-name) "README.org"))
      (let ((org-confirm-babel-evaluate nil)) (org-babel-tangle))))

  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'my/auto-tangle-updated-src-blocks nil 'make-it-local)))

  (defun my/revert-buffer-quick ()
    (interactive) (revert-buffer :ignore-auto :noconfirm))

  (defun my/auto-insert-lexical-binding ()
    "Insert `lexical-binding: t` in Emacs Lisp files under `no-littering-var-directory`."
    (when (and (stringp buffer-file-name)
               (boundp 'no-littering-var-directory)
               (string-prefix-p (expand-file-name no-littering-var-directory) (expand-file-name buffer-file-name))
               (string-match-p "\\.el\\'" buffer-file-name)
               (not (save-excursion (goto-char (point-min))
                                    (re-search-forward "lexical-binding" (line-end-position 5) t))))
      (save-excursion (goto-char (point-min)) (insert ";; -*- lexical-binding: t; -*- \n"))))
  (add-hook 'find-file-hook #'my/auto-insert-lexical-binding)

  (defun my/enable-view-mode-on-read-only ()
    (if buffer-read-only (view-mode 1) (view-mode -1)))
  (add-hook 'read-only-mode-hook #'my/enable-view-mode-on-read-only)

  (provide 'core/utils)
  ;;; core/utils.el ends here
#+end_src

*** core/history.el
:PROPERTIES:
:CUSTOM_ID: core-history
:END:

*Purpose*
Persist cursor positions, recent files, minibuffer history; auto-revert changed files.

*What it does*
Enables `save-place-mode`, `recentf-mode`, `savehist-mode`, `global-auto-revert-mode`.

*Notes*
All built-in ⇒ `:straight nil`.

#+begin_src emacs-lisp :tangle lisp/core/history.el
  ;;; core/history.el --- Session persistence & autorevert -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (leaf saveplace :straight nil
    :init
    (setq save-place-file (concat no-littering-var-directory "saveplace"))
    (save-place-mode +1))

  (leaf recentf :straight nil
    :init
    (setq recentf-max-saved-items 100
          recentf-save-file (concat no-littering-var-directory "recentf"))
    (recentf-mode +1))

  (leaf savehist
    :straight nil
    :global-minor-mode t
    :config
    (setq savehist-file (concat no-littering-var-directory "history"))
    (my/ensure-directory-exists (file-name-directory savehist-file))
    (add-to-list 'savehist-additional-variables 'my:desktop-ask-on-restore))

  (provide 'core/history)
  ;;; core/history.el ends here
#+end_src

*** core/editing.el
:PROPERTIES:
:CUSTOM_ID: core-editing
:END:

*Purpose*
Modern structural editing, pairs, which-key, undo helpers, visual line wrap.

*What it does*
- Lisp: `paredit`(+disable `electric-pair-local-mode`), `show-paren-mode`, `puni`
- UI aids: `which-key`, `ace-window`, `vundo`, `undo-fu`
- Editing: `expand-region`, `aggressive-indent`, `delete-selection-mode`, `visual-line-mode`
- Dired UI: `dired-filter`, `dired-subtree`

*Notes*
Built-ins use `:straight nil`.

#+begin_src emacs-lisp :tangle lisp/core/editing.el
  ;;; core/editing.el --- Editing helpers & UX aids -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  ;;;; TRAMP setup ---------------------------------------------------------------
  (leaf tramp
    :straight nil
    :pre-setq
    `((tramp-persistency-file-name . ,(concat no-littering-var-directory "tramp"))
      (tramp-auto-save-directory   . ,(concat no-littering-var-directory "tramp-autosave")))
    :custom
    '((tramp-default-method . "scp")
      (tramp-verbose        . 3)))

  ;; Visited-mode saves the *real* file after brief idle.
  (setopt auto-save-visited-interval 1   ;; seconds of idle before saving
          auto-save-default        nil)  ;; don't create #...# files
  (when (fboundp 'auto-save-visited-mode)
    (auto-save-visited-mode 1))

  (leaf paredit :straight t
    :hook (emacs-lisp-mode . (lambda () (enable-paredit-mode) (electric-pair-local-mode -1))))

  (leaf paren :straight nil
    :custom ((show-paren-delay . 0)
             (show-paren-style . 'expression)
             (show-paren-highlight-openparen . t))
    :global-minor-mode show-paren-mode)

  (leaf puni :straight t
    :global-minor-mode puni-global-mode
    :hook ((minibuffer-setup . (lambda () (puni-global-mode -1)))))

  (leaf which-key :straight t :global-minor-mode t
    :custom ((which-key-idle-delay . 0.5)))

  (leaf undo-fu :straight t
    :custom ((undo-fu-allow-undo-in-region . t)))

  (leaf vundo :straight t
    :bind (("C-c u" . vundo)))

  (leaf ace-window :straight t
    :custom ((aw-keys . '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
             (aw-scope . 'frame)
             (aw-background . t))
    :config (ace-window-display-mode 1))

  (leaf visual-line-mode :straight nil
    :hook (text-mode . visual-line-mode))

  (leaf dired-filter :straight t)
  (leaf dired-subtree :straight t :after dired)
  (leaf dired :straight nil
    :bind (:dired-mode-map
           ("i"   . dired-subtree-insert)
           ("TAB" . dired-subtree-toggle)
           ("z"   . my/dired-view-file-other-window)))

  (leaf expand-region :straight t :after treesit)
  (leaf aggressive-indent :straight t :hook (prog-mode . aggressive-indent-mode))
  (leaf delsel :straight nil :global-minor-mode delete-selection-mode)

  (leaf autorevert :straight nil
    :custom ((auto-revert-interval . 2)
             (auto-revert-verbose . nil))
    :global-minor-mode global-auto-revert-mode)

  ;; ---------------------------------------------------------------------------
  ;; Transient (prefix command sessions: used by Magit, Forge, etc.)
  (leaf transient
    :straight t
    :config
    (setq transient-history-file (concat no-littering-var-directory "transient/history.el")
          transient-levels-file  (concat no-littering-var-directory "transient/levels.el")
          transient-values-file  (concat no-littering-var-directory "transient/values.el"))
    ;; Ensure directory exists
    (my/ensure-directory-exists (concat no-littering-var-directory "transient/")))

  (provide 'core/editing)
  ;;; core/editing.el ends here
#+end_src

*** core/switches.el
This module toggles UI bundles and LSP backends from two user options:

- ~my:use-ui~ :: one of ~'none~, ~'doom~, ~'nano~
- ~my:use-lsp~ :: one of ~'eglot~, ~'lsp~

It provides:
- Soft detection (autoload targets / locate-library checks)
- Safe enabling (no hard dependency on presence)
- Legacy migration: ~my:use:modules → my:use-ui~ without defvaralias overwrite warnings

**Usage**
- Put your choice in `personal/<user>.el`, e.g.:
  - ~(setq my:use-ui 'doom)~
  - ~(setq my:use-lsp 'eglot)~

#+begin_src emacs-lisp :tangle lisp/core/switches.el
  ;;; core/switches.el --- Unified feature switches (UI/LSP) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Switcher for UI bundles (doom/nano) and LSP backends (eglot/lsp).
  ;;
  ;;; Code:

  (eval-when-compile (require 'subr-x))

  ;;;; Back-compat (migrate before defining referent) ------------------------------
  (when (boundp 'my:use:modules)
    (when (or (not (boundp 'my:use-ui)) (eq my:use-ui 'none))
      (setq my:use-ui my:use:modules)))
  (define-obsolete-variable-alias 'my:use:modules 'my:use-ui "2025-10-11")

  ;;;; User options ----------------------------------------------------------------
  (defgroup my:switches nil "Unified switches for UI and LSP." :group 'convenience)

  (defcustom my:use-lsp 'eglot
    "Which LSP client to use. One of: `eglot`, `lsp`."
    :type '(choice (const eglot) (const lsp))
    :group 'my:switches)

  (defcustom my:use-ui 'none
    "Which UI bundle to use. One of: `none`, `doom`, `nano`."
    :type '(choice (const none) (const doom) (const nano))
    :group 'my:switches)

  ;;;; Autoload entry points -------------------------------------------------------
  (autoload 'my/ui-enable-doom  "ui/ui-doom-modeline" "Enable Doom UI bundle." t)
  (autoload 'my/ui-enable-nano  "ui/ui-nano-modeline" "Enable Nano UI bundle." t)
  (autoload 'my/lsp-enable-eglot   "dev/dev-lsp-eglot" "Enable Eglot LSP." t)
  (autoload 'my/lsp-enable-lspmode "dev/dev-lsp-mode"  "Enable lsp-mode LSP." t)

  ;;;; Soft probes -----------------------------------------------------------------
  (defun my/sw--present-p (kind choice)
    (pcase kind
      ('ui (pcase choice
             ('doom (or (fboundp 'my/ui-enable-doom)
                        (locate-library "ui/ui-doom-modeline")
                        (locate-library "doom-modeline")))
             ('nano (or (fboundp 'my/ui-enable-nano)
                        (locate-library "ui/ui-nano-modeline")
                        (locate-library "nano-modeline")))
             (_ t)))
      ('lsp (pcase choice
              ('eglot (or (fboundp 'my/lsp-enable-eglot)
                          (locate-library "dev/dev-lsp-eglot")
                          (locate-library "eglot")))
              ('lsp   (or (fboundp 'my/lsp-enable-lspmode)
                          (locate-library "dev/dev-lsp-mode")
                          (locate-library "lsp-mode")))
              (_ nil)))
      (_ nil)))

  (defun my/sw--enable-ui (choice)
    (pcase choice
      ('doom (cond
              ((fboundp 'my/ui-enable-doom) (my/ui-enable-doom) t)
              ((locate-library "ui/ui-doom-modeline")
               (load (locate-library "ui/ui-doom-modeline") nil 'nomessage)
               (when (fboundp 'my/ui-enable-doom) (my/ui-enable-doom) t))
              (t (message "[switches] Doom UI not found.") nil)))
      ('nano (cond
              ((fboundp 'my/ui-enable-nano) (my/ui-enable-nano) t)
              ((locate-library "ui/ui-nano-modeline")
               (load (locate-library "ui/ui-nano-modeline") nil 'nomessage)
               (when (fboundp 'my/ui-enable-nano) (my/ui-enable-nano) t))
              (t (message "[switches] Nano UI not found.") nil)))
      ('none (message "[switches] UI bundle disabled.") t)
      (_ (message "[switches] Unknown UI choice: %s" choice) nil)))

  (defun my/sw--enable-lsp (choice)
    (pcase choice
      ('eglot (cond
               ((fboundp 'my/lsp-enable-eglot) (my/lsp-enable-eglot) t)
               ((locate-library "dev/dev-lsp-eglot")
                (load (locate-library "dev/dev-lsp-eglot") nil 'nomessage)
                (when (fboundp 'my/lsp-enable-eglot) (my/lsp-enable-eglot) t))
               (t (message "[switches] Eglot setup not found.") nil)))
      ('lsp (cond
             ((fboundp 'my/lsp-enable-lspmode) (my/lsp-enable-lspmode) t)
             ((locate-library "dev/dev-lsp-mode")
              (load (locate-library "dev/dev-lsp-mode") nil 'nomessage)
              (when (fboundp 'my/lsp-enable-lspmode) (my/lsp-enable-lspmode) t))
             (t (message "[switches] lsp-mode setup not found.") nil)))
      (_ (message "[switches] Unknown LSP choice: %s" choice) nil)))

  ;;;; Entrypoint ------------------------------------------------------------------
  (when (not (eq my:use-ui 'none))
    (let ((present (my/sw--present-p 'ui my:use-ui)))
      (cond
       ((my/sw--enable-ui my:use-ui) (message "[switches] UI bundle: %s" my:use-ui))
       (present (message "[switches] UI seems present but could not enable: %s" my:use-ui))
       (t (message "[switches] UI bundle unavailable: %s" my:use-ui)))))

  (let ((present (my/sw--present-p 'lsp my:use-lsp)))
    (cond
     ((my/sw--enable-lsp my:use-lsp) (message "[switches] LSP backend: %s" my:use-lsp))
     (present (message "[switches] LSP seems present but could not enable: %s" my:use-lsp))
     (t (message "[switches] LSP backend unavailable: %s" my:use-lsp))))

  (provide 'core/switches)
  ;;; core/switches.el ends here
#+end_src

*** ui/ui-font.el
:PROPERTIES:
:CUSTOM_ID: ui-font
:END:

*Purpose*
Font setup for default, variable-pitch, emoji, ligatures.

*What it does*
Applies fonts and enables `ligature` in `prog-mode`.

*Notes*
Works for GUI frames/daemon.

#+begin_src emacs-lisp :tangle lisp/ui/ui-font.el
  ;;; ui/ui-font.el --- Font configuration -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (defun my/system-default-font ()
    "Return a default monospace font family depending on OS."
    (cond ((eq system-type 'darwin) "Menlo")
          ((eq system-type 'gnu/linux) "Monospace")
          ((eq system-type 'windows-nt) "Consolas")
          (t "Monospace")))

  (defun my/system-emoji-font ()
    "Return a default emoji font family depending on OS."
    (cond ((eq system-type 'darwin) "Apple Color Emoji")
          ((eq system-type 'gnu/linux) "Noto Color Emoji")
          ((eq system-type 'windows-nt) "Segoe UI Emoji")
          (t "Noto Color Emoji")))

  (defun my/font-setup ()
    "Apply font settings, respecting overrides, and report applied fonts."
    (when (display-graphic-p)
      ;; Default (monospace) font
      (set-face-attribute 'default nil
                          :family (or my:font-default (my/system-default-font))
                          :height (* 10 (or my:font-size 16)))
      (message "[font] default: %s, %.1f pt"
               (face-attribute 'default :family)
               (/ (float (face-attribute 'default :height)) 10))

      ;; Variable-pitch font
      (set-face-attribute 'variable-pitch nil
                          :family (or my:font-alt (my/system-default-font)))
      (message "[font] variable-pitch: %s"
               (face-attribute 'variable-pitch :family))

      ;; Emoji font
      (set-fontset-font t 'emoji
                        (font-spec :family (or my:emoji-font (my/system-emoji-font))))
      (message "[font] emoji: %s"
  	     (or my:emoji-font (my/system-emoji-font)))))

  (defun my/show-current-font ()
    "Echo the current default font family and point size."
    (interactive)
    (let* ((family (face-attribute 'default :family))
           (height (face-attribute 'default :height))
           (pt (/ height 10.0)))
      (message "Current font: %s, %.1f pt" family pt)))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame) (with-selected-frame frame (my/font-setup))))
    (add-hook 'after-init-hook #'my/font-setup))

  (leaf ligature :straight t
    :config
    (ligature-set-ligatures 'prog-mode '("->" "=>" "::" "===" "!=" "&&" "||"))
    (global-ligature-mode 1))

  (provide 'ui/ui-font)
  ;;; ui/ui-font.el ends here
#+end_src

*** ui/ui-theme.el
:PROPERTIES:
:CUSTOM_ID: ui-theme
:END:

**Purpose**
Theme management with `ef-themes` and `spacious-padding`, plus a **safe face-normalizer** that avoids setting face attributes to `nil` (which causes warnings in Emacs 30+).

**What it does**
- Keeps your original theme setup (incl. `(modus-themes-to-toggle . '(ef-frost ef-spring))`).
- Adds `ui--normalize-faces-after-theme` to set problematic face attributes to `'unspecified` instead of `nil`.
- Hooks the normalizer to `after-load-theme-hook` and runs it once at init.

**Notes**
If your `custom-file` (under `.etc/custom.el`) sets any face attribute to `nil`, this helper will correct it at runtime to prevent warnings like:
`Warning: setting attribute ‘:foreground’ of face ‘font-lock-doc-markup-face’: nil value is invalid, use ‘unspecified’ instead.`

#+begin_src emacs-lisp :tangle lisp/ui/ui-theme.el
  ;;; ui/ui-theme.el --- Theme configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Theme management (ef-themes + spacious-padding) and a face normalizer that
  ;; replaces invalid `nil` attributes with `unspecified` to avoid warnings on
  ;; Emacs 30+ (e.g., font-lock-doc-markup-face :foreground nil).
  ;; Category: ui
  ;;;
  ;;; Code:

  (leaf ef-themes :straight t
    :custom ((modus-themes-to-toggle . '(ef-frost ef-spring)))
    :config
    (unless custom-enabled-themes
      (load-theme (if (display-graphic-p) 'ef-frost 'deeper-blue) t)))

  (leaf spacious-padding :straight t
    :if (display-graphic-p)
    :custom ((spacious-padding-widths . '((left . 15) (right . 15)))
             (spacious-padding-subtle-mode-line . t))
    :config (spacious-padding-mode 1))

  (defgroup ui-theme-normalize nil
    "Normalize face attributes set to nil."
    :group 'faces)

  (defcustom ui:normalize-face-attrs
    '((font-lock-doc-markup-face :foreground))
    "List of (FACE ATTR ...) pairs to ensure are not nil."
    :type '(repeat (cons symbol (repeat symbol)))
    :group 'ui-theme-normalize)

  (defun ui--normalize-face-attr (face attr)
    "If FACE's ATTR is nil, set it to \\='unspecified to avoid warnings."
    (when (facep face)
      (let ((val (face-attribute face attr nil 'default)))
        (when (null val)
          (set-face-attribute face nil attr 'unspecified)))))

  (defun ui--normalize-faces ()
    "Normalize all faces declared in `ui:normalize-face-attrs`."
    (dolist (entry ui:normalize-face-attrs)
      (let ((face (car entry)) (attrs (cdr entry)))
        (dolist (attr attrs)
          (ui--normalize-face-attr face attr)))))

  (add-hook 'enable-theme-functions (lambda (_theme) (ui--normalize-faces)))
  (add-hook 'emacs-startup-hook #'ui--normalize-faces)

  (provide 'ui/ui-theme)
  ;;; ui/ui-theme.el ends here
#+end_src

*** ui/ui-doom-modeline.el [UI: Doom Modeline bundle]
A compact UI bundle that enables *doom-modeline* with *nerd-icons*.
It only touches the modeline; it does not change your theme or other UI layers.

- Safe defaults (height, buffer file style, word count)
- Autoloaded entry point: ~my/ui-enable-doom~
- Provides: ~ui/ui-doom-modeline~

#+begin_src emacs-lisp :tangle lisp/ui/ui-doom-modeline.el
  ;;; ui-doom-modeline.el --- Doom UI bundle entry -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Category: ui
  ;; Enable doom-modeline (with nerd-icons) as a compact UI bundle.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (declare-function doom-modeline-mode "doom-modeline")

  (leaf nerd-icons :straight t)

  (leaf doom-modeline
    :straight t
    :custom ((doom-modeline-height . 28)
             (doom-modeline-buffer-file-name-style . 'truncate-with-project)
             (doom-modeline-minor-modes . nil)
             (doom-modeline-enable-word-count . t))
    :config
    (doom-modeline-mode 1))

  ;;;###autoload
  (defun my/ui-enable-doom ()
    "Enable Doom UI modeline bundle."
    (interactive)
    (unless (bound-and-true-p doom-modeline-mode)
      (doom-modeline-mode 1))
    (message "[ui] Doom modeline enabled."))

  (provide 'ui/ui-doom-modeline)
  ;;; ui-doom-modeline.el ends here
#+end_src

*** ui/ui-nano-modeline.el [UI: Nano Modeline bundle]
A minimal, elegant modeline provided by *nano-modeline*.
Like the Doom bundle, it is scoped to the modeline area only.

- Single switch: turns nano-modeline on globally
- Autoloaded entry point: ~my/ui-enable-nano~
- Provides: ~ui/ui-nano-modeline~

#+begin_src emacs-lisp :tangle lisp/ui/ui-nano-modeline.el
  ;;; ui-nano-modeline.el --- Nano UI bundle entry -*- lexical-binding: t; -*-
  ;;
  ;; Category: ui
  ;;
  ;;; Commentary:
  ;; Robust loader that tries to require `nano-modeline` and wires all mode hooks.
  ;; Safe even if the package is not available at build time.

  (eval-when-compile (require 'leaf))

  ;; Silence byte-compiler about functions defined in nano-modeline
  (declare-function nano-modeline-mode             "nano-modeline")
  (declare-function nano-modeline-prog-mode        "nano-modeline")
  (declare-function nano-modeline-text-mode        "nano-modeline")
  (declare-function nano-modeline-org-mode         "nano-modeline")
  (declare-function nano-modeline-pdf-mode         "nano-modeline")
  (declare-function nano-modeline-mu4e-headers-mode "nano-modeline")
  (declare-function nano-modeline-mu4e-message-mode "nano-modeline")
  (declare-function nano-modeline-elfeed-entry-mode "nano-modeline")
  (declare-function nano-modeline-elfeed-search-mode "nano-modeline")
  (declare-function nano-modeline-term-mode        "nano-modeline")
  (declare-function nano-modeline-xwidget-mode     "nano-modeline")
  (declare-function nano-modeline-message-mode     "nano-modeline")
  (declare-function nano-modeline-org-capture-mode "nano-modeline")
  (declare-function nano-modeline-org-agenda-mode  "nano-modeline")

  (defvar ui--nano-modeline-initialized nil
    "Non-nil once nano-modeline hooks have been installed.")

  (defun my/ui--nano-available-p ()
    "Return non-nil if `nano-modeline` can be required."
    (require 'nano-modeline nil 'noerror))

  (defun my/ui--nano-setup ()
    "Install nano-modeline hooks once (idempotent)."
    (when (and (not ui--nano-modeline-initialized)
               (my/ui--nano-available-p))
      ;; Your customizations (padding etc.)
      (setopt nano-modeline-padding '(0.20 . 0.25))

      ;; Enable default for text buffers
      (when (fboundp 'nano-modeline-text-mode)
        (nano-modeline-text-mode t))

      ;; Hooks (only add if target function exists)
      (when (fboundp 'nano-modeline-prog-mode)
        (add-hook 'prog-mode-hook            #'nano-modeline-prog-mode))
      (when (fboundp 'nano-modeline-text-mode)
        (add-hook 'text-mode-hook            #'nano-modeline-text-mode))
      (when (fboundp 'nano-modeline-org-mode)
        (add-hook 'org-mode-hook             #'nano-modeline-org-mode))
      (when (fboundp 'nano-modeline-pdf-mode)
        (add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode))
      (when (fboundp 'nano-modeline-mu4e-headers-mode)
        (add-hook 'mu4e-headers-mode-hook    #'nano-modeline-mu4e-headers-mode))
      (when (fboundp 'nano-modeline-mu4e-message-mode)
        (add-hook 'mu4e-view-mode-hook       #'nano-modeline-mu4e-message-mode))
      (when (fboundp 'nano-modeline-elfeed-entry-mode)
        (add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode))
      (when (fboundp 'nano-modeline-elfeed-search-mode)
        (add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode))
      (when (fboundp 'nano-modeline-term-mode)
        (add-hook 'term-mode-hook            #'nano-modeline-term-mode))
      (when (fboundp 'nano-modeline-xwidget-mode)
        (add-hook 'xwidget-webkit-mode-hook  #'nano-modeline-xwidget-mode))
      (when (fboundp 'nano-modeline-message-mode)
        (add-hook 'messages-buffer-mode-hook #'nano-modeline-message-mode))
      (when (fboundp 'nano-modeline-org-capture-mode)
        (add-hook 'org-capture-mode-hook     #'nano-modeline-org-capture-mode))
      (when (fboundp 'nano-modeline-org-agenda-mode)
        (add-hook 'org-agenda-mode-hook      #'nano-modeline-org-agenda-mode))

      (setq ui--nano-modeline-initialized t)
      (message "[ui] nano-modeline initialized.")))

  ;; straight.el recipe and lazy wiring
  (leaf nano-modeline
    :straight (nano-modeline :type git :host github :repo "rougier/nano-modeline")
    :require nil          ;; do not auto-(require) to avoid build-time hard dep
    :init
    ;; Try to set up after init; if not installed yet, this is a no-op.
    (add-hook 'after-init-hook #'my/ui--nano-setup))

  ;;;###autoload
  (defun my/ui-enable-nano ()
    "Enable Nano UI modeline bundle (guarded)."
    (interactive)
    (if (my/ui--nano-available-p)
        (progn
          (my/ui--nano-setup)
          (message "[ui] nano-modeline enabled."))
      (message "[ui] nano-modeline not available; will enable after it is installed.")))

  (provide 'ui/ui-nano-modeline)
  ;;; ui/ui-nano-modeline.el ends here
#+end_src

*** ui/ui-window.el
:PROPERTIES:
:CUSTOM_ID: ui-window
:END:

*Purpose*
Window management: fullscreen, zoom, tabs, save/restore layout.

*What it does*
For GUI frames set fullscreen; zoom-mode; tab-bar/line; save/restore functions.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/ui/ui-window.el
  ;;; ui/ui-window.el --- Window management -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (leaf zoom :straight t
    :hook (after-init-hook . zoom-mode)
    :custom ((zoom-size . '(0.62 . 0.62))
             (zoom-ignored-major-modes . '(dired-mode treemacs-mode))
             (zoom-ignored-buffer-names . '("*Messages*" "*Help*"))))

  ;; (leaf tab-bar :straight nil
  ;;   :custom ((tab-bar-show . 1)
  ;;            (tab-bar-new-tab-choice . "*scratch*"))
  ;;   :hook (after-init-hook . tab-bar-mode))

  ;; (leaf tab-line :straight nil
  ;;   :hook (after-init-hook . global-tab-line-mode))

  ;;;; Desktop Save Mode ---------------------------------------------------------
  (leaf desktop
    :straight nil
    :config
    (let* ((dir (concat no-littering-var-directory "desktop/")))
      (setq desktop-dirname            dir
            desktop-path               (list dir)
            desktop-base-file-name     "desktop"
            desktop-base-lock-name     "lock"
            desktop-restore-eager      10
            desktop-save               t
            desktop-load-locked-desktop nil
            desktop-auto-save-timeout  300)
      (my/ensure-directory-exists dir)
      (desktop-save-mode 1)))

  ;;;; Winner mode (window configuration undo/redo) ------------------------------
  (leaf winner
    :straight nil
    :global-minor-mode t
    :bind (("M-[" . winner-undo)
           ("M-]" . winner-redo)))

  (defvar my:saved-window-config nil)

  (defun my/save-window-layout () (interactive)
    (setq my:saved-window-config (window-state-get nil t))
    (message "Window configuration saved."))

  (defun my/restore-window-layout () (interactive)
    (if my:saved-window-config
        (window-state-put my:saved-window-config)
      (message "No saved window configuration found.")))


  (provide 'ui/ui-window)
  ;;; ui/ui-window.el ends here
#+end_src

*** ui/ui-utils.el
:PROPERTIES:
:CUSTOM_ID: ui-treemacs
:END:

*Purpose*
Sidebar project/file explorer with icons.

*What it does*
Treemacs + nerd-icons-dired.

*Notes*
GUI only.

#+begin_src emacs-lisp :tangle lisp/ui/ui-utils.el
  ;;; ui/ui-utils.el --- Treemacs configuration -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (leaf minions :straight t
    :custom ((minions-mode-line-lighter . "⚙"))
    :hook (after-init-hook . minions-mode))

  (setq display-time-interval 30
        display-time-day-and-date t
        display-time-24hr-format t)
  (display-time-mode 1)
  (when (fboundp 'display-battery-mode) (display-battery-mode 1))

  (leaf treemacs :straight t
    :if (display-graphic-p)
    :custom ((treemacs-filewatch-mode . t)
             (treemacs-follow-mode . t)
             (treemacs-indentation . 2)
             (treemacs-missing-project-action . 'remove)))

  (leaf nerd-icons-dired :straight t
    :hook (dired-mode . nerd-icons-dired-mode))


  (leaf pbcopy
    :if (memq window-system '(mac ns))
    :straight t
    :config (turn-on-pbcopy))

  (provide 'ui/ui-utils)
  ;;; ui/ui-utils.el ends here
#+end_src

*** completion/completion-core.el
#+begin_src emacs-lisp :tangle lisp/completion/completion-core.el
  ;;; completion-core.el --- Completion core settings -*- lexical-binding: t; -*-
  (eval-when-compile (require 'leaf))

  (leaf orderless
    :straight t
    :custom
    ((completion-styles . '(orderless basic))
     (completion-category-overrides
      . '((file (styles . (partial-completion)))
          (symbol (styles . (orderless)))
          (command (styles . (orderless)))))))

  (provide 'completion/completion-core)
#+end_src

*** completion/completion-vertico.el
#+begin_src emacs-lisp :tangle lisp/completion/completion-vertico.el
  ;;; completion-vertico.el --- Vertico minibuffer UI -*- lexical-binding: t; -*-
  (eval-when-compile (require 'leaf))

  (leaf vertico :straight t
    :global-minor-mode vertico-mode
    :custom ((vertico-count . 15)))

  (leaf vertico-posframe :straight t
    :if (display-graphic-p)
    :after vertico
    :custom ((vertico-posframe-border-width . 2))
    :config (vertico-posframe-mode 1))

  (leaf marginalia :straight t
    :global-minor-mode marginalia-mode)

  (provide 'completion/completion-vertico)
#+end_src

*** completion/completion-consult.el
#+begin_src emacs-lisp :tangle lisp/completion/completion-consult.el
  ;;; completion-consult.el --- Consult search/navigation -*- lexical-binding: t; -*-
  (eval-when-compile (require 'leaf))

  (leaf consult :straight t
    :custom
    ((xref-show-xrefs-function . #'consult-xref)
     (xref-show-definitions-function . #'consult-xref)))

  (provide 'completion/completion-consult)
#+end_src

*** completion/completion-embark.el
#+begin_src emacs-lisp :tangle lisp/completion/completion-embark.el
  ;;; completion-embark.el --- Embark actions -*- lexical-binding: t; -*-
  (eval-when-compile (require 'leaf))

  (leaf embark :straight t
    :custom ((prefix-help-command . #'embark-prefix-help-command)))

  (leaf embark-consult :straight t
    :after (embark consult)
    :hook (embark-collect-mode . consult-preview-at-point-mode))

  (provide 'completion/completion-embark)
#+end_src

*** completion/completion-corfu.el
#+begin_src emacs-lisp :tangle lisp/completion/completion-corfu.el
  ;;; completion/completion-corfu.el --- Corfu popup completion module -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; This module configures Corfu-based in-buffer completion with sensible defaults,
  ;; TAB-first indent → completion behavior, and iconified candidates.
  ;; Category: completion
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf corfu :straight t
    :init
    ;; Make TAB trigger completion (indent first, then complete).
    (setq tab-always-indent 'complete)
    (global-corfu-mode)
    :custom ((corfu-auto . t)
             (corfu-cycle . t))
    :bind (:corfu-map
           ;; Candidate navigation with TAB / S-TAB.
           ("TAB"     . corfu-next)
           ([tab]     . corfu-next)
           ("S-TAB"   . corfu-previous)
           ([backtab] . corfu-previous)
           ;; Confirm with RET (use corfu-complete instead if you prefer).
           ("RET"     . corfu-insert)))

  (leaf kind-icon :straight t
    :after corfu
    :custom ((kind-icon-default-face . 'corfu-default))
    :config (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (leaf cape :straight t
    :init
    (mapc (lambda (fn) (add-to-list 'completion-at-point-functions fn))
          '(cape-file cape-dabbrev cape-keyword)))

  (provide 'completion/completion-corfu)
  ;;; completion/completion-corfu.el ends here
#+end_src

*** completion/completion-icons.el
#+begin_src emacs-lisp :tangle lisp/completion/completion-icons.el
  ;;; completion-icons.el --- Nerd icons for completion -*- lexical-binding: t; -*-
  (eval-when-compile (require 'leaf))

  (leaf nerd-icons-ibuffer :straight t
    :hook (ibuffer-mode-hook . nerd-icons-ibuffer-mode))

  (leaf nerd-icons-completion :straight t
    :hook (marginalia-mode-hook . nerd-icons-completion-marginalia-setup)
    :config (nerd-icons-completion-mode))

  (provide 'completion/completion-icons)
#+end_src

*** orgx/org-core.el
:PROPERTIES:
:CUSTOM_ID: org-core
:END:

*Purpose*
Core Org: GTD workflow, agenda, capture, refile, paths.

*What it does*
Sets directories, agenda files, TODO keywords, refile targets, capture templates.

*Notes*
`org` is installed via ELPA here (`:straight t`)—必要なら `:straight nil` に変更可。

#+begin_src emacs-lisp :tangle lisp/orgx/org-core.el
  ;;; orgx/org-core.el --- Org Mode core configuration -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'cl-lib))

  ;; Org directories
  (defvar my:d:org (expand-file-name "org/" my:d:var))
  (defvar my:d:org-journal (expand-file-name "journal" my:d:org))
  (defvar my:d:org-roam (expand-file-name "org-roam" my:d:org))
  (defvar my:d:org-pictures (expand-file-name "pictures" my:d:org))
  (defvar my:f:capture-blog-file (expand-file-name "blog.org" my:d:org))

  (my/ensure-directory-exists my:d:org)
  (my/ensure-directory-exists my:d:org-journal)
  (my/ensure-directory-exists my:d:org-roam)
  (my/ensure-directory-exists my:d:org-pictures)

  (defun my/org-buffer-files ()
    "Return a list of *.org files currently visited in live buffers."
    (cl-loop for buf in (buffer-list)
             for file = (buffer-file-name buf)
             when (and file (string-match-p "\\.org\\'" file))
             collect file))

  (leaf org
    :straight nil
    :custom
    ((org-directory . my:d:org)
     (org-default-notes-file . "notes.org")
     (org-log-done . 'time)
     (org-support-shift-select . t)
     (org-return-follows-link . t))
    :config
    (setq org-agenda-files
          (seq-filter (lambda (file)
                        (and (string-match-p "\\.org$" file)
                             (not (string-match-p "archives" file))))
                      (directory-files-recursively org-directory "\\.org$")))
    (unless org-agenda-files
      (setq org-agenda-files (list (expand-file-name "inbox.org" org-directory))))
    (setq org-todo-keywords
          '((sequence "TODO(t)" "SOMEDAY(s)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c@)")))
    (setq org-refile-targets
          '((nil :maxlevel . 3)
            (my/org-buffer-files :maxlevel . 1)
            (org-agenda-files :maxlevel . 3)))
    (setq org-capture-templates
          `(("t" "Todo" entry (file+headline ,(expand-file-name "gtd.org" org-directory) "Inbox")
             "* TODO %?\n %i\n %a")
            ("n" "Note" entry (file+headline ,(expand-file-name "notes.org" org-directory) "Notes")
             "* %?\nEntered on %U\n %i\n %a")
            ("j" "Journal" entry (function org-journal-find-location)
             "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
            ("m" "Meeting" entry (file ,(expand-file-name "meetings.org" org-directory))
             "* MEETING with %? :meeting:\n  %U\n  %a"))))

  (with-eval-after-load 'org
    (let* ((central (expand-file-name "archive.org" (or (bound-and-true-p org-directory)
                                                       (expand-file-name "~/org")))))
      (setopt org-archive-location (concat central "::"))))

  (provide 'orgx/org-core)
  ;;; orgx/org-core.el ends here
#+end_src

*** orgx/org-visual.el
:PROPERTIES:
:CUSTOM_ID: org-visual
:END:

*Purpose*: Provide modern Org Mode visual enhancements.
*What it does*: Enables `org-modern` for indentation, pretty entities, and agenda visuals.
*Notes*: Removed `org-superstar` (redundant & conflicts). Use `org-modern` as default.

#+begin_src emacs-lisp :tangle lisp/orgx/org-visual.el
  ;;; orgx/org-visual.el --- Org Mode visual enhancements -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Use org-modern for visual tweaks. org-superstar removed for clarity.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf org-modern
    :straight t
    :hook (org-mode . org-modern-mode)
    :custom
    ((org-startup-indented . t)
     (org-hide-leading-stars . t)
     (org-auto-align-tags . nil)
     (org-tags-column . 0)
     (org-catch-invisible-edits . 'show-and-error)
     (org-special-ctrl-a/e . t)
     (org-insert-heading-respect-content . t)
     (org-hide-emphasis-markers . t)
     (org-pretty-entities . t)
     (org-agenda-tags-column . 0)
     (org-agenda-block-separator . ?─)
     (org-agenda-time-grid
      . '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          " ┄┄┄┄┄ " " ┄┄┄┄┄ "))
     (org-agenda-current-time-string
      . "⭠ now ─────────────────────────────────────────────────")))

  (provide 'orgx/org-visual)
  ;;; org-visual.el ends here
#+end_src

*** orgx/org-extensions.el
:PROPERTIES:
:CUSTOM_ID: org-extensions
:END:

*Purpose*
Org extensions: journal, roam, download, toc-org, cliplink.

*What it does*
Configures those packages and their paths.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/orgx/org-extensions.el
  ;;; orgx/org-extensions.el --- Org Mode extensions -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf org-journal :straight t
    :custom ((org-journal-dir . my:d:org-journal)))

  (leaf org-roam :straight t
    :custom ((org-roam-directory . my:d:org-roam))
    :config
    (setq org-roam-db-location (expand-file-name "org-roam.db" my:d:org-roam))
    (org-roam-db-autosync-mode))

  (leaf org-download :straight t
    :custom ((org-download-image-dir . my:d:org-pictures)))

  (leaf toc-org :straight t
    :hook ((org-mode . toc-org-enable)
           (markdown-mode . toc-org-mode)))

  (leaf org-cliplink :straight t
    :bind ("C-x p i" . org-cliplink))

  (provide 'orgx/org-extensions)
  ;;; orgx/org-extensions.el ends here
#+end_src

*** orgx/org-export.el
:PROPERTIES:
:CUSTOM_ID: org-export
:END:

*Purpose*: Configure Org export backends (LaTeX, Hugo, Markdown).
*What it does*:
- Tweak LaTeX export process
- Enable Hugo export (`ox-hugo`)
- Provide Markdown preview/editing helpers
*Notes*:
- Use `with-eval-after-load 'ox-latex` instead of `leaf org-latex` (safer)
- Markdown tools (`markdown-mode`, `edit-indirect`) included here for convenience

#+begin_src emacs-lisp :tangle lisp/orgx/org-export.el
  ;;; orgx/org-export.el --- Org export configuration -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Org export configuration: LaTeX, Hugo, Markdown.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; ---------------------------------------------------------------------------
  ;; Hugo Export
  (leaf ox-hugo :straight t
    :after ox
    :custom ((org-hugo-front-matter-format . "toml")))

  ;; ---------------------------------------------------------------------------
  ;; Markdown Editing/Preview
  (leaf markdown-mode :straight t)
  (leaf markdown-preview-mode :straight t)
  (leaf edit-indirect :straight t)

  (provide 'orgx/org-export)
  ;;; org-export.el ends here
#+end_src

*** vcs/vcs-magit.el
:PROPERTIES:
:CUSTOM_ID: vcs-magit
:END:

*Purpose*
Magit bindings.

*What it does*
Binds `C-x g` to `magit-status`.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/vcs/vcs-magit.el
  ;;; vcs/vcs-magit.el --- Git integration with Magit -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf magit :straight t
    :bind (("C-x g" . magit-status)))

  (provide 'vcs/vcs-magit)
  ;;; vcs/vcs-magit.el ends here
#+end_src

*** vcs/vcs-gutter.el
:PROPERTIES:
:CUSTOM_ID: vcs-gutter
:END:

*Purpose*: Show Git changes in the fringe.
*What it does*: Uses `diff-hl` for inline VC indicators and integrates with Magit refresh.
*Notes*: Removed `git-gutter` to avoid duplication and possible conflicts.

#+begin_src emacs-lisp :tangle lisp/vcs/vcs-gutter.el
  ;;; vcs/vcs-gutter.el --- Show Git changes in fringe -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Use `diff-hl` as the sole fringe indicator. Integrates with Magit refresh.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf diff-hl
    :straight t
    :hook ((prog-mode . diff-hl-mode)
           (text-mode . diff-hl-mode)
           (dired-mode . diff-hl-dired-mode)
           (magit-post-refresh . diff-hl-magit-post-refresh))
    :custom ((diff-hl-draw-borders . nil)))

  (provide 'vcs/vcs-gutter)
  ;;; vcs-gutter.el ends here
#+end_src

*** vcs/vcs-forge.el
:PROPERTIES:
:CUSTOM_ID: vcs-forge
:END:

*Purpose*
Forge: GitHub/GitLab issues/PRs integration.

*What it does*
Loads `forge` after `magit`.

*Notes*
Optional.

#+begin_src emacs-lisp :tangle lisp/vcs/vcs-forge.el
  ;;; vcs/vcs-forge.el --- GitHub/GitLab integration via Forge -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; ---------------------------------------------------------------------------
  ;; Forge: GitHub/GitLab issue/PR integration for Magit
  (leaf forge
    :straight t
    :after magit
    :config
    ;; Move database under .var/
    (setq forge-database-file
          (expand-file-name "forge/forge-database.sqlite" no-littering-var-directory))

    ;; Ensure directory exists
    (my/ensure-directory-exists (expand-file-name "forge" no-littering-var-directory)))

  (provide 'vcs/vcs-forge)
  ;;; vcs/vcs-forge.el ends here
#+end_src

*** dev/dev-lsp-eglot.el [LSP: Eglot setup]
Self-contained Eglot configuration that auto-enables only when a server is detectable.
Designed to be toggled by ~core/switches.el~ via ~my:use-lsp = 'eglot~.

- Gentle auto-start (~eglot--guess-contact~)
- Reconnects automatically
- Autoloaded entry point: ~my/lsp-enable-eglot~
- Provides: ~dev/dev-lsp-eglot~

#+begin_src emacs-lisp :tangle lisp/dev/dev-lsp-eglot.el
;;; dev-lsp-eglot.el --- Eglot setup -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2025
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;
;;; Commentary:
;; Category: dev (LSP: Eglot)
;; Eglot baseline with safe auto-enable only when a server is detectable.
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf eglot
  :straight t
  :commands (eglot eglot-ensure)
  :custom ((eglot-autoreconnect . t))
  :hook ((prog-mode . (lambda ()
                        (when (fboundp 'eglot--guess-contact)
                          (when (eglot--guess-contact)
                            (eglot-ensure)))))))

;;;###autoload
(defun my/lsp-enable-eglot ()
  "Enable Eglot-based LSP setup."
  (interactive)
  (add-hook 'prog-mode-hook
            (lambda ()
              (when (fboundp 'eglot--guess-contact)
                (when (eglot--guess-contact)
                  (eglot-ensure)))))
  (message "[lsp] Eglot enabled."))

(provide 'dev/dev-lsp-eglot)
;;; dev-lsp-eglot.el ends here
#+end_src

*** dev/dev-lsp-mode.el [LSP: lsp-mode setup]
Self-contained lsp-mode configuration with lsp-ui; completion is delegated to Corfu.
Designed to be toggled by ~core/switches.el~ via ~my:use-lsp = 'lsp~.

- ~lsp-deferred~ on ~prog-mode~
- lsp-ui doc & sideline enabled
- Autoloaded entry point: ~my/lsp-enable-lspmode~
- Provides: ~dev/dev-lsp-mode~

#+begin_src emacs-lisp :tangle lisp/dev/dev-lsp-mode.el
;;; dev-lsp-mode.el --- lsp-mode setup -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2025
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;
;;; Commentary:
;; Category: dev (LSP: lsp-mode)
;; lsp-mode baseline + lsp-ui. Completion is delegated to Corfu.
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf lsp-mode
  :straight t
  :commands (lsp lsp-deferred)
  :custom ((lsp-keymap-prefix . "C-c l")
           (lsp-enable-file-watchers . t)
           (lsp-file-watch-threshold . 5000)
           (lsp-response-timeout . 5)
           (lsp-diagnostics-provider . :auto)
           (lsp-completion-provider . :none)) ;; Corfu handles completion
  :hook ((prog-mode . lsp-deferred)))

(leaf lsp-ui
  :straight t
  :after lsp-mode
  :custom ((lsp-ui-doc-enable . t)
           (lsp-ui-doc-delay . 0.2)
           (lsp-ui-sideline-enable . t)))

;;;###autoload
(defun my/lsp-enable-lspmode ()
  "Enable lsp-mode-based LSP setup."
  (interactive)
  (add-hook 'prog-mode-hook #'lsp-deferred)
  (message "[lsp] lsp-mode enabled."))

(provide 'dev/dev-lsp-mode)
;;; dev-lsp-mode.el ends here
#+end_src

*** dev/dev-ai.el
:PROPERTIES:
:CUSTOM_ID: dev-ai
:END:

*Purpose*
AI-assisted coding via Aidermacs.

*What it does*
Supports OpenRouter/OpenAI backends; sets default model and backend.

*Notes*
Warns when no API keys.

#+begin_src emacs-lisp :tangle lisp/dev/dev-ai.el
  ;;; dev/dev-ai.el --- AI-assisted development -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; AI-assisted coding via Aidermacs.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf aidermacs :straight t
    :init
    (cond
     ((getenv "OPENROUTER_API_KEY")
      (setenv "OPENAI_API_BASE" "https://openrouter.ai/api/v1")
      (setenv "OPENAI_API_KEY"  (getenv "OPENROUTER_API_KEY"))
      (setopt aidermacs-default-model "openrouter/anthropic/claude-3.5-sonnet"))
     ((getenv "OPENAI_API_KEY")
      (setenv "OPENAI_API_BASE" "https://api.openai.com/v1")
      (setopt aidermacs-default-model "gpt-4o-mini"))
     (t
      (display-warning 'aidermacs
                       "No API keys set. Set OPENROUTER_API_KEY or OPENAI_API_KEY.")))
    (setopt aidermacs-retry-attempts 3
            aidermacs-retry-delay   2.0
            aidermacs-backend       'vterm))

  (provide 'dev/dev-ai)
  ;;; dev/dev-ai.el ends here
#+end_src

*** dev/dev-term.el
:PROPERTIES:
:CUSTOM_ID: dev-term
:END:

*Purpose*
Terminal integration with vterm.

*What it does*
Loads vterm package.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/dev/dev-term.el
  ;;; dev/dev-term.el --- Terminal integration -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Provides terminal integration with vterm.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf vterm :straight t)

  (provide 'dev/dev-term)
  ;;; dev/dev-term.el ends here
#+end_src

*** dev/dev-build.el
:PROPERTIES:
:CUSTOM_ID: dev-build
:END:

*Purpose*
Build system integration (Makefile, compile, ANSI color).

*What it does*
Strict tabs for Makefile; compile bindings; colorize compilation buffers.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/dev/dev-build.el
  ;;; dev/dev-build.el --- Build & Makefile tools -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Build system integration.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf make-mode :straight nil
    :mode (("\\`Makefile\\'"    . makefile-gmake-mode)
           ("\\`GNUmakefile\\'" . makefile-gmake-mode)
           ("\\`makefile\\'"    . makefile-gmake-mode))
    :hook ((makefile-mode . (lambda ()
                              (setq-local indent-tabs-mode t
                                          tab-width 8
                                          show-trailing-whitespace t))))
    :config
    (leaf compile :straight nil
      :bind (("C-c c c" . compile)
             ("C-c c r" . recompile)
             ("C-c c p" . project-compile))
      :custom ((compilation-scroll-output . t)
               (compilation-skip-threshold . 2))
      :init
      (defun my/set-make-compile-command ()
        "Use `make -k` when Makefile is present."
        (when (or (derived-mode-p 'makefile-mode)
                  (locate-dominating-file default-directory "Makefile")
                  (locate-dominating-file default-directory "GNUmakefile"))
          (setq-local compile-command "make -k")))
      (add-hook 'after-change-major-mode-hook #'my/set-make-compile-command))
    (leaf ansi-color :straight nil
      :hook (compilation-filter . (lambda ()
                                    (let ((inhibit-read-only t))
                                      (ansi-color-apply-on-region compilation-filter-start (point-max)))))))

  (provide 'dev/dev-build)
  ;;; dev/dev-build.el ends here
#+end_src

*** dev/dev-docker.el
:PROPERTIES:
:CUSTOM_ID: dev-docker
:END:

*Purpose*
Docker development support.

*What it does*
dockerfile-mode, yaml-mode for compose, docker.el dashboard, tramp-container, tempel snippets.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/dev/dev-docker.el
  ;;; dev/dev-docker.el --- Docker integration -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Docker development support.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf dockerfile-mode :straight t
    :mode (("Dockerfile\\(\\..*\\)?\\'" . dockerfile-mode)
           ("\\.dockerfile\\'"         . dockerfile-mode))
    :custom ((dockerfile-mode-command . "docker")))

  (leaf yaml-mode :straight t
    :mode (("\\`docker-compose.*\\.ya?ml\\'" . yaml-mode)
           ("\\.ya?ml\\'"                   . yaml-mode)))

  (leaf docker :straight t
    :commands (docker docker-containers docker-images docker-volumes docker-networks)
    :bind (("C-c d d" . docker)
           ("C-c d c" . docker-containers)
           ("C-c d i" . docker-images)
           ("C-c d v" . docker-volumes)
           ("C-c d n" . docker-networks)))

  (leaf tramp-container :straight nil
    :after tramp
    :init
    (setq tramp-container-method "docker"))

  (leaf tempel :straight t
    :commands (tempel-insert)
    :bind (dockerfile-mode-map
           ("C-c d t" . tempel-insert))
    :init
    (with-eval-after-load 'tempel
      (defvar my:tempel-docker-templates
        '((dockerfile "FROM " p n
                      "WORKDIR /app" n
                      "COPY . /app" n
                      "RUN " p n
                      "CMD [" p "]" n)))
      (add-to-list 'tempel-user-elements my:tempel-docker-templates)))

  (provide 'dev/dev-docker)
  ;;; dev/dev-docker.el ends here
#+end_src

*** dev/web-core.el
:PROPERTIES:
:CUSTOM_ID: dev-web-core
:END:

*Purpose*: Provide modern syntax highlighting and project management.
*What it does*: Configures built-in `project`, `files`, `treesit`, and associates file extensions with Tree-sitter modes. Also enables EditorConfig.
*Notes*: Tree-sitter is native in Emacs 30+. Ensure grammar installation via `M-x treesit-install-language-grammar`.

#+begin_src emacs-lisp :tangle lisp/dev/web-core.el
  ;;; web-core.el --- Treesit & project core -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Core configuration for project management and modern syntax highlighting.
  ;; Includes EditorConfig support and Tree-sitter remapping.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; Built-ins
  (leaf project :straight nil)
  (leaf files   :straight nil
    :custom ((require-final-newline . t)
             (delete-trailing-lines . t))
    :hook ((before-save-hook . delete-trailing-whitespace)))

  ;; EditorConfig
  (leaf editorconfig
    :straight t
    :global-minor-mode t)

  ;; Tree-sitter preferences (Emacs 30+)
  (leaf treesit
    :straight nil
    :custom ((major-mode-remap-alist
              . '((typescript-mode . typescript-ts-mode)
                  (js-mode         . js-ts-mode)
                  (json-mode       . json-ts-mode)
                  (css-mode        . css-ts-mode)
                  (yaml-mode       . yaml-ts-mode)
                  (sh-mode         . bash-ts-mode)))))

  ;; File associations
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'"  . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))

  (provide 'dev/web-core)
  ;;; web-core.el ends here
#+end_src

*** dev/format.el
:PROPERTIES:
:CUSTOM_ID: dev-format
:END:

*Purpose*: Provide auto-formatting for TypeScript/JavaScript/JSON/CSS/Markdown.
*What it does*: Configures Apheleia with `prettierd`/`prettier` formatters and enables global mode.
*Notes*: `prettierd` is preferred for performance; falls back to `npx prettier`.

#+begin_src emacs-lisp :tangle lisp/dev/format.el
  ;;; format.el --- Prettier/ESLint via Apheleia -*- lexical-binding: t; -*-

  (eval-when-compile (require 'leaf))

  (leaf apheleia
    :straight t
    :require t
    :config
    (setf (alist-get 'prettierd apheleia-formatters)
          '("prettierd" filepath))
    (setf (alist-get 'prettier apheleia-formatters)
          '("npx" "prettier" "--stdin-filepath" filepath))
    (dolist (pair '((typescript-ts-mode . prettierd)
                    (tsx-ts-mode        . prettierd)
                    (json-ts-mode       . prettierd)
                    (css-ts-mode        . prettierd)
                    (markdown-mode      . prettierd)))
      (add-to-list 'apheleia-mode-alist pair))
    (apheleia-global-mode +1))

  (provide 'dev/format)
  ;;; format.el ends here
#+end_src

*** dev/infra-modes.el
:PROPERTIES:
:CUSTOM_ID: dev-infra-modes
:END:

*Purpose*: Enable syntax modes for infrastructure files (`.env`, Compose, TOML, Makefiles).
*What it does*: Configures `docker-compose-mode`, `dotenv-mode`, `toml-mode`, and builtin `make-mode`.
*Notes*: Built-in `make-mode` remaps `Makefile` to GNU Make variant.

#+begin_src emacs-lisp :tangle lisp/dev/infra-modes.el
  ;;; infra-modes.el --- Infra modes (.env / Compose / TOML / Make) -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Syntax support for infra files such as Docker Compose, .env, TOML, and Makefiles.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf docker-compose-mode :straight t :mode ("docker-compose\\.*ya?ml\\'"))
  (leaf dotenv-mode :straight t
    :mode (("\\.env\\..*\\'" . dotenv-mode)
           ("\\.env\\'"     . dotenv-mode)))
  (leaf toml-mode :straight t :mode ("\\.toml\\'" . toml-mode))

  (provide 'dev/infra-modes)
  ;;; infra-modes.el ends here
#+end_src

*** dev/sql.el
:PROPERTIES:
:CUSTOM_ID: dev-sql
:END:

*Purpose*: Provide SQL/PostgreSQL development helpers and formatting.
*What it does*: Configures built-in `sql` with indentation mode, and uses `sqlformat` for auto-formatting with `pgformatter`.
*Notes*: Ensure `pgformatter` is installed in your system PATH.

#+begin_src emacs-lisp :tangle lisp/dev/sql.el
  ;;; lisp/dev/sql.el --- SQL/PostgreSQL helpers -*- lexical-binding: t; -*-
  (eval-when-compile (require 'leaf))

  (leaf sql :straight nil
    :custom ((sql-product . 'postgres)))

  (leaf sql-indent :straight t
    :hook (sql-mode . sqlind-minor-mode))

  (leaf sqlformat
    :straight t
    :custom ((sqlformat-command . 'pgformatter)
             (sqlformat-args . '("--nostyle")))
    :hook (sql-mode . sqlformat-on-save-mode)
    :hook (sql-ts-mode . sqlformat-on-save-mode))

  (provide 'dev/sql)
  ;;; sql.el ends here
#+end_src

*** dev/rest.el
:PROPERTIES:
:CUSTOM_ID: dev-rest
:END:

*Purpose*: Provide HTTP request testing inside Emacs.
*What it does*: Installs `restclient` and `restclient-jq` for `.http` files with JSON parsing.
*Notes*: Useful for API testing in Next.js, Ollama, Qdrant workflows.

#+begin_src emacs-lisp :tangle lisp/dev/rest.el
  ;;; rest.el --- REST client helpers (Next.js / Ollama / Qdrant) -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; REST client integration for testing HTTP requests inside Emacs.
  ;; Supports JSON parsing with jq.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf restclient :straight t :mode ("\\.http\\'" . restclient-mode))
  (leaf restclient-jq :straight t :after restclient)

  (provide 'dev/rest)
  ;;; rest.el ends here
#+end_src

*** utils/utils-functions.el
:PROPERTIES:
:CUSTOM_ID: utils-functions
:END:

*Purpose*
General utility helpers.

*What it does*
Directory ensure, safe load.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/utils/utils-functions.el
  ;;; utils/utils-functions.el --- General utility functions -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  ;;; lisp/utils/utils-functions.el --- General utility functions -*- lexical-binding: t; -*-

  (defun my/kill-buffer-smart ()
    "Kill buffer and window, or just buffer if only one window."
    (interactive)
    (if (one-window-p)
        (kill-buffer)
      (kill-buffer-and-window)))

  (provide 'utils/utils-functions)
#+end_src

*** utils/utils-scratch.el
:PROPERTIES:
:CUSTOM_ID: utils-scratch
:END:

*Purpose*
Ensure `*scratch*` buffer existence and quick recreate.

*What it does*
Creates scratch on kill, offers recreate command.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/utils/utils-scratch.el
  ;;; utils/utils-scratch.el --- Scratch buffer helpers -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (leaf *scratch-auto-recreate
    :straight nil
    :init
    (defun my/create-scratch-buffer ()
      "Create a new `*scratch*` buffer with `lisp-interaction-mode`."
      (let ((buf (get-buffer-create "*scratch*")))
        (with-current-buffer buf
          (lisp-interaction-mode)
          (insert ";; This is a new *scratch* buffer\n\n"))
        buf))

    (defun my/kill-scratch-buffer-advice (buf)
      "Recreate *scratch* if BUF is *scratch*."
      (when (string= (buffer-name buf) "*scratch*")
        (run-at-time 0 nil #'my/create-scratch-buffer)))

    (add-hook 'kill-buffer-hook
              (lambda ()
                (my/kill-scratch-buffer-advice (current-buffer)))))

  (provide 'utils/utils-scratch)
  ;;; utils/utils-scratch.el ends here
#+end_src

*** utils/utils-backup.el
:PROPERTIES:
:CUSTOM_ID: utils-backup
:END:

*Purpose*
Backup/auto-save helpers.

*What it does*
Deletes old backups on startup.

*Notes*
Keeps `.var/backup/` clean.

#+begin_src emacs-lisp :tangle lisp/utils/utils-backup.el
  ;;; utils/utils-backup.el --- Backup and auto-save helpers -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (defun my/delete-old-backups ()
    "Delete backup files older than 7 days."
    (interactive)
    (let ((backup-dir (concat no-littering-var-directory "backup/"))
          (threshold (- (float-time (current-time)) (* 7 24 60 60))))
      (when (file-directory-p backup-dir)
        (dolist (file (directory-files backup-dir t))
          (when (and (file-regular-p file)
                     (< (float-time (file-attribute-modification-time
                                     (file-attributes file)))
                        threshold))
            (delete-file file))))))

  (add-hook 'emacs-startup-hook #'my/delete-old-backups)

  (provide 'utils/utils-backup)
  ;;; utils/utils-backup.el ends here
#+end_src

*** utils/utils-async.el
:PROPERTIES:
:CUSTOM_ID: utils-async
:END:

*Purpose*
Run tasks safely async.

*What it does*
Provides `my/safe-run-async`.

*Notes*
None.

#+begin_src emacs-lisp :tangle lisp/utils/utils-async.el
  ;;; utils/utils-async.el --- Async helpers -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later

  ;;; Code:

  (defun my/safe-run-async (task)
    "Run TASK asynchronously, catching and reporting any errors."
    (run-at-time 0 nil
                 (lambda ()
                   (condition-case err
                       (funcall task)
                     (error (message "[async] error: %s" err))))))

  (provide 'utils/utils-async)
  ;;; utils/utils-async.el ends here
#+end_src

*** utils/search-nav.el
:PROPERTIES:
:CUSTOM_ID: utils-search-nav
:END:

*Purpose*: Provide project-level search and navigation tools.
*What it does*:
- Use `consult-ripgrep` (from completion-consult) for live grep if `rg` is installed
- Provide `dumb-jump` as a fallback xref backend (when no LSP available)
- Optional: `multiple-cursors` for multi-editing
*Notes*:
- Removed `leaf rg` (redundant with consult)
- `projectile` dropped in favor of built-in `project.el` (Emacs 30+)
- Safer and avoids duplication with `completion-consult.el`

#+begin_src emacs-lisp :tangle lisp/utils/search-nav.el
  ;;; utils/search-nav.el --- Project search & navigation -*- lexical-binding: t; -*-

  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later

  ;;; Commentary:
  ;; Modern search/navigation helpers using ripgrep (via consult) and dumb-jump fallback.

  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; ---------------------------------------------------------------------------
  ;; Dumb Jump (fallback xref backend when no LSP available)
  (leaf dumb-jump :straight t
    :hook (xref-backend-functions . dumb-jump-xref-activate)
    :custom ((dumb-jump-force-searcher  . 'rg)
             (dumb-jump-prefer-searcher . 'rg)))

  ;; ---------------------------------------------------------------------------
  ;; Multiple cursors for multi-editing
  (leaf multiple-cursors :straight t)

  ;; ---------------------------------------------------------------------------
  ;; WWW
  (leaf eww :straight nil
    :custom ((eww-search-prefix . "https://duckduckgo.com/html/?kl=jp-jp&k1=-1&kc=1&kf=-1&q=")
             (eww-download-directory . "~/Downloads"))
    :init
    (setq eww-bookmarks-file (expand-file-name "eww-bookmarks" my:d:var))
    (setq eww-history-limit 200)
    (defvar eww-hl-search-word nil "Word to highlight with isearch after EWW loads.")
    (defun my/eww-search (term)
      "Search TERM with EWW and start isearch."
      (interactive "sSearch terms: ")
      (setq eww-hl-search-word term)
      (eww-browse-url (concat eww-search-prefix term)))
    (add-hook 'eww-after-render-hook
              (lambda ()
                (when eww-hl-search-word
                  (isearch-mode t)
                  (isearch-yank-string eww-hl-search-word)
                  (setq eww-hl-search-word nil))))
    (defun my/eww-toggle-images () (interactive)
      (setq shr-inhibit-images (not shr-inhibit-images))
      (eww-reload)))

  (provide 'utils/search-nav)
  ;;; utils-search-nav.el ends here
#+end_src

** personal/user.el
:PROPERTIES:
:CUSTOM_ID: personal-user
:END:

**Purpose**
Personal, device-specific settings for macOS-first workflows: identity, fonts, directories, input source switching, pointing-device tuning, and Apple Music control.

**What it does**
- Sets user identity and preferred fonts (picked up by `ui/ui-font.el`).
- Establishes personal directories (cloud/org/blog) and ensures their presence.
- Recomputes `org-directory` and agenda files.
- Configures **macOS IME auto-switch** via `sis` (with `macism`).
- Tunes Logitech MX Ergo S scrolling and simple mouse gestures.
- Provides **Apple Music** control (play/pause, next/prev, playlist, info) with a personal hydra.

**Notes**
- Relies on helpers and paths prepared in `early-init.el` (e.g. `my/ensure-directory-exists`, `my:d`, `my:d:var`, etc.).
- `sis` requires macOS and `macism` (`brew install macism`).
- Public interactive commands are annotated with `;;;###autoload`.

#+begin_src emacs-lisp :tangle (eval (format "personal/%s.el" (user-login-name)))
  ;;; user.el --- Personal configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;;
  ;;; Commentary:
  ;; Personal settings and device-specific configurations (category: personal).
  ;; - Identity, fonts, directories
  ;; - macOS IME auto-switch (sis)
  ;; - Device tweaks (Logitech MX Ergo S)
  ;; - Apple Music control with personal hydra
  ;;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x)) ;; string-trim

  ;; -----------------------------------------------------------------------------
  ;; Personal identity, fonts, and directories
  (leaf *personals
    :straight nil
    :init
    ;; Identity
    (setq user-full-name "YAMASHITA, Takao"
          user-mail-address "tjy1965@gmail.com"
          inhibit-compacting-font-caches t
          plstore-cache-passphrase-for-symmetric-encryption t)

    ;; Fonts (picked up by ui/ui-font.el)
    (setq my:font-default "JetBrains Mono NL"
          my:font-alt     "Noto Sans JP"
          my:emoji-font   "Apple Color Emoji"
          my:font-size    18)

    ;; Modelines / LSP
    (setq my:use-ui 'nano
  	my:use-lsp 'eglot)

    ;; Directories
    (defvar my:d:cloud
      (expand-file-name "Documents/" (getenv "HOME"))
      "Cloud storage base directory.")
    (defvar my:d:org
      (expand-file-name "org/" my:d:cloud)
      "Org directory.")
    (defvar my:d:blog
      (expand-file-name "devel/repos/mysite/" my:d:cloud)
      "Blog directory.")
    (defvar my:f:capture-blog-file
      (expand-file-name "all-posts.org" my:d:blog)
      "Default Org file for blog captures.")
    (defvar my:d:excluded-directories
      (list (expand-file-name "Library/Accounts" (getenv "HOME")))
      "Directories excluded from `load-path` for safety.")

    ;; Ensure directories exist
    (mapc #'my/ensure-directory-exists (list my:d:cloud my:d:org my:d:blog))

    ;; Recompute Org paths
    (setq org-directory my:d:org)
    (setq org-agenda-files
          (seq-filter (lambda (file)
                        (and (string-match-p "\\.org\\'" file)
                             (not (string-match-p "archives" file))))
                      (directory-files-recursively org-directory "\\.org\\'")))

    ;; Clean up load-path
    (setq load-path
          (seq-remove (lambda (dir)
                        (member dir my:d:excluded-directories))
                      load-path)))

  ;; -----------------------------------------------------------------------------
  ;; Smart Input Source (macOS only, requires macism)
  (leaf sis
    :if (eq system-type 'darwin)
    :straight t
    :commands (sis-ism-lazyman-config
               sis-global-cursor-color-mode
               sis-global-respect-mode
               sis-global-inline-mode)
    :hook (emacs-startup .
           (lambda ()
             (when (fboundp 'sis-ism-lazyman-config)
               (sis-ism-lazyman-config
                "com.apple.keylayout.ABC"
                "com.apple.inputmethod.Kotoeri.RomajiTyping.Japanese"
                'macism))
             (when (fboundp 'sis-global-cursor-color-mode)
               (sis-global-cursor-color-mode t))
             (when (fboundp 'sis-global-respect-mode)
               (sis-global-respect-mode t))
             (when (fboundp 'sis-global-inline-mode)
               (sis-global-inline-mode t)))))

  ;; Keep cursor color consistent after theme changes
  (add-hook 'after-load-theme-hook
            (lambda ()
              (set-face-background 'cursor (frame-parameter nil 'cursor-color))))

  ;; -----------------------------------------------------------------------------
  ;; Logitech MX Ergo S configuration
  (leaf *device/MX_ErgoS
    :straight nil
    :init
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control) . 10))
          mouse-wheel-progressive-speed nil
          scroll-conservatively 10000
          scroll-margin 2
          scroll-preserve-screen-position t
          mac-mouse-wheel-smooth-scroll t
          mouse-wheel-tilt-scroll t
          mouse-wheel-flip-direction nil)
    ;; Quick gestures
    (global-set-key [mouse-2] #'yank)
    (global-set-key [mouse-4] #'previous-buffer)
    (global-set-key [mouse-5] #'next-buffer))

  ;; -----------------------------------------------------------------------------
  ;; Apple Music Control (macOS only)
  (when (eq system-type 'darwin)
    ;; Core AppleScript helpers
    (defun my/apple-music-osascript-async (script &optional callback)
      "Run AppleScript SCRIPT asynchronously, invoking CALLBACK with its output."
      (let* ((proc-name "apple-music-async")
             (buffer-name "*Apple Music Async*")
             (osascript-cmd (list "osascript" "-e" script))
             (proc (apply #'start-process proc-name buffer-name osascript-cmd)))
        (when callback
          (set-process-sentinel
           proc
           (lambda (process event)
             (when (string= event "finished\n")
               (with-current-buffer (process-buffer process)
                 (let ((output (string-trim (buffer-string))))
                   (funcall callback output)))
               (kill-buffer (process-buffer process))))))))


    (defun my/apple-music-osascript-sync (script)
      "Run AppleScript SCRIPT synchronously and return trimmed output."
      (string-trim
       (shell-command-to-string
        (format "osascript -e '%s'" script))))

    ;; Player controls
    ;;;###autoload
    (defun my/apple-music-play-pause () (interactive)
      "Toggle play/pause in Apple Music."
      (my/apple-music-osascript-async "tell application \"Music\" to playpause"))

    ;;;###autoload
    (defun my/apple-music-next-track () (interactive)
      "Skip to the next track in Apple Music."
      (my/apple-music-osascript-async "tell application \"Music\" to next track"))

    ;;;###autoload
    (defun my/apple-music-previous-track () (interactive)
      "Return to the previous track in Apple Music."
      (my/apple-music-osascript-async "tell application \"Music\" to previous track"))

    ;; Track info
    ;;;###autoload
    (defun my/apple-music-current-track-info () (interactive)
      "Echo current track info: Title — Artist [Album]."
      (let ((info (my/apple-music-osascript-sync
                   "tell application \"Music\" \
  to (get name of current track) & \" — \" & (get artist of current track) & \" [\" & (get album of current track) & \"]\"")))
        (message "%s" info)
        info))

    ;; Playlists
    (defun my/apple-music-get-playlists ()
      "Return a list of playlist names from Apple Music."
      (split-string
       (my/apple-music-osascript-sync
        "tell application \"Music\" to get name of playlists")
       ", "))

    ;;;###autoload
    (defun my/apple-music-play-playlist (playlist)
      "Prompt for PLAYLIST and play it in Apple Music."
      (interactive
       (list (completing-read "Playlist: " (my/apple-music-get-playlists))))
      (my/apple-music-osascript-async
       (format "tell application \"Music\" to play playlist \"%s\"" playlist)))

    ;; Hydra UI (namespaced hydra: my/hydra-apple-music)
    (with-eval-after-load 'hydra
      (defhydra my/hydra-apple-music (:hint nil)
        "
  Apple Music:
  _p_: Play/Pause  _n_: Next  _b_: Back  _l_: Playlist  _i_: Info  _q_: Quit
  "
        ("p" my/apple-music-play-pause)
        ("n" my/apple-music-next-track)
        ("b" my/apple-music-previous-track)
        ("l" my/apple-music-play-playlist)
        ("i" my/apple-music-current-track-info)
        ("q" nil "quit"))
      (global-set-key (kbd "C-c m") #'my/hydra-apple-music/body)))

  (provide 'user)
  ;;; user.el ends here
#+end_src

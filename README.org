# -*- mode: org; coding: utf-8; -*-
#+TITLE: Modern Emacs Configuration
#+AUTHOR: YAMASHITA, Takao
#+EMAIL: tjy1965@gmail.com
#+LANGUAGE: en
#+OPTIONS: toc:3 num:t
#+STARTUP: overview
#+PROPERTY: header-args :results silent :exports code :mkdirp yes :padline no :tangle no
#+PROPERTY: header-args:emacs-lisp :lexical t :noweb no-export

* Introduction
:PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

A modern, literate Emacs configuration using Org Mode's Babel format, emphasizing performance, language server integration, AI assistance, and productivity.

** Features
:PROPERTIES:
:CUSTOM_ID: features
:END:

-  üöÄ *Performance & Native Compilation* ‚Äî Early-init moves ELN under `.cache/`, silences async warnings, widens GC at startup and restores sane values later, and uses GCMH for idle GC.
-  üß© *Language Server Protocol* ‚Äî Backend-agnostic helpers in `core/general.el`; choose *Eglot* or *lsp-mode* via `core/switches.el` with presence checks and auto-enable logic.
-  ü§ñ *AI Integration* ‚Äî Aidermacs (vterm backend). Prefers OpenRouter when `OPENROUTER_API_KEY` is set; otherwise uses OpenAI with `OPENAI_API_KEY`.
-  üé® *Modern UI & Editing* ‚Äî Tree-sitter remaps (`*-ts-mode`), ef-themes + spacious-padding, Nerd Icons, Vertico/Orderless/Corfu/CAPE/Embark/Consult, Doom/Nano modeline switchers.
-  üóÇÔ∏è *Productivity Tools* ‚Äî Opinionated Org stack (agenda, capture, journal, roam, download, TOC), Magit + diff-hl/Forge, REST client, Docker/dev helpers, tidy backups/autosave-visited.

[[file:demo.png]]

** Coding Rules
:PROPERTIES:
:CUSTOM_ID: conventions
:END:

- ‚úÖ `lexical-binding: t` is *mandatory*. The `(provide 'FEATURE)` *must match the file name* (e.g., `lisp/core.el` ‚Üí `(provide 'core)`).
- üìö Rely *only on official documentation*. Do *not* use private/undocumented APIs or speculative future behavior.
- üåø In every `leaf` form, group settings under *`:straight` / `:bind` / `:hook` / `:custom`* (in this order).
- üì¶ For built-in packages, *always* specify *`:straight nil`*.

*** ‚úÖ Per-module Checklist
- [ ] File header includes `-*- lexical-binding: t; -*-`
- [ ] `(provide '‚Ä¶)` matches the file‚Äôs feature name
- [ ] `leaf` keywords ordered: `:straight` ‚Üí `:bind` ‚Üí `:hook` ‚Üí `:custom`
- [ ] Built-ins use `:straight nil`
- [ ] `;;;###autoload` only for public commands (never for internal `--` helpers)

*** üß± Header Template
#+begin_src emacs-lisp
  ;;; module.el --- description -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; What it does: <short summary>
  ;; Category: <core|ui|completion|orgx|dev|vcs|utils>
  ;;
  ;;; Code:

  ;; ... code ...

  (provide 'module)
  ;;; module.el ends here
#+end_src

*** üåø Minimal `leaf` Skeleton
#+begin_src emacs-lisp
  (leaf some-package
    :straight t                           ;; Use :straight nil for built-in packages
    :bind (("C-c x" . some-package-do))   ;; Keybindings
    :hook ((prog-mode . some-package-mode)) ;; Hooks
    :custom ((some-package-option . t)))  ;; Custom options
#+end_src

*** üß™ Naming Mini-Examples
#+begin_src emacs-lisp
  (defvar ui-modeline-map (make-sparse-keymap)
    "Keymap for the modeline.")                      ;; -map suffix for keymaps

  (defun ui--on-window-config-changed ()
    "Internal hook handler for window configuration changes.")  ;; -- for internal helpers

  (defun utils-temp-file-p (path)
    "Return non-nil if PATH looks like a temporary file.")      ;; -p suffix for predicates
#+end_src

*** üß≠ Do / Don‚Äôt Quick Reference
| ‚úÖ Do                                         | ‚ùå Don‚Äôt                                  |
|----------------------------------------------+-------------------------------------------|
| Match `provide` name to file name            | Mismatch `provide` and file name          |
| Keep `leaf` sections in fixed order          | Scatter `:bind` / `:hook` randomly        |
| Use `:straight nil` for built-ins            | Set `:straight t` for built-ins           |
| Add `;;;###autoload` only to public commands | Add autoloads to internal `--` functions  |
| Verify against official docs                 | Depend on private/unstable APIs           |

** Installation
:PROPERTIES:
   :CUSTOM_ID: installation
   :END:

*** Prerequisites
:PROPERTIES:
:CUSTOM_ID: prerequisites
:END:

- *Required*
  - Emacs *30.0+* with native compilation (`--with-native-compilation`)
  - Git
  - GNU Make
  - GCC *10+* with `libgccjit`

- *Optional but Recommended*
  - ripgrep (`rg`) ‚Üí faster project-wide search
  - aspell or hunspell ‚Üí spell checking
  - pass + GnuPG ‚Üí password and auth-source integration
  - Homebrew (macOS only) ‚Üí for consistent toolchain installation

*** Building Emacs

Use the provided build script:
[[https://github.com/ac1965/dotfiles/blob/master/.local/bin/build-emacs.sh][build-emacs.sh]]

#+begin_src shell
  build-emacs.sh --native-compilation
#+end_src

*** Quick Start

1. Clone the repository:
   #+begin_src shell
     git clone --depth 1 https://github.com/ac1965/.emacs.d ~/.emacs.d/
   #+end_src

2. Tangle configuration:
   #+begin_src shell
     EMACS=/Applications/Emacs.app/Contents/MacOS/Emacs make -C ~/.emacs.d/ tangle
   #+end_src

*** Makefile

#+begin_src text :tangle Makefile :comments no
  # Makefile ‚Äî One-pass builder for a modular Emacs config
  # - Default / `make all` : onepass-init (tangle -> incremental byte-compile)
  # - `make onepass-q`     : -Q (minimal env) tangle -> full byte-compile
  # - Paths are absolutized from repo root to avoid "lisp/personal" confusion.

  SHELL := /bin/sh

  # ---- Repo-root & absolutized dirs --------------------------------------------
  ROOT := $(CURDIR)

  EMACS  ?= emacs
  ORG    ?= README.org
  EARLY  ?= early-init.el
  INIT   ?= init.el

  # Always treat these as top-level under repo root
  LISPDIR_REL     ?= lisp
  PERSONALDIR_REL ?= personal

  LISPDIR     := $(abspath $(ROOT)/$(LISPDIR_REL))
  PERSONALDIR := $(abspath $(ROOT)/$(PERSONALDIR_REL))
  ORG := $(abspath $(ROOT)/$(ORG))
  EARLY := $(abspath $(ROOT)/$(EARLY))
  INIT  := $(abspath $(ROOT)/$(INIT))

  STRICT_BYTE_WARN ?= 0   # Treat byte-compile warnings as errors
  NATIVE_COMPILE   ?= 1   # Prefer native-compile if available

  # ---- Emacs runners & common eval snippets ------------------------------------
  EMACS_BATCH := "$(EMACS)" --batch
  EMACS_Q     := $(EMACS_BATCH) -Q

  EVAL_STRICT := $(if $(filter 1,$(STRICT_BYTE_WARN)),--eval "(setq byte-compile-error-on-warn t)",)
  EVAL_NATIVE := $(if $(filter 1,$(NATIVE_COMPILE)),--eval "(setq comp-deferred-compilation t)",)

  # Optional leaf injection for -Q
  STRAIGHT_BASE_DIR ?= $(shell \
    if [ -f "$(EARLY)" ]; then \
      $(EMACS_Q) -l "$(EARLY)" \
        --eval "(princ (expand-file-name (or (ignore-errors STRAIGHT_BASE_DIR) \
                                             (ignore-errors (and (boundp 'straight-base-dir) straight-base-dir)) \
                                             (expand-file-name \"straight\" user-emacs-directory))))"; \
    else \
      printf "%s" "$$HOME/.emacs.d/straight"; \
    fi)
  LEAF_DIR   := $(STRAIGHT_BASE_DIR)/repos/leaf
  LEAFKW_DIR := $(STRAIGHT_BASE_DIR)/repos/leaf-keywords

  EVAL_LEAF := \
    --eval "(let* ((ldir \"$(LEAF_DIR)\") (kwdir \"$(LEAFKW_DIR)\")) \
              (when (file-directory-p ldir)  (add-to-list 'load-path ldir)) \
              (when (file-directory-p kwdir) (add-to-list 'load-path kwdir)) \
              (ignore-errors (require 'leaf)) \
              (ignore-errors (require 'leaf-keywords)) \
              (when (featurep 'leaf-keywords) (leaf-keywords-init)))"

  # ---- Default target (no args) ------------------------------------------------
  .PHONY: all onepass-init onepass-q clean distclean show-files echo-paths tangle
  all: onepass-init

  # ---- One-pass (early+init env) : tangle -> incremental compile ---------------
  onepass-init: $(ORG)
  	@echo "[onepass-init] tangle -> incremental byte-compile (init loaded)"
  	@$(EMACS_BATCH) -l "$(EARLY)" -l "$(INIT)" \
  	  $(EVAL_STRICT) $(EVAL_NATIVE) \
  	  --eval "(setq org-confirm-babel-evaluate nil)" \
  	  --eval "(require 'org)" \
  	  --eval "(org-babel-tangle-file \"$(ORG)\")" \
  	  --eval "(let* ((dirs (delq nil (list (and (file-directory-p \"$(LISPDIR)\") \"$(LISPDIR)\") \
  	                                        (and (file-directory-p \"$(PERSONALDIR)\") \"$(PERSONALDIR)\"))))) \
  	            (dolist (d dirs) (byte-recompile-directory d 0)) \
  	            (when (and (featurep 'comp) (bound-and-true-p comp-deferred-compilation)) \
  	              (dolist (d dirs) (ignore-errors (native-compile-async d 'recursively)))))" \
  	  --eval "(message \"[onepass-init] done\")"

  # ---- One-pass (-Q minimal env) : tangle -> full compile ----------------------
  onepass-q: $(ORG)
  	@echo "[onepass-q] -Q tangle -> full byte-compile (init not loaded)"
  	@$(EMACS_Q) \
  	  $(EVAL_LEAF) $(EVAL_STRICT) $(EVAL_NATIVE) \
  	  --eval "(setq org-confirm-babel-evaluate nil)" \
  	  --eval "(require 'org)" \
  	  --eval "(org-babel-tangle-file \"$(ORG)\")" \
  	  --eval "(let* ((dirs (delq nil (list (and (file-directory-p \"$(LISPDIR)\") \"$(LISPDIR)\") \
  	                                        (and (file-directory-p \"$(PERSONALDIR)\") \"$(PERSONALDIR)\"))))) \
  	            (dolist (d dirs) (byte-recompile-directory d t)) \
  	            (when (and (featurep 'comp) (bound-and-true-p comp-deferred-compilation)) \
  	              (dolist (d dirs) (ignore-errors (native-compile-async d 'recursively)))))" \
  	  --eval "(message \"[onepass-q] done\")"

  # ---- Utilities ---------------------------------------------------------------
  show-files:
  	@echo "[list] $(LISPDIR)";    { [ -d "$(LISPDIR)" ] && find "$(LISPDIR)" -type f -name '*.el' | sort; } || true
  	@echo "[list] $(PERSONALDIR)"; { [ -d "$(PERSONALDIR)" ] && find "$(PERSONALDIR)" -type f -name '*.el' | sort; } || true

  echo-paths:
  	@echo "ROOT=$(ROOT)"; \
  	echo "EARLY=$(EARLY)"; \
  	echo "INIT=$(INIT)"; \
  	echo "LISPDIR=$(LISPDIR)"; \
  	echo "PERSONALDIR=$(PERSONALDIR)"; \
  	echo "STRAIGHT_BASE_DIR=$(STRAIGHT_BASE_DIR)"; \
  	echo "LEAF_DIR=$(LEAF_DIR)"; \
  	echo "LEAFKW_DIR=$(LEAFKW_DIR)"

  clean:
  	@echo "[clean] remove *.elc under $(LISPDIR) and $(PERSONALDIR)"
  	@{ [ -d "$(LISPDIR)" ] && find "$(LISPDIR)" -type f -name '*.elc' -delete; } 2>/dev/null || true
  	@{ [ -d "$(PERSONALDIR)" ] && find "$(PERSONALDIR)" -type f -name '*.elc' -delete; } 2>/dev/null || true

  distclean: clean
  	@echo "[distclean] remove stray *.eln"
  	@find "$(ROOT)" -type f -name '*.eln' -delete

  tangle:
  	@echo "[tangle] $(ORG)"
  	@$(EMACS_Q) \
  	  --eval "(require 'org)" \
  	  --eval "(require 'ob-core)" \
  	  --eval "(org-babel-do-load-languages 'org-babel-load-languages '((emacs-lisp . t)))" \
  	  --eval "(setq org-confirm-babel-evaluate nil noninteractive t)" \
  	  --eval "(org-babel-tangle-file \"$(ORG)\")"
#+end_src

*** System Information

**** Apple Silicon (Primary)
- GNU Emacs *31.0.50*

|Property|Value|
|--------|-----|
|Commit|11860fe936cfbb9dc13ab728e5c9719b7e7721a3|
|Branch|master|
|System|aarch64-apple-darwin25.1.0|
|Date|2025-11-05 00:40:44 (JST)|
|Patch|N/A ns-inline.patch|
|Features|ACL DBUS GLIB GNUTLS LCMS2 LIBXML2 MODULES NATIVE_COMP NOTIFY KQUEUE NS PDUMPER PNG RSVG SQLITE3 THREADS TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM ZLIB|
|Options|--with-native-compilation --with-gnutls=ifavailable --with-json --with-modules --with-tree-sitter --with-xml2 --with-librsvg --with-mailutils --with-native-image-api --with-ns CPPFLAGS=-I/opt/homebrew/opt/llvm/include 'LDFLAGS=-L/opt/homebrew/opt/llvm/lib -L/opt/homebrew/opt/llvm/lib/c++ -Wl,-rpath,/opt/homebrew/opt/llvm/lib/c++'|

**** Intel (Secondary)
- GNU Emacs *31.0.50*

|Property|Value|
|--------|-----|
|Commit|63ea5e5b3a57e7660ece022ba1834002ca2f206d|
|Branch|master|
|System|x86_64-apple-darwin25.1.0|
|Date|2025-11-01 12:05:25 (JST)|
|Patch|N/A ns-inline.patch|
|Features|ACL DBUS GIF GLIB GMP GNUTLS JPEG LCMS2 LIBXML2 MODULES NATIVE_COMP NOTIFY KQUEUE NS PDUMPER PNG RSVG SQLITE3 THREADS TIFF TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM ZLIB|
|Options|--with-native-compilation --with-gnutls=ifavailable --with-json --with-modules --with-tree-sitter --with-xml2 --with-librsvg --with-mailutils --with-native-image-api --with-ns CPPFLAGS=-I/usr/local/opt/llvm/include 'LDFLAGS=-L/usr/local/opt/llvm/lib -L/usr/local/opt/llvm/lib/c++ -Wl,-rpath,/usr/local/opt/llvm/lib/c++'|

** Tools
:PROPERTIES:
   :CUSTOM_ID: tools
:END:

*** Flowchart

- *Boot Sequence Overview*

  early-init.el prepares GC/UI and paths ‚Üí init.el bootstraps packages and globals ‚Üí modules.el loads feature modules in a deterministic order ‚Üí core/switches.el resolves active stacks (UI/LSP) ‚Üí selected UI/LSP bundles are enabled.

#+begin_src mermaid
  sequenceDiagram
      autonumber
      participant Emacs
      participant Early as early-init.el
      participant Init as init.el
      participant Mods as lisp/modules.el
      participant Switch as core/switches.el
      participant UI as UI bundle (doom|nano)
      participant LSP as LSP backend (eglot|lsp-mode)

      Emacs->>Early: pre-init (dirs, GC, paths, UI off, native-comp path)
      Early-->>Emacs: provide 'early-init
      Emacs->>Init: main init (URL dirs ‚Üí straight bootstrap ‚Üí leaf init)
      Init->>Init: perf knobs (GCMH, read-process-output-max)
      Init->>Mods: (add-to-list 'load-path "lisp") ‚Üí require 'modules
      Mods->>Mods: my/modules-load (verbose timing, skip/extra)
      Mods->>Switch: require 'core/switches
      Switch->>UI: enable doom or nano (if present)
      Switch->>LSP: enable eglot or lsp-mode
      Mods-->>Init: modules loaded (ok/ng/skip/total)
      Init-->>Emacs: startup message (time, GCs)
#+end_src

- *Loader & Dependency Shape*

  modules.el enumerates lisp/** modules and (require ...) each feature, respecting my:modules-skip/my:modules-extra. Inside each module, leaf/require pulls package features. The require graph you capture (graph.el) mirrors this.

#+begin_src mermaid
  flowchart TD
    A[early-init.el] --> B[init.el]
    B --> C[modules.el]
    C --> D[core/switches.el]
    D --> E{UI stack?}
    E -->|nano| E1[palette ‚Üí theme ‚Üí modeline ‚Üí padding]
    E -->|doom| E2[preset ‚Üí theme ‚Üí modeline ‚Üí padding]
    D --> F{LSP stack?}
    F -->|eglot| F1[eglot setup]
    F -->|lsp-mode| F2[lsp-mode + lsp-ui setup]
#+end_src

- *UI Stack* (ex. nano)

#+begin_src mermaid
  flowchart LR
    subgraph Palette["ui/ui-nano-palette.el (palette)"]
      P1[nano-color-* defcustoms]
      P2[my/nano-apply-faces]
    end

    subgraph Theme["ui/ui-theme.el"]
      T1[nano-emacs]
      T2[nano-theme]
      T3[spacious-padding]
      T4[re-apply after theme]
    end

    subgraph Modeline["ui/ui-nano-modeline.el"]
      N1[nano-modeline hooks]
      N2[my/ui-enable-nano]
    end

    Palette --> Theme
    Theme --> Modeline
    Modeline -->|"core/switches.el"| Switch[UI switch]
#+end_src

- *Completion Stack*

#+begin_src mermaid
  flowchart LR
    Orderless["orderless"] --> Mini[Minibuffer]
    Vertico["vertico(+posframe)"] --> Mini
    Marginalia["marginalia"] --> Mini
    Consult["consult (xref glue)"] --> Search[Search/Navigation]
    Embark["embark(+embark-consult)"] --> Actions[Context actions]

    Corfu["corfu"] --> InBuf[In-buffer CAPF UI]
    KindIcon["kind-icon"] --> Corfu
    CAPE["cape (file,dabbrev,keyword)"] --> CAPF[completion-at-point-functions]

    CAPF --> Corfu
    Mini --> Consult
    Mini --> Embark
#+end_src

- *LSP Stack*

#+begin_src mermaid
  flowchart LR
    Switch["core/switches.el"] -->|my:use-lsp = eglot| Eglot["eglot (auto-enable when contact guessable)"]
    Switch -->|my:use-lsp = lsp| LSP["lsp-mode"]
    LSP --> LspUI["lsp-ui"]
#+end_src

- *ORG Stack*

#+begin_src mermaid
  flowchart LR
    Core["orgx/org-core"] --> Visual["orgx/org-visual (org-modern)"]
    Core --> Ext["orgx/org-extensions (journal/roam/download/toc/cliplink)"]
    Core --> Export["orgx/org-export (ox-hugo, md, preview, edit-indirect)"]
#+end_src

- *Dev/VCS Stack*

#+begin_src mermaid
  flowchart LR
    DevCore["core/tools (treesit helpers)"] --> Web["dev/web-core (TS remaps, project, editorconfig)"]
    DevCore --> Format["dev/format (Apheleia/Prettier)"]
    DevCore --> Term["dev/dev-term (vterm palette)"]
    DevCore --> Build["dev/dev-build"]
    DevCore --> Rest["dev/rest"]
    DevCore --> SQL["dev/sql"]
    DevCore --> Docker["dev/dev-docker"]
    DevAI["dev/dev-ai (Aidermacs)"]

    Magit["vcs/vcs-magit"] --> DiffHL["vcs/vcs-gutter (diff-hl)"]
    Magit --> Forge["vcs/vcs-forge"]
#+end_src

- *Makefile Pipeline*

#+begin_src mermaid
  flowchart LR
    T["Tangle README.org ‚Üí *.el (.tangle-stamp)"] --> C["compile (init.el load)"]
    T --> CQ["compile-q (-Q + leaf inject)"]
    C --> CP["compile-personal"]
    C --> CL["compile-lisp"]
    C -->|strict/nc knobs| Opt["STRICT_BYTE_WARN / NATIVE_COMPILE"]
    Clean["clean/distclean"] -->|remove .elc/.eln/.stamp| T
#+end_src

*** Graph capture (copy & tangle to lisp/tools/graph.el)
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/tools/graph.el
:END:

#+begin_src emacs-lisp
  ;;; tools/graph.el -*- lexical-binding: t; -*-

  (defvar graph/require-edges (make-hash-table :test 'equal))
  (defvar graph/require-seen (make-hash-table :test 'equal))

  (defun graph--record (from to)
    (when (and (symbolp from) (symbolp to))
      (let* ((k (format "%s->%s" from to)))
        (puthash k t graph/require-edges))))

  ;; Advice require to record edges
  (defun graph/require-advice (orig feature &optional filename noerror)
    (let* ((from (or load-file-name (buffer-file-name)))
           (from-sym (if from (intern (file-name-sans-extension (file-name-nondirectory from))) 'init))
           (to-sym (if (symbolp feature) feature (intern (format "%s" feature)))))
      (graph--record from-sym to-sym)
      (funcall orig feature filename noerror)))

  (defun graph/edge-list ()
    (sort (hash-table-keys graph/require-edges) #'string<))

  (defun graph/export-dot ()
    "Render recorded require edges as Graphviz DOT in *Require Graph (DOT)*."
    (interactive)
    (let ((buf (get-buffer-create "*Require Graph (DOT)*")))
      (with-current-buffer buf
        (erase-buffer)
        (insert "digraph G {\n  rankdir=LR;\n  node [shape=box, fontsize=10];\n")
        (dolist (e (graph/edge-list))
          (string-match "^\\([^->]+\\)->\\(.+\\)$" e)
          (insert (format "  \"%s\" -> \"%s\";\n" (match-string 1 e) (match-string 2 e))))
        (insert "}\n"))
      (pop-to-buffer buf)))

  (defun graph/export-mermaid ()
    "Render recorded require edges as Mermaid in *Require Graph (Mermaid)*."
    (interactive)
    (let ((buf (get-buffer-create "*Require Graph (Mermaid)*")))
      (with-current-buffer buf
        (erase-buffer)
        (insert "```mermaid\nflowchart LR\n")
        (dolist (e (graph/edge-list))
          (string-match "^\\([^->]+\\)->\\(.+\\)$" e)
          (insert (format "  %s --> %s\n" (replace-regexp-in-string "[./-]" "_" (match-string 1 e))
                          (replace-regexp-in-string "[./-]" "_" (match-string 2 e)))))
        (insert "```\n"))
      (pop-to-buffer buf)))

  ;;; Enable/disable capture
  (defun graph/enable-require-capture ()
    (interactive)
    (advice-add 'require :around #'graph/require-advice)
    (clrhash graph/require-edges)
    (message "[graph] require capture enabled"))

  (defun graph/disable-require-capture ()
    (interactive)
    (advice-remove 'require #'graph/require-advice)
    (message "[graph] require capture disabled"))

  (provide 'tools/graph)
  ;;; tools/graph.el ends here
#+end_src


#+begin_src emacs-lisp
(defun my/modules-summary-line ()
  "Display a concise summary of module loading and captured `require' edges.

The summary includes:
- Number of `require' edges captured by tools/graph (if available),
- Current value of `my:modules-verbose',
- Counts of `my:modules-skip' and `my:modules-extra'.

Safe even if those variables are unbound."
  (interactive)
  (let* ((edges-count
          ;; Handle both hash-table (preferred) and list fallbacks; otherwise N/A.
          (cond ((and (boundp 'graph/require-edges)
                      (hash-table-p graph/require-edges))
                 (hash-table-count graph/require-edges))
                ((and (boundp 'graph/require-edges)
                      (listp graph/require-edges))
                 (length graph/require-edges))
                (t "N/A")))
         (skip-count  (if (boundp 'my:modules-skip)
                          (length (or my:modules-skip '()))
                        0))
         (extra-count (if (boundp 'my:modules-extra)
                          (length (or my:modules-extra '()))
                        0))
         (msg (format "[modules] summary: edges=%s (require), verbose=%s, skip=%d, extra=%d"
                      edges-count
                      (if (boundp 'my:modules-verbose) my:modules-verbose nil)
                      skip-count
                      extra-count)))
    (message "%s" msg)
    msg))
#+end_src

#+begin_src emacs-lisp
  ;; Usage (run after init):
  (require 'tools/graph)
  (graph/enable-require-capture)
  ;; ;; Re-run the loader here via (require 'modules) or `M-x eval-buffer`
  ;; ;; After loading completes:
  (graph/export-mermaid) ;; or (graph/export-dot)
#+end_src

1) Tangle the Graph capture code into: lisp/tools/graph.el

2) Restart Emacs, then evaluate:
   M-: (require 'tools/graph)
   M-: (graph/enable-require-capture)

3) Run your loader:
   - Either: M-: (load "lisp/modules.el")
   - Or start Emacs normally so the loader runs as usual.

4) Export the graph:
   M-: (graph/export-mermaid)   ;; or M-: (graph/export-dot)

5) Paste the output into your Org/Markdown document.

6) (Optional) Get a numeric summary:
   M-: (my/modules-summary-line)

- Ready-to-paste examples

#+begin_src mermaid :file ./graphs/require-graph.svg :results file
%% Paste the Mermaid text generated by (graph/export-mermaid) below:
graph TD
  A[modules.el] --> B[core/general.el]
  %% ...
#+end_src

#+RESULTS:
[[file:./graphs/require-graph.svg]]

* Configuration Files
:PROPERTIES:
:CUSTOM_ID: structure
:END:

This Emacs configuration is modular and organized for *Emacs 30+*.

- `early-init.el` ‚Üí startup optimizations & directories
- `init.el` ‚Üí package bootstrap & base settings
- `lisp/` ‚Üí modular configs (core, ui, completion, org, dev, vcs, utils)
- `personal/` ‚Üí user-specific settings

** Core Bootstrap ‚Äî early-init.el & init.el
:PROPERTIES:
:CUSTOM_ID: core-bootstrap
:END:

*** Overview
**** Purpose
Provide a clean, fast, and macOS-friendly bootstrap that runs *before* regular initialization and sets safe defaults for directories, performance, package management (*straight.el + leaf*), and UI. The second stage (`init.el`) finishes bootstrapping (*straight.el*), imports the login environment on macOS, applies performance knobs, and exposes a deterministic module entrypoint.

**** What this configuration does
- Disables `package.el` early (we use *straight.el* and *leaf* exclusively).
- Speeds up startup (temporarily widen GC and clear `file-name-handler-alist`, then restore).
- Normalizes state locations under `.cache/`, `.etc/`, `.var/` (incl. *native-compile*).
- Prefers *Homebrew* toolchain on macOS (PATH, `LIBRARY_PATH`, and `CC` ‚Üí `gcc-N`).
- Turns *backupsd* and classic *auto-save* off early (you can use `auto-save-visited-mode` later).
- Applies early UI defaults to avoid flicker (no tool/menu/scroll bars, predictable frames).
- Bootstraps *straight.el* robustly (network download guarded with helpful error messages).
- Loads a minimal base of packages, initializes *leaf* keywords, and enables core performance tweaks (GCMH, `read-process-output-max`).
- Sets URL state paths *before* `url.el` loads (so *straight* inherits them).
- Provides a safe ‚Äúpersonal override‚Äù loader (`personal/<user>.el`) and a `modules.el` entrypoint.

**** Module map (where things live)
|File|Role|
|----+----|
| =early-init.el= |Pre-init bootstrap (dirs, performance, `package.el` off, macOS toolchain, early UI)|
| =init.el=      |Main init (URL state, straight bootstrap, env import, performance knobs, module loader)|

**** How it works (boot flow)
1. Emacs loads *early-init.el*:
   - Paths/dirs are established, `package.el` is disabled, GC/file-handlers are relaxed,
     UI is quieted, and macOS toolchain variables are prepared.
2. Emacs loads *init.el*:
   - URL state directories are set *before* `url.el`, then *straight.el* is bootstrapped.
   - On macOS GUI/daemon, the login environment is imported via *exec-path-from-shell*.
   - *leaf* is initialized and a few base packages are ensured.
   - Performance knobs (GCMH, `read-process-output-max`) are applied and later restored.
   - A per-user personal file is safely loaded, and `modules.el` acts as the entrypoint.
3. After init, a concise startup message is printed (time + GC count).

**** Key settings (reference)
- =package-enable-at-startup= :: =nil= ‚Äî rely on *straight.el*.
- =straight-base-dir= :: =.cache/= under your config base.
- =native-comp-eln-load-path= :: Uses =.cache/eln-cache= to keep artifacts tidy.
- =read-process-output-max= :: Temporarily raised to 4 MiB for better LSP/IO throughput.
- =gcmh-high-cons-threshold= :: 16 MiB; =gcmh-mode= on for smoother GC behavior.

**** Usage tips
- Keep customization out of `early-init.el`‚Äîtreat it as infrastructure. Put user-level
  behaviors into modules loaded from `init.el` (via `modules.el`) or `personal/<user>.el`.
- If you install `gcc`/`libgccjit` via Homebrew after Emacs is running, restart Emacs to
  pick up `LIBRARY_PATH`/`CC` changes for native compilation.
- To rehome all artifacts, move the config directory and Emacs will regenerate `.cache/`, `.etc/`, and `.var/`.

**** Troubleshooting
- *‚ÄúNative compilation can‚Äôt find libgccjit on macOS‚Äù* ‚Üí Ensure Homebrew‚Äôs
  `opt/libgccjit` exists and Emacs sees `LIBRARY_PATH`. Thais early-init sets it if present.
- *‚ÄúStraight bootstrap failed‚Äù* ‚Üí Network hiccup during `url-retrieve-synchronously`.
  Re-run; the code surfaces a clear `[straight] bootstrap failed: ...` message.
- *‚ÄúInhibit startup echo warning‚Äù* ‚Üí We set `inhibit-startup-echo-area-message` to your
  real user name string to satisfy Emacs‚Äô type constraint.

*** early-init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle early-init.el
:END:

#+begin_src emacs-lisp
  ;;; early-init.el --- Early initialization (core) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Core bootstrap executed before regular init.
  ;; Category: core
  ;;
  ;; - Disable package.el (we use straight.el + leaf)
  ;; - Fast startup: widen GC/file-name-handlers and restore after startup
  ;; - Keep artifacts under .cache/ .etc/ .var/ (native-compile, no-littering, straight)
  ;; - macOS: prefer Homebrew gcc/libgccjit (PATH/LIBRARY_PATH/CC)
  ;; - Backups OFF; classic auto-save OFF (use auto-save-visited in init)
  ;; - Early UI: frame defaults & hide GUI bars to avoid flicker
  ;;
  ;;; Code:

  (eval-when-compile (require 'subr-x))
  (require 'seq)

  ;;;; Internal helpers (core namespace) -----------------------------------------
  (defun core--ensure-directory-exists (dir)
    "Ensure DIR exists, creating it if necessary."
    (unless (file-directory-p dir)
      (condition-case err
          (make-directory dir t)
        (error (warn "Failed to create directory: %s (%s)"
                     dir (error-message-string err))))))

  (defun core--system-username ()
    "Return current login name as a string or nil."
    (ignore-errors (user-login-name)))

  (defun core--restore-startup-state ()
    "Restore GC and file handler settings after startup."
    (setq file-name-handler-alist core--orig-file-name-handler-alist
          gc-cons-threshold 16777216     ;; 16MB
          gc-cons-percentage 0.1))

  ;; Backward-compat public alias for existing configs
  (defalias 'my/ensure-directory-exists #'core--ensure-directory-exists)

  ;;;; 1) Disable package.el ------------------------------------------------------
  (setq package-enable-at-startup nil
       package-quickstart nil)

  ;;;; 2) Base directory ----------------------------------------------------------
  (defvar my:d
    (or (and load-file-name (file-name-directory (file-chase-links load-file-name)))
        user-emacs-directory)
    "Base directory for this Emacs configuration.")
  (setq user-emacs-directory (file-name-as-directory my:d))

  ;;;; 3) Hidden sub-directories --------------------------------------------------
  (defconst my:d:var        (expand-file-name ".var"        my:d))
  (defconst my:d:etc        (expand-file-name ".etc"        my:d))
  (defconst my:d:cache      (expand-file-name ".cache"      my:d))
  (defconst my:d:lisp       (expand-file-name "lisp"        my:d))
  (defconst my:d:eln-cache  (expand-file-name "eln-cache"   my:d:cache))
  (defconst my:d:treesit    (expand-file-name "tree-sitter" my:d:var))
  (defconst my:d:url        (expand-file-name "url/"        my:d:var)
    "Directory for url.* state (cookies, history, etc.) under my:d:var.")
  (defconst my:d:eww        (expand-file-name "eww/"        my:d:var)
    "Directory for EWW state (bookmarks, history) under my:d:var.")

  (dolist (dir (list my:d:var my:d:etc my:d:cache my:d:lisp
                     my:d:treesit my:d:url my:d:eww
                     my:d:eln-cache))
    (core--ensure-directory-exists dir))

  ;;;; 4) macOS: prefer Homebrew gcc/libgccjit -----------------------------------
  (when (eq system-type 'darwin)
    (let* ((brew-prefix
            (or (getenv "HOMEBREW_PREFIX")
                (and (file-directory-p "/opt/homebrew") "/opt/homebrew")
                (and (file-directory-p "/usr/local")   "/usr/local")))
           (bin  (and brew-prefix (expand-file-name "bin" brew-prefix)))
           (prefix-libgccjit (and brew-prefix (expand-file-name "opt/libgccjit" brew-prefix)))
           (prefix-gcc       (and brew-prefix (expand-file-name "opt/gcc"       brew-prefix)))
           (candidates (seq-filter
                        #'file-directory-p
                        (list
                         (and prefix-libgccjit (expand-file-name "lib/gcc/current" prefix-libgccjit))
                         (and prefix-libgccjit (expand-file-name "lib"             prefix-libgccjit))
                         (and prefix-gcc       (expand-file-name "lib/gcc/current" prefix-gcc))))))
      ;; PATH: prepend brew bin once.
      (when (and bin (file-directory-p bin))
        (let* ((path (or (getenv "PATH") ""))
               (parts (split-string path ":" t)))
          (unless (member bin parts)
            (setenv "PATH" (concat bin ":" path)))))
      ;; LIBRARY_PATH: add & de-dup.
      (when candidates
        (setenv "LIBRARY_PATH"
                (string-join
                 (delete-dups
                  (append candidates
                          (when-let* ((old (getenv "LIBRARY_PATH")))
                            (split-string old ":" t))))
                 ":")))
      ;; CC: pick highest gcc-N available.
      (when (and bin (file-directory-p bin))
        (when-let* ((gcc
                     (car (seq-filter
                           #'file-exists-p
                           (mapcar (lambda (n) (expand-file-name (format "gcc-%d" n) bin))
                                   (number-sequence 20 10 -1))))))
          (setenv "CC" gcc)))))

  ;;;; 5) Native compilation path (.cache/eln-cache) ------------------------------
  (when (featurep 'native-compile)
    (setopt native-comp-eln-load-path (list my:d:eln-cache)
            native-comp-async-report-warnings-errors 'silent))

  ;;;; 6) Pre-wire no-littering dirs ----------------------------------------------
  (defvar no-littering-etc-directory (file-name-as-directory my:d:etc))
  (defvar no-littering-var-directory (file-name-as-directory my:d:var))

  ;;;; 7) straight.el base under .cache/ ------------------------------------------
  (setopt straight-base-dir my:d:cache
  	straight-vc-git-default-clone-depth 1
          straight-use-package-by-default t
  	straight-build-dir (format "build-%s" emacs-version)
          straight-profiles '((nil . "default.el")))

  ;;;; 8) Startup speedups (restore after startup) --------------------------------
  (defvar core--orig-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil
        gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)
  (add-hook 'emacs-startup-hook #'core--restore-startup-state)

  ;;;; 9) Backups OFF / classic auto-save OFF -------------------------------------
  (setq make-backup-files nil
        version-control nil
        delete-old-versions nil
        backup-by-copying nil
        auto-save-default nil
        auto-save-list-file-prefix nil)
  (core--ensure-directory-exists (expand-file-name "backups" my:d:var))

  ;;;; 10) Early UI (avoid flicker) ----------------------------------------------
  (setopt frame-resize-pixelwise t
          frame-inhibit-implied-resize t
          cursor-in-non-selected-windows nil
          x-underline-at-descent-line t
          window-divider-default-right-width 16
          window-divider-default-places 'right-only)

  (dolist (it '((fullscreen . fullboth)
                (undecorated . nil)
                (internal-border-width . 8)
                (left-fringe . 0)
                (right-fringe . 0)
                (tool-bar-lines . 0)))
    (add-to-list 'default-frame-alist it)
    (add-to-list 'initial-frame-alist it))

  (when (fboundp 'menu-bar-mode)  (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode)  (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode)(scroll-bar-mode -1))

  ;; Correct type: must be user name string.
  (let ((u (core--system-username)))
    (when (stringp u)
      (setq inhibit-startup-echo-area-message u)))

  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle init.el
:END:

#+begin_src emacs-lisp
  ;;; init.el --- Main initialization (core) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Entry point for Emacs 30+ configuration.
  ;; Category: core
  ;;
  ;; - URL state paths (before url.el)
  ;; - straight.el bootstrap
  ;; - Early import of shell environment (exec-path-from-shell)
  ;; - Performance (GCMH / read-process-output-max)
  ;; - Core built-ins via leaf (do not duplicate early-init responsibilities)
  ;; - Backups OFF + auto-save-visited managed elsewhere (early-init / core)
  ;;
  ;;; Code:

  (eval-when-compile (require 'subr-x))

  ;;;; 0) URL state BEFORE url.el is loaded --------------------------------------
  (setopt url-configuration-directory (or (bound-and-true-p my:d:url)
                                          (expand-file-name "url/" user-emacs-directory))
          url-cookie-file  (expand-file-name "cookies" url-configuration-directory)
          url-history-file (expand-file-name "history" url-configuration-directory)
          url-cache-directory (expand-file-name "cache" url-configuration-directory))
  (dolist (d (list url-configuration-directory url-cache-directory))
    (when d (make-directory d t)))
  (require 'url)  ;; used by straight bootstrap

  ;;;; 1) Bootstrap straight.el ---------------------------------------------------
  (defvar bootstrap-version 7)
  (let* ((base (or (bound-and-true-p straight-base-dir) user-emacs-directory))
         (bootstrap-file (expand-file-name "straight/repos/straight.el/bootstrap.el" base)))
    (unless (file-exists-p bootstrap-file)
      (condition-case err
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp))
        (error (user-error "[straight] bootstrap failed: %s"
                           (error-message-string err)))))
    (load bootstrap-file nil 'nomessage))

  ;;;; 1.5) Import environment early (macOS GUI/daemon safe) ---------------------
  (straight-use-package 'exec-path-from-shell)
  (when (memq window-system '(mac ns))
    (setq exec-path-from-shell-check-startup-files nil
          exec-path-from-shell-arguments '("-l" "-i"))
    (exec-path-from-shell-copy-envs
     '("PATH" "LANG" "PASSWORD_STORE_DIR" "GPG_KEY_ID"
       "OPENROUTER_API_KEY" "OPENAI_API_KEY"))
    (exec-path-from-shell-initialize))

  (defun my/straight-install (pkgs)
    "Install PKGS via straight-use-package with simple timing/log."
    (let ((t0 (float-time)))
      (dolist (p pkgs)
        (let ((s (float-time)))
          (condition-case e
              (progn
                (straight-use-package p)
                (message "OK  %-18s  %4.2fs" p (- (float-time) s)))
            (error
             (message "ERR %-18s  %4.2fs  %s" p (- (float-time) s) (error-message-string e))))))
      (message "Total %4.2fs" (- (float-time) t0))))

  ;; Base packages
  (defvar my:bootstrap-packages-base
    '(leaf leaf-keywords leaf-convert blackout helpful imenu-list hydra org)
    "Base packages you‚Äôll want to install in any environment.")

  (my/straight-install my:bootstrap-packages-base)

  (eval-when-compile
    (require 'leaf)
    (require 'leaf-keywords))
  (when (fboundp 'leaf-keywords-init)
    (leaf-keywords-init))
  (require 'org)

  ;;;; 2) Performance tweaks ------------------------------------------------------
  (defvar core--orig-read-process-output-max
    (and (boundp 'read-process-output-max) read-process-output-max))
  (when (boundp 'read-process-output-max)
    (setq read-process-output-max (* 4 1024 1024)))  ;; 4MB for LSP/IO
  (add-hook 'emacs-startup-hook
            (lambda ()
              (when (boundp 'read-process-output-max)
                (setq read-process-output-max core--orig-read-process-output-max))))

  (leaf gcmh
    :straight t
    :custom ((gcmh-idle-delay . 5)
             (gcmh-high-cons-threshold . 16777216)) ;; 16MB
    :config
    (gcmh-mode 1))

  ;;;; 3) Core built-ins (do NOT duplicate early-init responsibilities) ----------
  (leaf emacs
    :straight nil
    :bind (("M-/" . cape-dabbrev))
    :hook ((prog-mode . display-line-numbers-mode))
    :custom ((inhibit-startup-screen . t)
             (inhibit-startup-message . t)
             (initial-scratch-message . nil)
             (initial-major-mode . 'fundamental-mode)  ;; must be quoted
             (use-short-answers . t)
             (create-lockfiles . nil)
             (idle-update-delay . 0.2)
             (ring-bell-function . #'ignore)          ;; function value must be #'quoted
             (display-line-numbers-type . 'relative)  ;; <-- quote the symbol
             (frame-title-format . t))
    :config
    (when (fboundp 'window-divider-mode) (window-divider-mode 1))
    (when (fboundp 'pixel-scroll-precision-mode) (pixel-scroll-precision-mode 1))
    (when (fboundp 'electric-pair-mode) (electric-pair-mode 1))
    (dolist (k '("C-z" "C-x C-z" "C-x C-c" "M-z" "M-m"))
      (when (lookup-key (current-global-map) (kbd k))
        (keymap-global-unset k)))
    (setq confirm-kill-emacs #'y-or-n-p)
    ;; backup/auto-save policy is handled in early-init and core/editing; do not duplicate here.
    )

  ;;;; 4) Modifiers per OS --------------------------------------------------------
  (leaf my:modifier
    :straight nil
    :config
    (pcase system-type
      ('darwin
       (setq mac-option-modifier 'meta
             mac-command-modifier 'super
             mac-control-modifier 'control
             mac-function-modifier 'hyper))
      ('windows-nt
       (setq w32-lwindow-modifier 'super
             w32-rwindow-modifier 'super
             w32-apps-modifier   'hyper))
      (_ nil)))

  ;;;; 5) Files and environment ---------------------------------------------------
  ;; ‚õ≥ duplicate exec-path-from-shell block removed (initialized earlier).
  (leaf no-littering :straight t)

  ;; macOS: complement exec-path/PATH with Homebrew bin (just in case).
  (when (eq system-type 'darwin)
    (dolist (p '("/opt/homebrew/bin" "/usr/local/bin"))
      (when (and (file-directory-p p) (not (member p exec-path)))
        (add-to-list 'exec-path p)
        (unless (and (getenv "PATH") (string-match-p (regexp-quote p) (getenv "PATH")))
          (setenv "PATH" (concat p ":" (getenv "PATH")))))))

  ;;;; 6) Dired display settings --------------------------------------------------
  ;; ‚õ≥ moved to core/editing.el to avoid split/duplication. (section removed)

  ;;;; 7) Personal file loader ----------------------------------------------------
  (defun utils--safe-load-file (file &optional noerror)
    "Load FILE safely. If NOERROR is non-nil, log instead of raising."
    (when (and file (file-exists-p file))
      (condition-case err
          (load file nil 'nomessage)
        (error
         (funcall (if noerror #'message #'user-error)
                  "[load] failed to load %s: %s"
                  file (error-message-string err))))))
  (defalias 'my/safe-load-file #'utils--safe-load-file)

  (my/safe-load-file
   (expand-file-name (concat "personal/" user-login-name ".el")
                     (or (bound-and-true-p my:d) user-emacs-directory))
   t)

  ;;;; 8) Modules entrypoint ------------------------------------------------------
  (let* ((root (or (and (boundp 'my:d) (stringp my:d) (file-directory-p my:d) my:d)
                   user-emacs-directory))
         (lisp-dir (expand-file-name "lisp" root)))
    (add-to-list 'load-path lisp-dir)
    (defvar my:modules-extra nil)
    (require 'core/custom-ui-extras) ;; Initialize the extras prior to loading the modules.
    (require 'modules nil t))

  ;;;; 9) Startup message ---------------------------------------------------------
  (defun core--announce-startup ()
    "Report startup time and GC count to *Messages*."
    (message "Emacs ready in %.2f seconds with %d GCs."
             (float-time (time-subtract after-init-time before-init-time))
             gcs-done))
  (add-hook 'after-init-hook
            (lambda () (run-with-idle-timer 0 nil #'core--announce-startup)))

  (provide 'init)
  ;;; init.el ends here
#+end_src

** Modular Loader & Core Module Suite ‚Äî `modules.el` + core/ui/completion/orgx/dev/utils
:PROPERTIES:
:CUSTOM_ID: modular-loader-and-core-suite
:END:
*** Overview
**** Purpose
Provide a *deterministic, modular Emacs 30+ configuration* that is:
- *Composable*: modules live under =lisp/= and load in a fixed order.
- *Selectable*: enable/skip modules and switch *UI* and *LSP* backends at runtime.
- *Low-noise*: route Customize output to =.etc/custom.el=; keep writable state under =.var/=.

**** What this configuration does
- *Bootstraps modules* via =modules.el=, honoring:
  - =my:modules-verbose= for per-module timings + summary logs,
  - =my:modules-skip= to omit features,
  - =my:modules-extra= to append features at the end.
- *Switches UI/LSP stack* centrally (=core/switches.el=):
  - UI: =none | doom | nano=
  - LSP: =eglot | lsp=
- *Hardens daily UX* with focused cores:
  - Editing & Dired defaults; undo stack (=undo-fu= / =vundo=); window ops (=ace-window=),
  - Session (saveplace/recentf/savehist/desktop/winner); autosave policy,
  - Utilities (auto-tangle updated Org blocks, scratch auto-recreate, backups GC).
- *UI surface*:
  - Fonts/ligatures, theme (nano-theme + spacious-padding), Treemacs, Minions, time/battery,
  - Optional *nano-modeline* or *doom-modeline* bundles.
- *Development surface*:
  - Tree-sitter grammars + language remaps; project/editorconfig,
  - Eglot or lsp-mode (+ lsp-ui); Apheleia formatting; Docker/REST/SQL helpers,
  - Aidermacs integration under =~/.var/aideremacs/=.
- *Completion surface (stacked)*:
  - Orderless + Vertico (+ Marginalia),
  - Corfu (+ kind-icon, CAPE) for in-buffer CAPF completion,
  - Consult (+ Embark / embark-consult) for search/actions.

**** Module map (where things live)
| Module file                      | Role / Notes                                                                                 |
|----------------------------------+----------------------------------------------------------------------------------------------|
| =modules.el=                       | Central loader; honors =my:modules-verbose/skip/extra=; prints per-module timings.             |
| =core/custom.el=                   | Route Customize to =.etc/custom.el=; helpers to open/dump curated vars/faces.                  |
| =core/editing.el=                  | Paredit/Puni, paren/visuals, Dired + GNU ls on macOS, undo-fu/vundo, aggressive-indent, etc. |
| =core/general.el=                  | Non-modal global *leader* (s-SPC on macOS / C-c SPC otherwise), helpers, which-key labels.     |
| =core/history.el=                  | saveplace/recentf/savehist setup (in =.var/=), adds safe directories & variables.              |
| =core/switches.el=                 | =my:use-ui= (none/doom/nano) and =my:use-lsp= (eglot/lsp) enablement with presence checks.       |
| =core/tools.el=                    | Win split toggle, keybinding conflict scanner, Tree-sitter install/ensure, Org fold helpers. |
| =core/utils.el=                    | Auto-tangle updated Org, insert lexical-binding headers under =.var/=, view-mode on RO.        |
| =ui/ui-font.el=                    | Default/emoji font selection, daemon-safe apply, optional ligatures.                         |
| =ui/ui-theme.el=                   | nano-theme colors + spacious-padding; face normalization on theme enable.                    |
| =ui/ui-window.el=                  | Zoom focus layout, desktop save/restore, winner, quick layout save/restore.                  |
| =ui/ui-utils.el=                   | Minions, display-time/battery, Treemacs & nerd-icons-dired, pbcopy on macOS.                 |
| =ui/ui-nano-modeline.el=           | Nano modeline bundle wrapper (idempotent hooks, guarded require).                            |
| =ui/ui-doom-modeline.el=           | Doom modeline bundle (nerd-icons).                                                           |
| =completion/completion-core.el=    | Orderless + category overrides (partial-completion for files).                               |
| =completion/completion-vertico.el= | Vertico (+ posframe on GUI) and Marginalia.                                                  |
| =completion/completion-consult.el= | Consult (xref glue).                                                                         |
| =completion/completion-embark.el=  | Embark + embark-consult integration.                                                         |
| =completion/completion-corfu.el=   | Corfu (+ kind-icon) + CAPE sources; TAB navigation.                                          |
| =completion/completion-icons.el=   | nerd-icons for ibuffer/completion surfaces.                                                  |
| =orgx/org-core.el=                 | Org core; agenda refs, capture, refile targets, directories under =.var/org=.                  |
| =orgx/org-visual.el=               | org-modern visuals, agenda layout/icons.                                                     |
| =orgx/org-extensions.el=           | org-journal, org-roam, org-download, toc-org, org-cliplink.                                  |
| =orgx/org-export.el=               | ox-hugo, markdown-mode/preview, edit-indirect.                                               |
| =dev/web-core.el=                  | Treesit remaps; project/files/editorconfig; TS/TSX/YAML/JSON associations.                   |
| =dev/dev-lsp-eglot.el=             | Eglot baseline; safe auto-enable when server contact is guessable.                           |
| =dev/dev-lsp-mode.el=              | lsp-mode (+ lsp-ui); LSP completion delegated to Corfu.                                      |
| =dev/format.el=                    | Apheleia global mode; Prettier(d) wiring for web stacks.                                     |
| =dev/dev-build.el=                 | Make/compile integration; ANSI color in compile buffer.                                      |
| =dev/dev-docker.el=                | Dockerfile/YAML modes, =docker= commands, tramp-container.                                     |
| =dev/dev-term.el=                  | vterm + vterm-toggle keybindings and display rules.                                          |
| =dev/rest.el=                      | restclient (+ jq).                                                                           |
| =dev/sql.el=                       | SQL defaults (PostgreSQL), sql-indent, sqlformat (pgformatter).                              |
| =utils/utils-functions.el=         | General helpers (smart kill-buffer).                                                         |
| =utils/utils-backup.el=            | GC old backups in =.var/backup/= at startup.                                                   |
| =utils/utils-async.el=             | Safe async runner with error trap.                                                           |
| =utils/search-nav.el=              | ripgrep via Consult; dumb-jump Xref backend; EWW helpers + image toggle.                     |

**** How it works (flow)
1. *Load order*
   =modules.el= builds a final list from =my:modules= + =my:modules-extra= minus =my:modules-skip=, then =require='s each feature with error trapping and (optionally) prints timing.
2. *Switch centers*
   =core/switches.el= checks presence, then enables the selected *UI* bundle (=doom=/=nano=) and *LSP* (=eglot=/=lsp=) via autoloaded entry functions.
3. *State & Customize*
   =core/custom.el= sets =custom-file= to =.etc/custom.el=, ensures the file/dir exist, and provides commands to open/dump curated settings and faces.
4. *Daily UX*
   Editing/Dired/window/session modules apply sane defaults; UI modules configure fonts/themes/modeline; the completion stack is layered; dev modules wire LSP/Tree-sitter/formatting.
5. *Org & export*
   Org directories live under =.var/org/‚Ä¶=; visuals via org-modern; export helpers (ox-hugo/Markdown) are available.

**** Key settings (reference)
- *Loader*
  - =my:modules-verbose= :: non-nil ‚Üí per-module timing + summary
  - =my:modules-skip= :: list of =feature= symbols to skip (e.g., ='(dev/dev-docker)=)
  - =my:modules-extra= :: list of =feature= symbols appended after defaults
- *Switches*
  - =my:use-ui= :: one of ='none 'doom 'nano=
  - =my:use-lsp= :: one of ='eglot 'lsp=
- *Tree-sitter*
  - =treesit-language-source-alist= :: upstream repos; grammars under =my:d:var/tree-sitter/=
  - =treesit-extra-load-path= :: includes =my:d:treesit=
  - =my/treesit-ensure= :: install missing grammars safely (Emacs 30 Tree-sitter API)
- *Customize & State*
  - =custom-file= :: ‚Üí =.etc/custom.el=
  - Writable runtime :: under =.var/= (savehist/recentf/saveplace/desktop/transient/backup/‚Ä¶)
- *Leader (non-modal)*
  - macOS: =s-SPC=, else: =C-c SPC= ‚Üí grouped submaps (=b, w, p, g, c, e, t, o, m, a, q, h=)

**** Usage tips
- *Skip slow/unused* modules via =my:modules-skip= (e.g., temporarily exclude =dev/dev-docker=).
- *Append experimentals* with =my:modules-extra= so they load after the stable base.
- *Flip UI/LSP* quickly: set =my:use-ui= / =my:use-lsp= before the loader runs (or re-eval switches).
- *Install Tree-sitter grammars* once with =M-x my/treesit-ensure=; re-run after adding languages.
- *Keep Customize clean*: use =M-x my/custom-open= / =my/custom-dump-current= to curate what‚Äôs persisted.

**** Troubleshooting
- *‚ÄúNano modeline didn‚Äôt enable‚Äù* ‚Üí The wrapper defers until =nano-modeline= is available; ensure the package is installed, then run =M-x my/ui-enable-nano=.
- *‚ÄúLSP not engaging in some buffers (Eglot)‚Äù* ‚Üí Eglot auto-enables only when a server contact is guessable; run =M-x eglot= or add a project config.
- *‚ÄúTree-sitter install error‚Äù* ‚Üí Requires Emacs built with Tree-sitter; verify =M-: (featurep 'treesit)= and install Xcode/Build deps on macOS.
- *‚ÄúGNU ls not found on macOS Dired‚Äù* ‚Üí Install coreutils via Homebrew so =gls= is available, or fall back to built-in =ls= with reduced features.

**** Related source blocks (ready to paste; no tangle)
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
#+begin_src emacs-lisp
  ;; --- Loader knobs -------------------------------------------------------------
  (setq my:modules-verbose t)
  (setq my:modules-skip  '(dev/dev-docker))        ;; example: skip docker during CI
  (setq my:modules-extra '(utils/utils-async))     ;; example: append extras at the end

  ;; --- Switch your stacks -------------------------------------------------------
  (setq my:use-ui  'nano)  ;; 'none | 'doom | 'nano
  (setq my:use-lsp 'eglot) ;; 'eglot | 'lsp

  ;; --- Run the loader (modules.el must be on load-path) ------------------------
  (require 'modules)  ;; provides `my/modules-load` and runs it once at the end
  ;; If you prefer explicit invocation, comment the last line of modules.el and call:
  ;; (my/modules-load)

  ;; --- Tree-sitter bootstrapping (run once; re-run when adding languages) ------
  (when (fboundp 'my/treesit-ensure)
    (my/treesit-ensure))

  ;; --- Customize file helpers ---------------------------------------------------
  ;; Open the curated customize file:
  ;;   M-x my/custom-open
  ;; Dump a curated snapshot of selected vars/faces:
  ;;   M-x my/custom-dump-current
#+end_src

*** modules.el
:PROPERTIES:
:CUSTOM_ID: core-modules
:header-args:emacs-lisp: :tangle lisp/modules.el
:END:

#+begin_src emacs-lisp
  ;;; modules.el --- Modular config loader -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;;; Commentary:
  ;; Central entry point to load modular configs placed under lisp/.
  ;; Category: core
  ;;
  ;;; Code:

  (eval-when-compile (require 'subr-x)) ;; string-join, etc.
  ;; If your build complains about seq at byte-compile time, uncomment:
  ;; (eval-when-compile (require 'seq))

  (defgroup my:modules nil
    "Loader options for modular Emacs configuration."
    :group 'convenience)

  (defcustom my:modules-verbose t
    "If non-nil, print per-module load time and a summary."
    :type 'boolean
    :group 'my:modules)

  (defcustom my:modules-skip nil
    "List of module features to skip during loading."
    :type '(repeat symbol)
    :group 'my:modules)

  (defcustom my:modules-extra nil
    "List of extra module features to append after `my:modules'."
    :type '(repeat symbol)
    :group 'my:modules)

  (defconst my:modules
    '(
      ;; Core
      core/fixes
      core/general
      core/tools
      core/utils
      core/history
      core/editing
      core/switches
      core/custom

      ;; UI
      ui/ui-font
      ui/ui-theme
      ui/ui-window
      ui/ui-utils

      ;; Completion
      completion/completion-core
      completion/completion-vertico
      completion/completion-consult
      completion/completion-embark
      completion/completion-corfu
      completion/completion-icons

      ;; Org ecosystem (module namespace = orgx/)
      orgx/org-core
      orgx/org-visual
      orgx/org-extensions
      orgx/org-export

      ;; ;; VCS (uncomment when needed)
      ;; vcs/vcs-magit
      ;; vcs/vcs-gutter
      ;; vcs/vcs-forge

      ;; Development
      dev/dev-ai
      dev/dev-term
      dev/dev-build
      dev/dev-docker

      ;; Web/Infra
      dev/web-core
      dev/format
      dev/infra-modes
      dev/sql
      dev/rest

      ;; Utils
      utils/utils-functions
      utils/utils-scratch
      utils/utils-backup
      utils/utils-async
      utils/search-nav
      )
    "Default set of modules to load in order.")

  (defun my/modules--should-load-p (feature)
    "Return non-nil if FEATURE should be loaded (i.e., not in skip list)."
    (not (memq feature my:modules-skip)))

  (defun my/modules--require-safe (feature)
    "Require FEATURE with error trapping. Return non-nil on success.
  Errors are reported via `message' but do not abort the whole loader."
    (condition-case err
        (progn (require feature) t)
      (error
       (message "[modules] Failed to load %s: %s"
                feature (error-message-string err))
       nil)))

  (defun my:modules--format-seconds (sec)
    "Format SEC (float seconds) in a compact human-readable form."
    (cond
     ((< sec 0.001) (format "%.3fms" (* sec 1000.0)))
     ((< sec 1.0)   (format "%.1fms"  (* sec 1000.0)))
     (t             (format "%.2fs"   sec))))

  (defun my/modules-load ()
    "Load all modules defined by `my:modules', respecting options.
  - Honors `my:modules-skip' and `my:modules-extra'.
  - Prints per-module timing when `my:modules-verbose' is non-nil.
  - Prints a final summary including counts *and* the lists of skipped/failed."
    (let* ((all (append my:modules my:modules-extra))
           (final (seq-remove (lambda (m) (not (my/modules--should-load-p m))) all))
           (skipped (seq-remove (lambda (m) (memq m final)) all))
           (ok 0) (ng 0)
           (failed '())
           (loaded '())
           (t0 (and my:modules-verbose (current-time))))
      (dolist (mod final)
        (let ((m0 (and my:modules-verbose (current-time))))
          (if (my/modules--require-safe mod)
              (progn (setq ok (1+ ok)) (push mod loaded))
            (setq ng (1+ ng)) (push mod failed))
          (when my:modules-verbose
            (message "[modules] %-24s %s"
                     mod (my:modules--format-seconds
                          (float-time (time-subtract (current-time) m0)))))))
      (when my:modules-verbose
        ;; Main summary (backward-compatible)
        (message "[modules] loaded=%d skipped=%d failed=%d total=%s"
                 ok (length skipped) ng
                 (my:modules--format-seconds
                  (float-time (time-subtract (current-time) t0))))
        ;; Detail: skipped targets
        (when skipped
          (message "[modules] skipped (%d): %s"
                   (length skipped)
                   (mapconcat #'symbol-name (nreverse skipped) " ")))
        ;; Detail: failed targets
        (when failed
          (message "[modules] failed  (%d): %s"
                   (length failed)
                   (mapconcat #'symbol-name (nreverse failed) " "))))
      ok))

  (my/modules-load)

  (provide 'modules)
  ;;; modules.el ends here
#+end_src

*** core/fixes.el
:PROPERTIES:
:CUSTOM_ID: core-fixes
:header-args:emacs-lisp: :tangle lisp/core/fixes.el
:END:

#+begin_src emacs-lisp
  ;;; core/fixes.el --- Final patch for Emacs 30.1 after-load bug -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; Prevents "void-variable thisfile" and ensures safe `after-load` evaluation.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; ------------------------------------------------------------
  ;; Core safeguard functions
  ;; ------------------------------------------------------------

  (defvar thisfile nil
    "Dynamically bound to the file currently being loaded.
  Hard-defined to avoid `void-variable` errors on Emacs 30.1.")

  (defun my:with-thisfile--load (orig file &rest args)
    "Ensure `thisfile` is bound when FILE is being loaded."
    (let* ((fname (cond
                   ((stringp file) (ignore-errors (expand-file-name file)))
                   (t file)))
           (thisfile (or (and (boundp 'thisfile) thisfile) fname)))
      (apply orig file args)))

  (defun my:with-thisfile--require (orig feature &optional filename noerror)
    "Ensure `thisfile` is bound when FEATURE is required."
    (let* ((lib (or (and filename (locate-library filename))
                    (locate-library (symbol-name feature))
                    filename
                    (symbol-name feature)))
           (thisfile (or (and (boundp 'thisfile) thisfile) lib)))
      (funcall orig feature filename noerror)))

  (defun my:guard-after-load (orig-fn file)
    "Ensure `thisfile` is safely bound during `do-after-load-evaluation`."
    (let ((thisfile (or (and (boundp 'thisfile) thisfile) file)))
      (condition-case _
          (funcall orig-fn file)
        (void-variable
         (let ((thisfile file))
           (ignore-errors (funcall orig-fn file)))))))

  ;; ------------------------------------------------------------
  ;; Activate patch
  ;; ------------------------------------------------------------

  (leaf core-fixes
    :straight nil
    :init
    (advice-add 'load :around #'my:with-thisfile--load)
    (advice-add 'require :around #'my:with-thisfile--require)
    (when (fboundp 'do-after-load-evaluation)
      (ignore-errors
        (advice-remove 'do-after-load-evaluation #'my:guard-after-load))
      (advice-add 'do-after-load-evaluation :around #'my:guard-after-load))
    (message "[core/fixes] Hardening active: global thisfile + load/require guards."))

  (provide 'core/fixes)
  ;;; core/fixes.el ends here
#+end_src

*** core/genral.el
:PROPERTIES:
:CUSTOM_ID: core-general
:header-args:emacs-lisp: :tangle lisp/core/general.el
:END:

#+begin_src emacs-lisp
  ;;; core/general.el --- General settings & keybindings (NO Meow) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; - Drop Meow: provide a non-modal, global leader-key layout.
  ;; - Keep useful global bindings for macOS-like shortcuts and muscle memory.
  ;; - Provide LSP-agnostic helpers (code actions, rename, format).
  ;; - Authentication helpers (GPG + pass) remain as-is.
  ;;
  ;; Design notes:
  ;; - We define a global leader key (C-c SPC).
  ;; - Under the leader, we expose groups: b(buffers), w(windows), p(project), g(git),
  ;; c(code), e(errors), t(toggles), o(org/roam), m(mode-specific), a(ai), q(session), h(help).
  ;; - "m" is reserved as a local leader prefix for major-mode specific commands.
  ;; - Which-Key labels reflect the chosen leader key at runtime.
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x))

  (defvar plstore-secret-keys)
  (defvar plstore-encrypt-to)

  (autoload 'magit-status "magit")
  (autoload 'magit-blame-addition "magit")
  (autoload 'magit-log-current "magit")
  (autoload 'magit-diff-buffer-file "magit")
  (autoload 'magit-commit "magit")

  (autoload 'flymake-goto-next-error "flymake")
  (autoload 'flymake-goto-prev-error "flymake")
  (autoload 'flymake-show-buffer-diagnostics "flymake")

  (autoload 'project-roots "project")

  ;;;; Text scaling hydra --------------------------------------------------------
  (leaf hydra
    :straight t
    :config
    (defhydra core-hydra-text-scale (:hint nil :color red)
      "
  ^Text Scaling^
  [_+_] increase   [_-_] decrease   [_0_] reset   [_q_] quit
  "
      ("+" text-scale-increase)
      ("-" text-scale-decrease)
      ("0" (text-scale-set 0) :color blue)
      ("q" nil "quit" :color blue)))

  ;;;; Small utilities -----------------------------------------------------------
  (leaf my:utils
    :straight nil
    :init
    (defun my/new-frame-with-scratch ()
      "Create a new frame and switch to a fresh buffer."
      (interactive)
      (let ((frame (make-frame)))
        (with-selected-frame frame
          (switch-to-buffer (generate-new-buffer "untitled")))))

    (defun my/restart-or-exit ()
      "Restart Emacs if `restart-emacs' exists; otherwise save & exit."
      (interactive)
      (if (fboundp 'restart-emacs)
          (restart-emacs)
        (save-buffers-kill-emacs)))

    ;; Arrow-based window motions (keeps default muscle memory).
    (windmove-default-keybindings))

  ;;;; IDE-agnostic helpers (Eglot / lsp-mode) -----------------------------------
  (defun my/code-actions ()
    "Run code actions via Eglot or lsp-mode."
    (interactive)
    (cond
     ((fboundp 'eglot-code-actions) (eglot-code-actions))
     ((fboundp 'lsp-execute-code-action) (lsp-execute-code-action))
     (t (user-error "No code action backend (Eglot/LSP) available"))))

  (defun my/rename-symbol ()
    "Rename symbol via Eglot or lsp-mode."
    (interactive)
    (cond
     ((fboundp 'eglot-rename) (eglot-rename))
     ((fboundp 'lsp-rename) (lsp-rename))
     (t (user-error "No rename backend (Eglot/LSP) available"))))

  (defun my/format-buffer ()
    "Format buffer via Eglot/LSP; fallback to `indent-region'."
    (interactive)
    (cond
     ((fboundp 'eglot-format-buffer) (eglot-format-buffer))
     ((fboundp 'lsp-format-buffer) (lsp-format-buffer))
     ((fboundp 'indent-region) (indent-region (point-min) (point-max)))
     (t (user-error "No formatter available"))))

  (defun my/consult-ripgrep-project ()
    "Run ripgrep in current project; fallback to prompting."
    (interactive)
    (let* ((pr (when (fboundp 'project-current) (project-current)))
           (root (when pr (car (project-roots pr)))))
      (if (and root (fboundp 'consult-ripgrep))
          (consult-ripgrep root)
        (call-interactively 'consult-ripgrep))))

  (defun my/toggle-transient-line-numbers ()
    "Toggle line numbers, preserving buffer-local overrides."
    (interactive)
    (if (bound-and-true-p display-line-numbers-mode)
        (display-line-numbers-mode 0)
      (display-line-numbers-mode 1)))

  ;;;; Global LEADER (non-modal) -------------------------------------------------
  ;; Define leader keys and prefix maps:
  (defconst my:leader-key "C-c SPC"
    "Key sequence used as the global leader key.")

  (defconst my:leader-which-prefix "C-c SPC"
    "Human-readable leader prefix string for which-key labels.")

  ;; Define a local leader key sequence for major mode commands (contextual).
  (defconst my:local-leader-key (concat my:leader-key " m")
    "Key sequence used as the local (major-mode) leader key.")

  ;; Top-level leader prefix map and subgroup prefix maps.
  (define-prefix-command 'my/leader-map)
  (define-prefix-command 'my/leader-b-map) ;; buffers
  (define-prefix-command 'my/leader-w-map) ;; windows
  (define-prefix-command 'my/leader-p-map) ;; project
  (define-prefix-command 'my/leader-g-map) ;; git
  (define-prefix-command 'my/leader-c-map) ;; code
  (define-prefix-command 'my/leader-e-map) ;; errors/diagnostics
  (define-prefix-command 'my/leader-t-map) ;; toggles
  (define-prefix-command 'my/leader-o-map) ;; org/roam
  (define-prefix-command 'my/leader-m-map) ;; mode-specific (local leader)
  (define-prefix-command 'my/leader-a-map) ;; ai
  (define-prefix-command 'my/leader-q-map) ;; session/quit
  (define-prefix-command 'my/leader-h-map) ;; help

  ;; Bind the global leader key to its prefix map.
  (when (fboundp 'keymap-global-set)
    (keymap-global-set my:leader-key 'my/leader-map)
    ;; In older Emacs, use (global-set-key (kbd my:leader-key) 'my/leader-map)
    )

  ;; Bind group prefixes under the leader map.
  (define-key my/leader-map (kbd "b") 'my/leader-b-map)
  (define-key my/leader-map (kbd "w") 'my/leader-w-map)
  (define-key my/leader-map (kbd "p") 'my/leader-p-map)
  (define-key my/leader-map (kbd "g") 'my/leader-g-map)
  (define-key my/leader-map (kbd "c") 'my/leader-c-map)
  (define-key my/leader-map (kbd "e") 'my/leader-e-map)
  (define-key my/leader-map (kbd "t") 'my/leader-t-map)
  (define-key my/leader-map (kbd "o") 'my/leader-o-map)
  (define-key my/leader-map (kbd "m") 'my/leader-m-map)  ;; "m" for major-mode leader
  (define-key my/leader-map (kbd "a") 'my/leader-a-map)
  (define-key my/leader-map (kbd "q") 'my/leader-q-map)
  (define-key my/leader-map (kbd "h") 'my/leader-h-map)

  ;; 1) Top-level leader bindings (LEADER <key>)
  (define-key my/leader-map (kbd "SPC") #'execute-extended-command) ;; M-x
  (define-key my/leader-map (kbd "/")   #'consult-line)
  (define-key my/leader-map (kbd ";")   #'comment-or-uncomment-region)
  (define-key my/leader-map (kbd "=")   #'er/expand-region)
  (define-key my/leader-map (kbd "`")   #'eval-expression)
  (define-key my/leader-map (kbd "z")   #'core-hydra-text-scale/body)
  ;; frequent file and buffer helpers
  (define-key my/leader-map (kbd ".")   #'other-window)
  (define-key my/leader-map (kbd "f")   #'find-file)
  (define-key my/leader-map (kbd "F")   #'find-file-other-window)
  (define-key my/leader-map (kbd "O")   #'find-file-other-frame)
  (define-key my/leader-map (kbd "r")   #'consult-recent-file)

  ;; 2) Buffers (LEADER b ...)
  (define-key my/leader-b-map (kbd "b") #'consult-buffer)
  (define-key my/leader-b-map (kbd "B") #'consult-project-buffer)
  (define-key my/leader-b-map (kbd "k") #'my/kill-buffer-smart)
  (define-key my/leader-b-map (kbd "n") #'next-buffer)
  (define-key my/leader-b-map (kbd "p") #'previous-buffer)
  (define-key my/leader-b-map (kbd "r") #'revert-buffer)

  ;; 3) Windows (LEADER w ...)
  (define-key my/leader-w-map (kbd "w") #'ace-window)
  (define-key my/leader-w-map (kbd "s") #'split-window-below)
  (define-key my/leader-w-map (kbd "v") #'split-window-right)
  (define-key my/leader-w-map (kbd "d") #'delete-window)
  (define-key my/leader-w-map (kbd "o") #'delete-other-windows)
  (define-key my/leader-w-map (kbd "=") #'balance-windows)
  (define-key my/leader-w-map (kbd "2") #'my/toggle-window-split)

  ;; 4) Project (LEADER p ...)
  (define-key my/leader-p-map (kbd "p") #'project-switch-project)
  (define-key my/leader-p-map (kbd "f") #'project-find-file)
  (define-key my/leader-p-map (kbd "s") #'my/consult-ripgrep-project)
  (define-key my/leader-p-map (kbd "b") #'consult-project-buffer)
  (define-key my/leader-p-map (kbd "r") #'project-query-replace-regexp)
  (define-key my/leader-p-map (kbd "d") #'project-dired)

  ;; 5) Search (LEADER s ...) ‚Äì (placed under main map for convenience)
  (define-key my/leader-map (kbd "s s") #'consult-line)
  (define-key my/leader-map (kbd "s r") #'consult-ripgrep)
  (define-key my/leader-map (kbd "s g") #'my/consult-ripgrep-project)
  (define-key my/leader-map (kbd "s m") #'consult-imenu)

  ;; 6) Git (LEADER g ...)
  (define-key my/leader-g-map (kbd "s") #'magit-status)
  (define-key my/leader-g-map (kbd "b") #'magit-blame-addition)
  (define-key my/leader-g-map (kbd "l") #'magit-log-current)
  (define-key my/leader-g-map (kbd "d") #'magit-diff-buffer-file)
  (define-key my/leader-g-map (kbd "c") #'magit-commit)

  ;; 7) Code (LEADER c ...) ‚Äì LSP-agnostic helpers
  (define-key my/leader-c-map (kbd "a") #'my/code-actions)
  (define-key my/leader-c-map (kbd "r") #'my/rename-symbol)
  (define-key my/leader-c-map (kbd "f") #'my/format-buffer)
  (define-key my/leader-c-map (kbd "d") #'xref-find-definitions)
  (define-key my/leader-c-map (kbd "D") #'xref-find-definitions-other-window)
  (define-key my/leader-c-map (kbd "R") #'xref-find-references)
  (define-key my/leader-c-map (kbd "i") #'completion-at-point)

  ;; 8) Errors/diagnostics (LEADER e ...)
  (define-key my/leader-e-map (kbd "n") #'flymake-goto-next-error)
  (define-key my/leader-e-map (kbd "p") #'flymake-goto-prev-error)
  (define-key my/leader-e-map (kbd "l") #'flymake-show-buffer-diagnostics)

  ;; 9) Toggles (LEADER t ...)
  (define-key my/leader-t-map (kbd "l") #'my/toggle-transient-line-numbers)
  (define-key my/leader-t-map (kbd "w") #'whitespace-mode)
  (define-key my/leader-t-map (kbd "r") #'read-only-mode)
  (define-key my/leader-t-map (kbd "z") #'core-hydra-text-scale/body)
  ;; Removed toggle for images here, as it's specific to EWW (now local leader in eww-mode).

  ;; 10) Org & Roam (LEADER o ...)
  (define-key my/leader-o-map (kbd "a") #'org-agenda)
  (define-key my/leader-o-map (kbd "c") #'org-capture)
  (define-key my/leader-o-map (kbd "i") #'org-roam-node-insert)
  (define-key my/leader-o-map (kbd "f") #'org-roam-node-find)
  (define-key my/leader-o-map (kbd "s") #'my/org-sidebar)
  (define-key my/leader-o-map (kbd "t") #'my/org-sidebar-toggle)

  ;; 11) Misc/Web ‚Äì **(Moved to local leader or global C-c w)**
  ;; (LEADER m ...) previously held EWW (web) commands.
  ;; We leave my/leader-m-map defined for local leader usage, but no global bindings here now.
  ;; EWW commands are accessible via global "C-c w" prefix or when in eww-mode via local leader.

  ;; 12) AI (LEADER a ...)
  (define-key my/leader-a-map (kbd "a") #'aidermacs-transient-menu)

  ;; 13) Session/quit (LEADER q ...)
  (define-key my/leader-q-map (kbd "n") #'my/new-frame-with-scratch)
  (define-key my/leader-q-map (kbd "r") #'my/restart-or-exit)
  (define-key my/leader-q-map (kbd "q") #'save-buffers-kill-emacs)

  ;; 14) Help (LEADER h ...)
  (define-key my/leader-h-map (kbd "k") #'describe-key)
  (define-key my/leader-h-map (kbd "f") #'describe-function)
  (define-key my/leader-h-map (kbd "v") #'describe-variable)

  ;;;; Which-Key integration for leader groups -----------------------------------
  (leaf which-key
    :straight t
    :hook (after-init-hook . which-key-mode)
    :custom ((which-key-idle-delay . 0.4))
    :config
    ;; Label leader groups dynamically according to `my:leader-which-prefix`.
    (dolist (it `((,(concat my:leader-which-prefix " b") . "buffers")
                  (,(concat my:leader-which-prefix " w") . "windows")
                  (,(concat my:leader-which-prefix " p") . "project")
                  (,(concat my:leader-which-prefix " s") . "search")
                  (,(concat my:leader-which-prefix " g") . "git")
                  (,(concat my:leader-which-prefix " c") . "code")
                  (,(concat my:leader-which-prefix " e") . "errors")
                  (,(concat my:leader-which-prefix " t") . "toggles")
                  (,(concat my:leader-which-prefix " o") . "org/roam")
                  (,(concat my:leader-which-prefix " m") . "mode")   ;; updated label
  		(,(concat my:leader-which-prefix " a") . "ai")
                  (,(concat my:leader-which-prefix " q") . "session")
                  (,(concat my:leader-which-prefix " h") . "help")))
      (which-key-add-key-based-replacements (car it) (cdr it))))

  ;;;; Major-mode specific (local leader) bindings -------------------------------
  (with-eval-after-load 'dired
    (require 'dired-filter nil t)
    (require 'dired-subtree nil t)
    (add-hook 'dired-mode-hook #'dired-filter-mode)
    (setq dired-subtree-use-backgrounds t)
    ;; ---- Dired Local Keybindings ----
    (define-key dired-mode-map (kbd "TAB") #'dired-subtree-toggle)
    (define-key dired-mode-map (kbd "i")   #'dired-subtree-insert)
    (define-key dired-mode-map (kbd ";")   #'dired-subtree-remove)
    (define-key dired-mode-map (kbd "f")   #'dired-filter-mode)
    (define-key dired-mode-map (kbd "/")   #'dired-filter-map)
    (define-key dired-mode-map (kbd "z")   #'my/dired-view-file-other-window)
    (with-eval-after-load 'which-key
      (which-key-add-key-based-replacements
        "C-c SPC m TAB" "toggle subtree"
        "C-c SPC m i"   "insert subtree"
        "C-c SPC m ;"   "remove subtree"
        "C-c SPC m f"   "filter mode"
        "C-c SPC m /"   "filter map"
        "C-c SPC m z"   "view in other window")))

  (with-eval-after-load 'vterm
    (define-key vterm-mode-map (kbd "C-c SPC m c") #'vterm-send-C-c)
    (define-key vterm-mode-map (kbd "C-c SPC m r") #'vterm-send-return)
    (define-key vterm-mode-map (kbd "C-c SPC m k") #'vterm-reset-cursor-point)
    (define-key vterm-mode-map (kbd "C-c SPC m q") #'vterm-quit)
    (with-eval-after-load 'which-key
      (which-key-add-key-based-replacements
        "C-c SPC m c" "send C-c"
        "C-c SPC m r" "send RET"
        "C-c SPC m q" "quit vterm")))

  (with-eval-after-load 'eww
    (define-key eww-mode-map (kbd "s") #'my/eww-search)
    (define-key eww-mode-map (kbd "o") #'eww-open-file)
    (define-key eww-mode-map (kbd "b") #'eww-list-bookmarks)
    (define-key eww-mode-map (kbd "r") #'eww-readable)
    (define-key eww-mode-map (kbd "u") #'my/eww-toggle-images)
    (with-eval-after-load 'which-key
      (which-key-add-key-based-replacements
        "C-c SPC m s" "search"
        "C-c SPC m b" "bookmarks"
        "C-c SPC m u" "toggle images")))

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c SPC m t") #'org-todo)
    (define-key org-mode-map (kbd "C-c SPC m a") #'org-archive-subtree)
    (define-key org-mode-map (kbd "C-c SPC m s") #'org-schedule)
    (define-key org-mode-map (kbd "C-c SPC m d") #'org-deadline)
    (define-key org-mode-map (kbd "C-c SPC m p") #'org-priority)
    (with-eval-after-load 'which-key
      (which-key-add-key-based-replacements
        "C-c SPC m t" "todo"
        "C-c SPC m s" "schedule"
        "C-c SPC m d" "deadline"
        "C-c SPC m p" "priority")))

  (with-eval-after-load 'magit
    (define-key magit-mode-map (kbd "C-c SPC m c") #'magit-commit)
    (define-key magit-mode-map (kbd "C-c SPC m p") #'magit-push-current)
    (define-key magit-mode-map (kbd "C-c SPC m f") #'magit-fetch)
    (define-key magit-mode-map (kbd "C-c SPC m l") #'magit-log-buffer-file)
    (define-key magit-mode-map (kbd "C-c SPC m s") #'magit-stage)
    (define-key magit-mode-map (kbd "C-c SPC m u") #'magit-unstage)
    (with-eval-after-load 'which-key
      (which-key-add-key-based-replacements
        "C-c SPC m c" "commit"
        "C-c SPC m p" "push"
        "C-c SPC m f" "fetch"
        "C-c SPC m s" "stage"
        "C-c SPC m u" "unstage")))

  ;;;; Global keybindings (outside leader) ---------------------------------------
  ;; Define global keys (macOS-like shortcuts, function keys, etc.)
  (global-set-key (kbd "<f1>") #'help-command)
  (global-set-key (kbd "<f5>") #'my/revert-buffer-quick)   ;; quick revert buffer (if defined elsewhere)
  (global-set-key (kbd "<f8>") #'treemacs)
  (global-set-key (kbd "C-.") #'other-window)
  (global-set-key (kbd "C-/") #'undo-fu-only-undo)
  (global-set-key (kbd "C-=") #'er/expand-region)
  (global-set-key (kbd "C-?") #'undo-fu-only-redo)
  (global-set-key (kbd "C-c 0") #'delete-window)
  (global-set-key (kbd "C-c 1") #'delete-other-windows)
  (global-set-key (kbd "C-c 2") #'my/toggle-window-split)
  (global-set-key (kbd "C-c ;") #'comment-or-uncomment-region)
  (global-set-key (kbd "C-c M-a") #'align-regexp)
  (global-set-key (kbd "C-c V") #'view-file-other-window)
  (global-set-key (kbd "C-c a a") #'aidermacs-transient-menu)   ;; global AI menu (duplicate of LEADER a a)
  (global-set-key (kbd "C-c b") #'consult-buffer)
  ;; "C-c d ..." org/roam bindings (these may be redundant with leader o):
  (global-set-key (kbd "C-c d a") #'org-agenda)
  (global-set-key (kbd "C-c d c") #'org-capture)
  (global-set-key (kbd "C-c d f") #'org-roam-node-find)
  (global-set-key (kbd "C-c d i") #'org-roam-node-insert)
  (global-set-key (kbd "C-c d s") #'my/org-sidebar)
  (global-set-key (kbd "C-c d t") #'my/org-sidebar-toggle)
  (global-set-key (kbd "C-c k") #'my/kill-buffer-smart)
  (global-set-key (kbd "C-c l") #'display-line-numbers-mode)    ;; quick toggle line numbers
  (global-set-key (kbd "C-c o") #'find-file)
  (global-set-key (kbd "C-c r") #'consult-ripgrep)
  (global-set-key (kbd "C-c v") #'find-file-read-only)
  ;; Web/EWW global prefix keys:
  (global-set-key (kbd "C-c w b") #'eww-list-bookmarks)
  (global-set-key (kbd "C-c w o") #'eww-open-file)
  (global-set-key (kbd "C-c w r") #'eww-readable)
  (global-set-key (kbd "C-c w s") #'my/eww-search)
  (global-set-key (kbd "C-c w u") #'my/eww-toggle-images)
  (global-set-key (kbd "C-c w w") #'eww)
  (global-set-key (kbd "C-c z") #'core-hydra-text-scale/body)
  ;; macOS-like Super (s-) keys:
  (global-set-key (kbd "C-h") #'backward-delete-char)   ;; Make C-h backspace (like in terminals/mac)
  (global-set-key (kbd "C-s") #'consult-line)           ;; Search in buffer (override isearch)
  (global-set-key (kbd "s-.") #'ace-window)
  (global-set-key (kbd "s-<down>") #'end-of-buffer)
  (global-set-key (kbd "s-<left>") #'previous-buffer)
  (global-set-key (kbd "s-<right>") #'next-buffer)
  (global-set-key (kbd "s-<up>") #'beginning-of-buffer)
  (global-set-key (kbd "s-b") #'consult-buffer)
  (global-set-key (kbd "s-j") #'find-file-other-window)
  (global-set-key (kbd "s-m") #'my/new-frame-with-scratch)
  (global-set-key (kbd "s-o") #'find-file-other-frame)
  (global-set-key (kbd "s-r") #'my/restart-or-exit)
  (global-set-key (kbd "s-w") #'ace-swap-window)
  (global-set-key (kbd "M-x") #'execute-extended-command)

  ;;;; Auth / secrets ------------------------------------------------------------
  (defvar my:d:password-store
    (or (getenv "PASSWORD_STORE_DIR")
        (concat no-littering-var-directory "password-store/"))
    "Path to the password store.")

  (defun my/auth-check-env ()
    "Validate authentication environment and warn if misconfigured."
    (unless (getenv "GPG_KEY_ID")
      (display-warning 'auth "GPG_KEY_ID is not set." :level 'debug))
    (unless (file-directory-p my:d:password-store)
      (display-warning 'auth
                       (format "Password store directory does not exist: %s"
                               my:d:password-store)
                       :level 'warning)))

  (leaf *authentication
    :straight nil
    :init
    (my/auth-check-env)

    (leaf epa-file
      :straight nil
      :commands (epa-file-enable)
      :init
      (setq epa-pinentry-mode
            (if (getenv "USE_GPG_LOOPBACK") 'loopback 'default))
      (add-hook 'emacs-startup-hook #'epa-file-enable))

    (leaf auth-source
      :straight nil
      :init
      (with-eval-after-load 'auth-source
        (let ((key (getenv "GPG_KEY_ID")))
          (if key
              (setq auth-source-gpg-encrypt-to key)
            (display-warning 'auth-source
                             "GPG_KEY_ID is not set. Authentication backends may be limited.")))))

    (leaf password-store :straight t)

    (leaf auth-source-pass
      :straight t
      :commands (auth-source-pass-enable)
      :hook (emacs-startup-hook . (lambda ()
                                    (when (executable-find "pass")
                                      (auth-source-pass-enable)))))

    (leaf plstore
      :straight nil
      :init
      (with-eval-after-load 'plstore
        (setq plstore-secret-keys 'silent
              plstore-encrypt-to (getenv "GPG_KEY_ID")))))

  (provide 'core/general)
  ;;; core/general.el ends here
#+end_src

*** core/tools.el
:PROPERTIES:
:CUSTOM_ID: core-tools
:header-args:emacs-lisp: :tangle lisp/core/tools.el
:END:

#+begin_src emacs-lisp
  ;;; core/tools.el --- Developer & UI helper tools -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Code:

  (defun my/toggle-linum-lines () (interactive)
    (if (bound-and-true-p display-line-numbers-mode)
        (display-line-numbers-mode 0)
      (display-line-numbers-mode 1)))

  (defun my/toggle-window-split ()
    "Toggle between horizontal and vertical split for two windows."
    (interactive)
    (when (= (count-windows) 2)
      (let* ((this-buf (window-buffer))
             (next-buf (window-buffer (next-window)))
             (this-edges (window-edges))
             (next-edges (window-edges (next-window)))
             (split-vert (= (car this-edges) (car next-edges)))
             (split-fn (if split-vert #'split-window-horizontally #'split-window-vertically)))
        (delete-other-windows)
        (funcall split-fn)
        (set-window-buffer (selected-window) this-buf)
        (set-window-buffer (next-window) next-buf)
        (select-window (selected-window)))))

  (defun my/find-keybinding-conflicts ()
    "Find and display conflicting keybindings in active keymaps."
    (interactive)
    (let ((conflicts (make-hash-table :test 'equal))
          (maps (current-active-maps t))
          (buffer-name "*Keybinding Conflicts*"))
      (dolist (map maps)
        (map-keymap
         (lambda (key cmd)
           (when (commandp cmd)
             (let ((desc (key-description (vector key)))
                   (existing (gethash desc conflicts)))
               (puthash desc (delete-dups (cons cmd existing)) conflicts))))
         map))
      (with-current-buffer (get-buffer-create buffer-name)
        (read-only-mode -1)
        (erase-buffer)
        (insert "* Keybinding Conflicts *\n\n")
        (maphash (lambda (key cmds)
                   (when (> (length cmds) 1)
                     (insert (format "%s => %s\n" key (mapconcat #'symbol-name cmds ", ")))))
                 conflicts)
        (read-only-mode 1))
      (pop-to-buffer buffer-name)))

  (defun my/dired-view-file-other-window ()
    "Open selected Dired file or directory in another window."
    (interactive)
    (let ((file (dired-get-file-for-visit)))
      (if (file-directory-p file)
          (or (and (cdr dired-subdir-alist) (dired-goto-subdir file)) (dired file))
        (view-file-other-window file))))

  ;; --------- Tree-sitter helpers -------------------------------------------------
  ;;;; Tree-sitter (modern API; grammars under my:d:var/tree-sitter) --------------
  ;; We store/look up compiled grammars (.so/.dylib) under my:d:var/tree-sitter.

  (defvar my:d:var
    (or (bound-and-true-p my:d:var)
        ;; Prefer no-littering var dir if available
        (and (boundp 'no-littering-var-directory) no-littering-var-directory)
        ;; Fallback: ~/.emacs.d/.var/
        (expand-file-name ".var/" user-emacs-directory))
    "Base directory for variable (writable) runtime data.")

  (defun my/ensure-directory-exists (dir)
    "Create DIR if it does not exist."
    (unless (file-directory-p dir)
      (make-directory dir t)))

  (defconst my:d:treesit
    (expand-file-name "tree-sitter/" my:d:var)
    "Directory to store and load Tree-sitter grammars.")

  ;; Ensure directory exists and register it as an extra search path.
  (my/ensure-directory-exists my:d:treesit)
  (add-to-list 'treesit-extra-load-path my:d:treesit)

  ;; Declare language sources. Keys are language symbols used by treesit.
  (setq treesit-language-source-alist
        '((bash       "https://github.com/tree-sitter/tree-sitter-bash")
          (c          "https://github.com/tree-sitter/tree-sitter-c")
          (cpp        "https://github.com/tree-sitter/tree-sitter-cpp")
          (css        "https://github.com/tree-sitter/tree-sitter-css")
          (go         "https://github.com/tree-sitter/tree-sitter-go")
          (html       "https://github.com/tree-sitter/tree-sitter-html")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript")
          (json       "https://github.com/tree-sitter/tree-sitter-json")
          (python     "https://github.com/tree-sitter/tree-sitter-python")
          (ruby       "https://github.com/tree-sitter/tree-sitter-ruby")
          (rust       "https://github.com/tree-sitter/tree-sitter-rust")
          (toml       "https://github.com/tree-sitter/tree-sitter-toml")
          (tsx        "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
          (yaml       "https://github.com/ikatyang/tree-sitter-yaml")))

  (defun my/treesit--language-installed-p (lang)
    "Return non-nil if LANG grammar library can be loaded."
    (and (fboundp 'treesit-language-available-p)
         (ignore-errors (treesit-language-available-p lang))))

  (defun my/treesit-install-languages (&optional langs)
    "Install LANGS via `treesit-install-language-grammar` (0‚Äì1 arg API).
  If LANGS is nil, install everything from `treesit-language-source-alist`."
    (unless (fboundp 'treesit-install-language-grammar)
      (user-error "This Emacs is not built with tree-sitter support"))
    (let ((targets (or langs (mapcar #'car treesit-language-source-alist))))
      (dolist (lang targets)
        (unless (my/treesit--language-installed-p lang)
  	(message "[treesit] Installing %s ‚Ä¶" lang)
          (treesit-install-language-grammar lang)))))

  (defun my/treesit-ensure (&optional langs)
    "Ensure LANGS grammars are available; install missing ones."
    (interactive)
    (my/treesit-install-languages langs)
    (message "[treesit] All requested grammars are available."))

  ;; Legacy shim preserved for compatibility with old sites passing 7 args, etc.
  (defun my/treesit--call-with-outdir (&rest maybe-legacy-args)
    "Compatibility wrapper. Accept LANG or list of LANG symbols, ignore extras."
    (let ((head (car maybe-legacy-args)))
      (cond
       ((symbolp head) (my/treesit-ensure (list head)))
       ((and (listp head) (cl-every #'symbolp head)) (my/treesit-ensure head))
       (t (user-error "Unsupported call form: %S" maybe-legacy-args)))))
  ;; --------- Misc dev / UI helpers ----------------------------------------------

  (defun my/open-by-vscode () (interactive)
    (when (buffer-file-name)
      (async-shell-command
       (format "code -r -g %s:%d:%d" (buffer-file-name) (line-number-at-pos) (current-column)))))

  (defun my/show-env-variable (var) (interactive "sEnvironment variable: ")
    (message "%s = %s" var (or (getenv var) "Not set")))

  (defun my/print-build-info () (interactive)
    (let ((buf (get-buffer-create "*Build Info*")))
      (with-current-buffer buf
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (format "- GNU Emacs *%s*\n\n" emacs-version))
          (insert "|Property|Value|\n|--------|-----|\n")
          (insert (format "|Commit|%s|\n" (if (fboundp 'emacs-repository-get-version)
                                              (emacs-repository-get-version) "N/A")))
          (insert (format "|Branch|%s|\n" (if (fboundp 'emacs-repository-get-branch)
                                              (emacs-repository-get-branch) "N/A")))
          (insert (format "|System|%s|\n" system-configuration))
          (insert (format "|Date|%s|\n" (format-time-string "%Y-%m-%d %T (%Z)" emacs-build-time)))
          (insert (format "|Patch|%s ns-inline.patch|\n" (if (boundp 'mac-ime--cursor-type) "with" "N/A")))
          (insert (format "|Features|%s|\n" system-configuration-features))
          (insert (format "|Options|%s|\n" system-configuration-options)))
        (view-mode 1))
      (switch-to-buffer buf)))

  (with-eval-after-load 'org
    (require 'org-fold)
    (defun my/org-fold-subtree ()   (interactive) (org-fold-subtree t))
    (defun my/org-unfold-subtree () (interactive) (org-show-subtree))
    (defun my/org-toggle-fold () (interactive)
      (save-excursion
        (org-back-to-heading t)
        (if (org-fold-folded-p (point)) (org-show-subtree) (org-fold-subtree t))))
    (define-key org-mode-map (kbd "C-c f") #'my/org-fold-subtree)
    (define-key org-mode-map (kbd "C-c e") #'my/org-unfold-subtree)
    (define-key org-mode-map (kbd "C-c t") #'my/org-toggle-fold))

  (provide 'core/tools)
  ;;; core/tools.el ends here
#+end_src

*** core/utils.el
:PROPERTIES:
:CUSTOM_ID: core-utils
:header-args:emacs-lisp: :tangle lisp/core/utils.el
:END:

#+begin_src emacs-lisp
  ;;; core/utils.el --- Core utility helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Code:

  ;; Insert timestamp on save
  (defun my/save-buffer-wrapper ()
    "Insert or update a `$Lastupdate` timestamp at the top of the buffer."
    (interactive)
    (let ((timestamp (concat "$Lastupdate: " (format-time-string "%Y/%m/%d %H:%M:%S") " $")))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "\\$Lastupdate: [0-9/: ]*\\$" nil t)
          (replace-match timestamp t nil)))))
  (add-hook 'before-save-hook #'my/save-buffer-wrapper)

  (defun my/auto-tangle-updated-src-blocks ()
    "Automatically tangle updated Org source blocks when saving `README.org`."
    (when (and buffer-file-name (string= (file-name-nondirectory buffer-file-name) "README.org"))
      (let ((org-confirm-babel-evaluate nil)) (org-babel-tangle))))

  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'my/auto-tangle-updated-src-blocks nil 'make-it-local)))

  (defun my/revert-buffer-quick ()
    (interactive) (revert-buffer :ignore-auto :noconfirm))

  (defun my/auto-insert-lexical-binding ()
    "Insert `lexical-binding: t` in Emacs Lisp files under `no-littering-var-directory`."
    (when (and (stringp buffer-file-name)
               (boundp 'no-littering-var-directory)
               (string-prefix-p (expand-file-name no-littering-var-directory) (expand-file-name buffer-file-name))
               (string-match-p "\\.el\\'" buffer-file-name)
               (not (save-excursion (goto-char (point-min))
                                    (re-search-forward "lexical-binding" (line-end-position 5) t))))
      (save-excursion (goto-char (point-min)) (insert ";; -*- lexical-binding: t; -*- \n"))))
  (add-hook 'find-file-hook #'my/auto-insert-lexical-binding)

  (defun my/enable-view-mode-on-read-only ()
    (if buffer-read-only (view-mode 1) (view-mode -1)))
  (add-hook 'read-only-mode-hook #'my/enable-view-mode-on-read-only)

  (provide 'core/utils)
  ;;; core/utils.el ends here
#+end_src

*** core/history.el
:PROPERTIES:
:CUSTOM_ID: core-history
:header-args:emacs-lisp: :tangle lisp/core/history.el
:END:

#+begin_src emacs-lisp
  ;;; core/history.el --- Session persistence & autorevert -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf saveplace :straight nil
    :init
    (setq save-place-file (concat no-littering-var-directory "saveplace"))
    (save-place-mode +1))

  (leaf recentf :straight nil
    :init
    (setq recentf-max-saved-items 100
          recentf-save-file (concat no-littering-var-directory "recentf"))
    (recentf-mode +1))

  (leaf savehist
    :straight nil
    :global-minor-mode savehist-mode
    :config
    (setq savehist-file (concat no-littering-var-directory "history"))
    (my/ensure-directory-exists (file-name-directory savehist-file))
    (add-to-list 'savehist-additional-variables 'my:desktop-ask-on-restore))

  (provide 'core/history)
  ;;; core/history.el ends here
#+end_src

*** core/editing.el
:PROPERTIES:
:CUSTOM_ID: core-editing
:header-args:emacs-lisp: :tangle lisp/core/editing.el
:END:

#+begin_src emacs-lisp
  ;;; core/editing.el --- Editing helpers & UX aids -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Code:

  (leaf tramp
    :straight nil
    :pre-setq
    `((tramp-persistency-file-name . ,(concat no-littering-var-directory "tramp"))
      (tramp-auto-save-directory   . ,(concat no-littering-var-directory "tramp-autosave")))
    :custom
    '((tramp-default-method . "scp")
      (tramp-verbose        . 3)))

  ;; Single source of truth for auto-save-visited.
  (setopt auto-save-visited-interval 1
          auto-save-default        nil)
  (when (fboundp 'auto-save-visited-mode)
    (auto-save-visited-mode 1))

  (leaf paredit :straight t
    :hook (emacs-lisp-mode . (lambda ()
                               (enable-paredit-mode)
                               (electric-pair-local-mode -1))))

  (leaf paren :straight nil
    :custom ((show-paren-delay . 0)
             (show-paren-style . 'expression)
             (show-paren-highlight-openparen . t))
    :global-minor-mode show-paren-mode)

  (leaf puni :straight t
    :global-minor-mode puni-global-mode
    :hook ((minibuffer-setup . (lambda () (puni-global-mode -1)))))

  (leaf undo-fu :straight t
    :custom ((undo-fu-allow-undo-in-region . t)))

  (leaf vundo :straight t)

  (leaf ace-window :straight t
    :custom ((aw-keys . '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
             (aw-scope . 'frame)
             (aw-background . t))
    :config (ace-window-display-mode 1))

  (leaf visual-line-mode :straight nil
    :hook (text-mode . visual-line-mode))

  (leaf dired-filter :straight t)
  (leaf dired-subtree :straight t :after dired)

  ;; Dired listing/ls settings centralized here.
  (leaf dired :straight nil
    :config
    (if (and (eq system-type 'darwin) (executable-find "gls"))
        (progn
          (setq insert-directory-program "gls"
                dired-use-ls-dired t
                dired-listing-switches "-aBhl --group-directories-first"))
      (setq dired-use-ls-dired nil
            dired-listing-switches "-alh")))

  (leaf expand-region :straight t :after treesit)
  (leaf aggressive-indent :straight t :hook (prog-mode . aggressive-indent-mode))
  (leaf delsel :straight nil :global-minor-mode delete-selection-mode)

  (leaf autorevert :straight nil
    :custom ((auto-revert-interval . 2)
             (auto-revert-verbose . nil))
    :global-minor-mode global-auto-revert-mode)

  (leaf transient
    :straight t
    :config
    (setq transient-history-file (concat no-littering-var-directory "transient/history.el")
          transient-levels-file  (concat no-littering-var-directory "transient/levels.el")
          transient-values-file  (concat no-littering-var-directory "transient/values.el"))
    (my/ensure-directory-exists (concat no-littering-var-directory "transient/")))

  (provide 'core/editing)
  ;;; core/editing.el ends here
#+end_src

*** core/switches.el
:PROPERTIES:
:CUSTOM_ID: core-switches
:header-args:emacs-lisp: :tangle lisp/core/switches.el
:END:

#+begin_src emacs-lisp
  ;;; core/switches.el --- Unified feature switches (UI/LSP) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; Switcher for UI bundles (doom/nano) and LSP backends (eglot/lsp).
  ;;
  ;;; Code:

  (eval-when-compile (require 'subr-x))

  (when (boundp 'my:use:modules)
    (when (or (not (boundp 'my:use-ui)) (eq my:use-ui 'none))
      (setq my:use-ui my:use:modules)))
  (define-obsolete-variable-alias 'my:use:modules 'my:use-ui "2025-10-11")

  (defgroup my:switches nil "Unified switches for UI and LSP." :group 'convenience)

  (defcustom my:use-lsp 'eglot
    "Which LSP client to use. One of: `eglot`, `lsp`."
    :type '(choice (const eglot) (const lsp))
    :group 'my:switches)

  (defcustom my:use-ui 'none
    "Which UI bundle to use. One of: `none`, `doom`, `nano`."
    :type '(choice (const none) (const doom) (const nano))
    :group 'my:switches)

  (autoload 'my/ui-enable-doom  "ui/ui-doom-modeline" "Enable Doom UI bundle." t)
  (autoload 'my/ui-enable-nano  "ui/ui-nano-modeline" "Enable Nano UI bundle." t)
  (autoload 'my/lsp-enable-eglot   "dev/dev-lsp-eglot" "Enable Eglot LSP." t)
  (autoload 'my/lsp-enable-lspmode "dev/dev-lsp-mode"  "Enable lsp-mode LSP." t)

  (defun my/sw--present-p (kind choice)
    (pcase kind
      ('ui (pcase choice
             ('doom (or (fboundp 'my/ui-enable-doom)
                        (locate-library "ui/ui-doom-modeline")
                        (locate-library "doom-modeline")))
             ('nano (or (fboundp 'my/ui-enable-nano)
                        (locate-library "ui/ui-nano-modeline")
                        (locate-library "nano-modeline")))
             (_ t)))
      ('lsp (pcase choice
              ('eglot (or (fboundp 'my/lsp-enable-eglot)
                          (locate-library "dev/dev-lsp-eglot")
                          (locate-library "eglot")))
              ('lsp   (or (fboundp 'my/lsp-enable-lspmode)
                          (locate-library "dev/dev-lsp-mode")
                          (locate-library "lsp-mode")))
              (_ nil)))
      (_ nil)))

  (defun my/sw--enable-ui (choice)
    (pcase choice
      ('doom (cond
              ((fboundp 'my/ui-enable-doom) (my/ui-enable-doom) t)
              ((locate-library "ui/ui-doom-modeline")
               (load (locate-library "ui/ui-doom-modeline") nil 'nomessage)
               (when (fboundp 'my/ui-enable-doom) (my/ui-enable-doom) t))
              (t (message "[switches] Doom UI not found.") nil)))
      ('nano (cond
              ((fboundp 'my/ui-enable-nano) (my/ui-enable-nano) t)
              ((locate-library "ui/ui-nano-modeline")
               (load (locate-library "ui/ui-nano-modeline") nil 'nomessage)
               (when (fboundp 'my/ui-enable-nano) (my/ui-enable-nano) t))
              (t (message "[switches] Nano UI not found.") nil)))
      ('none (message "[switches] UI bundle disabled.") t)
      (_ (message "[switches] Unknown UI choice: %s" choice) nil)))

  (defun my/sw--enable-lsp (choice)
    (pcase choice
      ('eglot (cond
               ((fboundp 'my/lsp-enable-eglot) (my/lsp-enable-eglot) t)
               ((locate-library "dev/dev-lsp-eglot")
                (load (locate-library "dev/dev-lsp-eglot") nil 'nomessage)
                (when (fboundp 'my/lsp-enable-eglot) (my/lsp-enable-eglot) t))
               (t (message "[switches] Eglot setup not found.") nil)))
      ('lsp (cond
             ((fboundp 'my/lsp-enable-lspmode) (my/lsp-enable-lspmode) t)
             ((locate-library "dev/dev-lsp-mode")
              (load (locate-library "dev/dev-lsp-mode") nil 'nomessage)
              (when (fboundp 'my/lsp-enable-lspmode) (my/lsp-enable-lspmode) t))
             (t (message "[switches] lsp-mode setup not found.") nil)))
      (_ (message "[switches] Unknown LSP choice: %s" choice) nil)))

  (when (not (eq my:use-ui 'none))
    (let ((present (my/sw--present-p 'ui my:use-ui)))
      (cond
       ((my/sw--enable-ui my:use-ui) (message "[switches] UI bundle: %s" my:use-ui))
       (present (message "[switches] UI seems present but could not enable: %s" my:use-ui))
       (t (message "[switches] UI bundle unavailable: %s" my:use-ui)))))

  (let ((present (my/sw--present-p 'lsp my:use-lsp)))
    (cond
     ((my/sw--enable-lsp my:use-lsp) (message "[switches] LSP backend: %s" my:use-lsp))
     (present (message "[switches] LSP seems present but could not enable: %s" my:use-lsp))
     (t (message "[switches] LSP backend unavailable: %s" my:use-lsp))))

  (provide 'core/switches)
  ;;; core/switches.el ends here
#+end_src

*** core/custom.el
:PROPERTIES:
:CUSTOM_ID: custom-file
:header-args:emacs-lisp: :tangle lisp/core/custom.el
:END:

#+begin_src emacs-lisp
  ;;; core/custom.el --- custom-file helpers -*- lexical-binding: t; -*-
  ;;
  ;; Category: core
  ;;
  ;;; Commentary:
  ;; - Route customize output to .etc/custom.el
  ;; - Provide helpers to open and (optionally) dump current values/faces.

  (eval-when-compile (require 'subr-x))

  (defconst my:f:custom
    (or (bound-and-true-p my:f:custom)
        (expand-file-name "custom.el" (or (bound-and-true-p my:d:etc)
  					(expand-file-name ".etc" user-emacs-directory))))
    "Path to the custom-file (Customize output).")

  (defun my/custom--ensure-file ()
    "Ensure `custom-file` exists and has a small header."
    (let* ((dir (file-name-directory my:f:custom)))
      (unless (file-directory-p dir)
        (condition-case err
            (make-directory dir t)
          (error (warn "[custom] failed to create %s: %s" dir (error-message-string err)))))
      (unless (file-exists-p my:f:custom)
        (with-temp-file my:f:custom
          (insert ";;; custom.el --- Customize output -*- lexical-binding: t; -*-\n"
                  ";; This file is generated by Customize. Edit with care.\n\n")))))

  ;; 1) Route Customize output to .etc/custom.el (idempotent)
  (setq custom-file my:f:custom)
  (my/custom--ensure-file)
  (when (file-readable-p custom-file)
    (ignore-errors (load custom-file nil 'nomessage)))

  ;;;###autoload
  (defun my/custom-open ()
    "Open the `custom-file`."
    (interactive)
    (my/custom--ensure-file)
    (find-file my:f:custom))

  ;;;###autoload
  (defun my/custom-dump-current ()
    "Persist a curated set of current settings/faces into `custom-file`.
  This is a one-shot snapshot; it won't run automatically."
    (interactive)
    (my/custom--ensure-file)

    ;; ---- Variables you want to persist (add/remove as you like) ----
    (dolist (pair
             `(
               ;; Core UI
               (inhibit-startup-screen             . ,inhibit-startup-screen)
               (frame-resize-pixelwise             . ,(bound-and-true-p frame-resize-pixelwise))
               (display-line-numbers-type          . ,(and (boundp 'display-line-numbers-type) display-line-numbers-type))
               ;; Completion
               (completion-styles                  . ,(and (boundp 'completion-styles) completion-styles))
               (completion-category-overrides      . ,(and (boundp 'completion-category-overrides) completion-category-overrides))
               ;; Org (selected)
               (org-startup-indented               . ,(and (boundp 'org-startup-indented) org-startup-indented))
               (org-hide-leading-stars             . ,(and (boundp 'org-hide-leading-stars) org-hide-leading-stars))
               (org-tags-column                    . ,(and (boundp 'org-tags-column) org-tags-column))
               (org-agenda-tags-column             . ,(and (boundp 'org-agenda-tags-column) org-agenda-tags-column))
               ;; org-modern (selected)
               (org-modern-list                    . ,(and (boundp 'org-modern-list) org-modern-list))
               (org-modern-checkbox                . ,(and (boundp 'org-modern-checkbox) org-modern-checkbox))
               (org-modern-priority                . ,(and (boundp 'org-modern-priority) org-modern-priority))
               (org-modern-replace-stars           . ,(and (boundp 'org-modern-replace-stars) org-modern-replace-stars))
               (org-modern-todo-faces              . ,(and (boundp 'org-modern-todo-faces) org-modern-todo-faces))
               ))
      ;; Only save bound values; skip nil/unbound
      (when (car (last pair))
        (customize-save-variable (car pair) (cdr pair))))

    ;; ---- Faces you want to persist (add/remove as you like) ----
    (let ((faces
           '(
             (org-modern-date-active   ((t (:background "#373844" :foreground "#f8f8f2" :height 0.75 :weight light :width condensed))))
             (org-modern-time-active   ((t (:background "#44475a" :foreground "#f8f8f2" :height 0.75 :weight light :width condensed))))
             (org-modern-date-inactive ((t (:background "#373844" :foreground "#b0b8d1" :height 0.75 :weight light :width condensed))))
             (org-modern-time-inactive ((t (:background "#44475a" :foreground "#b0b8d1" :height 0.75 :weight light :width condensed))))
             (org-modern-tag           ((t (:background "#44475a" :foreground "#b0b8d1" :height 0.75 :weight light :width condensed))))
             (org-modern-statistics    ((t (:foreground "violet" :weight light))))
             )))
      (dolist (f faces)
        (let ((face (nth 0 f)) (spec (nth 1 f)))
          (custom-set-faces `(,face ,spec)))))
    ;; Actually write
    (custom-save-all)
    (message "[custom] Wrote current snapshot to %s" my:f:custom))

  (provide 'core/custom)
  ;;; core/custom.el ends here
#+end_src

**** Wiring
- If your *early-init.el* / *init.el* already points `custom-file` to `.etc/custom.el`, you‚Äôre good.
- Ensure `core/custom` is in the module list (e.g. `lisp/modules.el` ‚Üí add `core/custom` to `my:modules`).

**** Usage
- `M-x my/custom-open` ‚Äî open `.etc/custom.el`
- `M-x my/custom-dump-current` ‚Äî write a one-time snapshot of selected settings/faces to `.etc/custom.el` (it does *not* run at startup)

*** core/custom-ui-extras.el (Enable new UI extras via my:modules-extra)
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/core/custom-ui-extras.el
:END:
#+begin_src emacs-lisp
  ;;; core/custom-ui-extras.el --- user extras -*- lexical-binding: t; -*-
  ;; Append without touching your default module list.
  (setq my:modules-extra
        (delete-dups
         (append my:modules-extra
                 '(ui/ui-visual-aids
                   orgx/org-typography
                   ui/ui-macos))))
  (provide 'core/custom-ui-extras)
#+end_src

*** ui/ui-font.el
:PROPERTIES:
:CUSTOM_ID: ui-font
:header-args:emacs-lisp: :tangle lisp/ui/ui-font.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-font.el --- Font configuration -*- lexical-binding: t; -*-

  ;; Ensure the leaf macro is available at compile time here too.
  (eval-when-compile (require 'leaf))

  (defun my/system-default-font ()
    "Return a default monospace font family depending on OS."
    (cond ((eq system-type 'darwin) "Menlo")
          ((eq system-type 'gnu/linux) "Monospace")
          ((eq system-type 'windows-nt) "Consolas")
          (t "Monospace")))

  (defun my/system-emoji-font ()
    "Return a default emoji font family depending on OS."
    (cond ((eq system-type 'darwin) "Apple Color Emoji")
          ((eq system-type 'gnu/linux) "Noto Color Emoji")
          ((eq system-type 'windows-nt) "Segoe UI Emoji")
          (t "Noto Color Emoji")))

  (defun my/font-setup ()
    "Apply font settings, respecting overrides, and report applied fonts."
    (when (display-graphic-p)
      (set-face-attribute 'default nil
                          :family (or my:font-default (my/system-default-font))
                          :height (* 10 (or my:font-size 18)))
      (message "[font] default: %s, %.1f pt"
               (face-attribute 'default :family)
               (/ (float (face-attribute 'default :height)) 18))
      (set-face-attribute 'variable-pitch nil
                          :family (or my:font-alt (my/system-default-font)))
      (message "[font] variable-pitch: %s"
               (face-attribute 'variable-pitch :family))
      (set-fontset-font t 'emoji
                        (font-spec :family (or my:emoji-font (my/system-emoji-font))))
      (message "[font] emoji: %s"
               (or my:emoji-font (my/system-emoji-font)))))

  (defun my/show-current-font () (interactive)
    "Echo the current default font family and point size."
    (let* ((family (face-attribute 'default :family))
           (height (face-attribute 'default :height))
           (pt (/ height 10.0)))
      (message "Current font: %s, %.1f pt" family pt)))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame) (with-selected-frame frame (my/font-setup))))
    (add-hook 'after-init-hook #'my/font-setup))

  ;; OPTIONAL ligatures ‚Äî install & enable only when available/GUI.
  (leaf ligature
    :straight (ligature :type git :host github :repo "mickeynp/ligature.el")
    :when (display-graphic-p)
    :require t
    :config
    (when (fboundp 'ligature-set-ligatures)
      (ligature-set-ligatures 'prog-mode '("->" "=>" "::" "===" "!=" "&&" "||"))
      (global-ligature-mode 1)))

  (provide 'ui/ui-font)
  ;;; ui/ui-font.el ends here
#+end_src

*** ui/ui-nano-palette.el
:PROPERTIES:
:CUSTOM_ID: ui-theme
:header-args:emacs-lisp: :tangle lisp/ui/ui-nano-palette.el
:END:

#+begin_src emacs-lisp
  ;;; ui-nano-palette.el --- Nano-style palette -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;; Commentary:
  ;; One source of truth:
  ;; - Define the palette once (defcustom ‚Üí easy to tweak via M-x customize)
  ;; - Apply all faces from a single function
  ;; - No duplicated literal colors scattered around
  ;;
  ;;; Code:

  (defgroup my:nano nil
    "Minimal nano-style light palette."
    :group 'faces)

  (defcustom nano-color-background "#fafafa" ; near-white / gray-50
    "UI background for buffers/panels."
    :type 'string :group 'my:nano)

  (defcustom nano-color-foreground "#374151" ; slate-700
    "Default body text color."
    :type 'string :group 'my:nano)

  (defcustom nano-color-salient "#2563eb" ; blue-600
    "Accent for links/keywords/standout choices."
    :type 'string :group 'my:nano)

  (defcustom nano-color-popout "#6b7280" ; slate-500 (muted notice)
    "Neutral notice / muted highlight."
    :type 'string :group 'my:nano)

  (defcustom nano-color-critical "#dc2626" ; red-600
    "Critical error / danger color."
    :type 'string :group 'my:nano)

  (defcustom nano-color-strong "#111827" ; slate-900
    "Strong emphasis (headings, key mode-line parts)."
    :type 'string :group 'my:nano)

  (defcustom nano-color-faded "#9ca3af" ; slate-400
    "De-emphasized info (comments/secondary/disabled)."
    :type 'string :group 'my:nano)

  (defcustom nano-color-subtle "#e5e7eb" ; gray-200
    "Subtle backgrounds (mode/header lines, gentle selections)."
    :type 'string :group 'my:nano)

  (defun my/nano-apply-faces ()
    "Apply faces based on the nano-style palette defined above.
  Call this *after* your theme is enabled if the theme overrides faces."
    ;; Core text
    (set-face-attribute 'default nil
                        :background nano-color-background
                        :foreground nano-color-foreground)
    (set-face-attribute 'bold   nil :foreground nano-color-strong :weight 'bold)
    (set-face-attribute 'italic nil :slant 'italic)

    ;; Syntax (tune to taste)
    (set-face-attribute 'font-lock-comment-face nil :foreground nano-color-faded)
    (set-face-attribute 'font-lock-keyword-face nil :foreground nano-color-salient :weight 'semi-bold)
    (set-face-attribute 'font-lock-string-face  nil :foreground nano-color-popout)
    (set-face-attribute 'font-lock-warning-face nil :foreground nano-color-popout :weight 'bold)

    ;; Links / buttons
    (set-face-attribute 'link   nil :foreground nano-color-salient :underline t)
    (set-face-attribute 'button nil :foreground nano-color-salient :underline t)

    ;; Status faces
    (set-face-attribute 'error   nil :foreground nano-color-critical :weight 'bold)
    (set-face-attribute 'warning nil :foreground nano-color-popout  :weight 'bold)
    (set-face-attribute 'success nil :foreground "#10b981") ; emerald-500

    ;; Selection
    (set-face-attribute 'region nil :background nano-color-subtle)

    ;; Mode line
    (let ((ml-bg nano-color-subtle)
          (ml-fg nano-color-strong))
      (set-face-attribute 'mode-line nil
                          :background ml-bg :foreground ml-fg
                          :box `(:line-width 1 :color ,ml-bg))
      (set-face-attribute 'mode-line-inactive nil
                          :background nano-color-background :foreground nano-color-faded
                          :box `(:line-width 1 :color ,nano-color-background)))

    ;; Minibuffer prompt
    (set-face-attribute 'minibuffer-prompt nil
                        :foreground nano-color-salient :weight 'semi-bold))

  ;; Optional: a convenience API to override a subset, then apply.
  (defun my/nano-set-palette-and-apply (&rest plist)
    "Override any palette entries via PLIST and apply faces.
  Keys: :background :foreground :salient :popout :critical :strong :faded :subtle"
    (when plist
      (let ((map '((:background . nano-color-background)
                   (:foreground . nano-color-foreground)
                   (:salient    . nano-color-salient)
                   (:popout     . nano-color-popout)
                   (:critical   . nano-color-critical)
                   (:strong     . nano-color-strong)
                   (:faded      . nano-color-faded)
                   (:subtle     . nano-color-subtle))))
        (while plist
          (let* ((k (pop plist)) (v (pop plist))
                 (sym (cdr (assq k map))))
            (when sym (set sym v))))))
    (my/nano-apply-faces))

  ;; Usage examples:
  ;; (my/nano-apply-faces) ; apply as-is
  ;; (my/nano-set-palette-and-apply :popout "#f59e0b") ; switch to amber popout, then apply

  (provide 'ui/ui-nano-palette)
  ;;; ui/ui-nano-palette.el ends here
#+end_src

*** ui/ui-theme.el
:PROPERTIES:
:CUSTOM_ID: ui-theme
:header-args:emacs-lisp: :tangle lisp/ui/ui-theme.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-theme.el --- Theme configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Commentary:
  ;;; ui/ui-theme.el --- Theme configuration -*- lexical-binding: t; -*-
  ;;
  ;; Category: ui
  ;; Uses nano-emacs + nano-theme + spacious-padding
  ;; Palette & face normalization are centralized in my-nano-palette.el
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; Load the palette (one source of truth for colors)
  (require 'ui/ui-nano-palette) ;; provides: my/nano-apply-faces, my/nano-set-palette-and-apply, defcustoms

  ;; Compact line height (tweak to taste)
  (setq-default line-spacing 0.24)

  ;; Helper: re-apply our face normalization after any theme is enabled
  (defun my/nano--reapply-after-theme (&rest _)
    "Re-apply nano-style face normalization after a theme change."
    (when (fboundp 'my/nano-apply-faces)
      (my/nano-apply-faces)))

  ;; Emacs 29+ offers `enable-theme-functions`; if unavailable, use advice
  (with-eval-after-load 'cus-theme
    (if (boundp 'enable-theme-functions)
        (add-hook 'enable-theme-functions #'my/nano--reapply-after-theme)
      (advice-add 'enable-theme :after #'my/nano--reapply-after-theme)))

  ;; nano: faces/base ‚Üí theme ‚Üí modeline
  (leaf nano-emacs
    :straight (nano-emacs :type git :host github :repo "rougier/nano-emacs")
    :init
    (when (fboundp 'my-nano-setup-colors) (my/nano-setup-colors))
    :config
    (require 'nano-layout)
    (require 'nano-faces)
    (nano-faces)

    ;; Make nano's strong face actually "strong"
    (set-face-attribute 'nano-face-strong nil
                        :foreground (face-foreground 'nano-face-default)
                        :weight 'bold)

    (leaf nano-theme
      :straight (nano-theme :type git :host github :repo "rougier/nano-theme")
      :config
      ;; Enable nano theme, then normalize faces from our palette
      (load-theme 'nano t)
      (my/nano-apply-faces)

      ;; Keep basic emphasis consistent regardless of theme internals
      (set-face-attribute 'bold nil   :weight 'bold)
      (set-face-attribute 'italic nil :slant 'italic)
      (with-eval-after-load 'elec-pair
        (custom-set-faces
         '(electric-pair-overlay-face ((t (:background "#e5e7eb"))))
         '(show-paren-match ((t (:background "#e5e7eb" :foreground "#111827" :weight bold))))
         '(show-paren-mismatch ((t (:background "#dc2626" :foreground "white" :weight bold))))))))

  ;; Subtle padding on GUI
  (leaf spacious-padding :straight t
    :if (display-graphic-p)
    :custom
    ((spacious-padding-widths . '((left . 15) (right . 15)))
     (spacious-padding-subtle-mode-line . t))
    :config
    (spacious-padding-mode 1)
    ;; Re-apply faces once padding tweaks modeline metrics
    (my/nano-apply-faces))

  (provide 'ui/ui-theme)
  ;;; ui/ui-theme.el ends here
#+end_src

*** ui/ui-doom-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-doom-modeline
:header-args:emacs-lisp: :tangle lisp/ui/ui-doom-modeline.el
:END:

#+begin_src emacs-lisp
  ;;; ui-doom-modeline.el --- Doom UI bundle entry -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;;; Commentary:
  ;; Enable doom-modeline (with nerd-icons) as a compact UI bundle.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))
  (declare-function doom-modeline-mode "doom-modeline")

  (leaf nerd-icons :straight t)

  (leaf doom-modeline
    :straight t
    :custom ((doom-modeline-height . 28)
             (doom-modeline-buffer-file-name-style . 'truncate-with-project)
             (doom-modeline-minor-modes . nil)
             (doom-modeline-enable-word-count . t))
    :config
    (doom-modeline-mode 1))

  ;;;###autoload
  (defun my/ui-enable-doom ()
    "Enable Doom UI modeline bundle."
    (interactive)
    (unless (bound-and-true-p doom-modeline-mode)
      (doom-modeline-mode 1))
    (message "[ui] Doom modeline enabled."))

  (provide 'ui/ui-doom-modeline)
  ;;; ui/ui-doom-modeline.el ends here
#+end_src

*** ui/ui-nano-modeline.el
:PROPERTIES:
:CUSTOM_ID: ui-nano-modeline
:header-args:emacs-lisp: :tangle lisp/ui/ui-nano-modeline.el
:END:

#+begin_src emacs-lisp
  ;;; ui-nano-modeline.el --- Nano UI bundle entry -*- lexical-binding: t; -*-
  ;;
  ;; Category: ui
  ;;
  ;;; Commentary:
  ;; Robust loader that tries to require `nano-modeline` and wires all mode hooks.
  ;; Safe even if the package is not available at build time.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (declare-function nano-modeline-mode              "nano-modeline")
  (declare-function nano-modeline-prog-mode         "nano-modeline")
  (declare-function nano-modeline-text-mode         "nano-modeline")
  (declare-function nano-modeline-org-mode          "nano-modeline")
  (declare-function nano-modeline-pdf-mode          "nano-modeline")
  (declare-function nano-modeline-mu4e-headers-mode "nano-modeline")
  (declare-function nano-modeline-mu4e-message-mode "nano-modeline")
  (declare-function nano-modeline-elfeed-entry-mode "nano-modeline")
  (declare-function nano-modeline-elfeed-search-mode "nano-modeline")
  (declare-function nano-modeline-term-mode         "nano-modeline")
  (declare-function nano-modeline-xwidget-mode      "nano-modeline")
  (declare-function nano-modeline-message-mode      "nano-modeline")
  (declare-function nano-modeline-org-capture-mode  "nano-modeline")
  (declare-function nano-modeline-org-agenda-mode   "nano-modeline")

  (defvar ui--nano-modeline-initialized nil
    "Non-nil once nano-modeline hooks have been installed.")

  (defun my/ui--nano-available-p ()
    "Return non-nil if `nano-modeline` can be required."
    (require 'nano-modeline nil 'noerror))

  (defun my/ui--nano-setup ()
    "Install nano-modeline hooks once (idempotent)."
    (when (and (not ui--nano-modeline-initialized)
               (my/ui--nano-available-p))
      (setopt nano-modeline-padding '(0.20 . 0.25))

      (when (fboundp 'nano-modeline-text-mode)
        (nano-modeline-text-mode t))

      (when (fboundp 'nano-modeline-prog-mode)
        (add-hook 'prog-mode-hook            #'nano-modeline-prog-mode))
      (when (fboundp 'nano-modeline-text-mode)
        (add-hook 'text-mode-hook            #'nano-modeline-text-mode))
      (when (fboundp 'nano-modeline-org-mode)
        (add-hook 'org-mode-hook             #'nano-modeline-org-mode))
      (when (fboundp 'nano-modeline-pdf-mode)
        (add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode))
      (when (fboundp 'nano-modeline-mu4e-headers-mode)
        (add-hook 'mu4e-headers-mode-hook    #'nano-modeline-mu4e-headers-mode))
      (when (fboundp 'nano-modeline-mu4e-message-mode)
        (add-hook 'mu4e-view-mode-hook       #'nano-modeline-mu4e-message-mode))
      (when (fboundp 'nano-modeline-elfeed-entry-mode)
        (add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode))
      (when (fboundp 'nano-modeline-elfeed-search-mode)
        (add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode))
      (when (fboundp 'nano-modeline-term-mode)
        (add-hook 'term-mode-hook            #'nano-modeline-term-mode))
      (when (fboundp 'nano-modeline-xwidget-mode)
        (add-hook 'xwidget-webkit-mode-hook  #'nano-modeline-xwidget-mode))
      (when (fboundp 'nano-modeline-message-mode)
        (add-hook 'messages-buffer-mode-hook #'nano-modeline-message-mode))
      (when (fboundp 'nano-modeline-org-capture-mode)
        (add-hook 'org-capture-mode-hook     #'nano-modeline-org-capture-mode))
      (when (fboundp 'nano-modeline-org-agenda-mode)
        (add-hook 'org-agenda-mode-hook      #'nano-modeline-org-agenda-mode))

      (setq ui--nano-modeline-initialized t)
      (message "[ui] nano-modeline initialized.")))

  (leaf nano-modeline
    :straight (nano-modeline :type git :host github :repo "rougier/nano-modeline")
    :after nano-emacs
    :require nil
    :init
    (add-hook 'after-init-hook #'my/ui--nano-setup)
    :hook
    (prog-mode-hook . nano-modeline-prog-mode)
    (text-mode-hook . nano-modeline-text-mode))

  ;;;###autoload
  (defun my/ui-enable-nano ()
    "Enable Nano UI modeline bundle (guarded)."
    (interactive)
    (if (my/ui--nano-available-p)
        (progn
          (my/ui--nano-setup)
          (message "[ui] nano-modeline enabled."))
      (message "[ui] nano-modeline not available; will enable after it is installed.")))

  (provide 'ui/ui-nano-modeline)
  ;;; ui/ui-nano-modeline.el ends here
#+end_src

*** ui/ui-window.el
:PROPERTIES:
:CUSTOM_ID: ui-window
:header-args:emacs-lisp: :tangle lisp/ui/ui-window.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-window.el --- Window management -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;;; Code:

  (leaf zoom :straight t
    :hook (after-init-hook . zoom-mode)
    :custom ((zoom-size . '(0.62 . 0.62))
             (zoom-ignored-major-modes . '(dired-mode treemacs-mode))
             (zoom-ignored-buffer-names . '("*Messages*" "*Help*"))))

  (leaf desktop
    :straight nil
    :config
    (let* ((dir (concat no-littering-var-directory "desktop/")))
      (setq desktop-dirname            dir
            desktop-path               (list dir)
            desktop-base-file-name     "desktop"
            desktop-base-lock-name     "lock"
            desktop-restore-eager      10
            desktop-save               t
            desktop-load-locked-desktop nil
            desktop-auto-save-timeout  300)
      (my/ensure-directory-exists dir)
      (desktop-save-mode 1)))

  (leaf winner
    :straight nil
    :global-minor-mode t)

  (defvar my:saved-window-config nil)

  (defun my/save-window-layout () (interactive)
    (setq my:saved-window-config (window-state-get nil t))
    (message "Window configuration saved."))

  (defun my/restore-window-layout () (interactive)
    (if my:saved-window-config
        (window-state-put my:saved-window-config)
      (message "No saved window configuration found.")))

  (provide 'ui/ui-window)
  ;;; ui/ui-window.el ends here
#+end_src

*** ui/ui-utils.el
:PROPERTIES:
:CUSTOM_ID: ui-utils
:header-args:emacs-lisp: :tangle lisp/ui/ui-utils.el
:END:

#+begin_src emacs-lisp
  ;;; ui/ui-utils.el --- Treemacs configuration & UI utils -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: ui
  ;;
  ;;; Code:

  (leaf minions :straight t
    :custom ((minions-mode-line-lighter . "‚öô"))
    :hook (after-init-hook . minions-mode))

  (setq display-time-interval 30
        display-time-day-and-date t
        display-time-24hr-format t)
  (display-time-mode 1)
  (when (fboundp 'display-battery-mode) (display-battery-mode 1))

  (leaf treemacs :straight t
    :if (display-graphic-p)
    :custom ((treemacs-filewatch-mode . t)
             (treemacs-follow-mode . t)
             (treemacs-indentation . 2)
             (treemacs-missing-project-action . 'remove)))

  (leaf nerd-icons-dired :straight t
    :hook (dired-mode . nerd-icons-dired-mode))

  (leaf pbcopy
    :if (memq window-system '(mac ns))
    :straight t
    :config (turn-on-pbcopy))

  (provide 'ui/ui-utils)
  ;;; ui/ui-utils.el ends here
#+end_src

*** ui/ui-visual-aids.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/ui/ui-visual-aids.el
:END:
#+begin_src emacs-lisp
  ;;; ui/ui-visual-aids.el --- Subtle visual helpers -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Add gentle, non-overlapping visual aids. Avoids features already present in your config.

  (eval-when-compile (require 'leaf))

  ;; 1) Cursor/Movement trail
  (leaf pulsar
    :straight t
    :init (setq pulsar-delay 0.04
                pulsar-pulse t
                pulsar-face 'pulsar-generic)
    :config
    (pulsar-global-mode 1)
    ;; add some common jumps without touching your existing keymaps
    (dolist (cmd '(recenter-top-bottom other-window next-buffer previous-buffer))
      (add-to-list 'pulsar-pulse-functions cmd)))

  ;; 2) TODO highlighting in code/text
  (leaf hl-todo
    :straight t
    :hook ((prog-mode-hook text-mode-hook) . hl-todo-mode)
    :init (setq hl-todo-keyword-faces
                '(("TODO" . "#d97706") ("FIXME" . "#dc2626")
                  ("NOTE" . "#2563eb") ("HACK" . "#9333ea"))))

  ;; 3) Rainbow delimiters (programming only)
  (leaf rainbow-delimiters
    :straight t
    :hook (prog-mode-hook . rainbow-delimiters-mode))

  ;; ;; 4) Lightweight indent guides (no tree sitter dependency)
  ;; (leaf indent-bars
  ;;   :straight t
  ;;   :hook (prog-mode-hook . indent-bars-mode)
  ;;   :init (setq indent-bars-prefer-character t
  ;;               indent-bars-spacing-override 2))

  (provide 'ui/ui-visual-aids)
  ;;; ui/ui-visual-aids.el ends here
#+end_src

*** ui/ui-macos.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/ui/ui-macos.el
:END:
#+begin_src emacs-lisp
  ;;; ui/ui-macos.el --- macOS niceties -*- lexical-binding: t; -*-
  (eval-when-compile (require 'leaf))

  (when (eq system-type 'darwin)
    ;; transparent titlebar & light/dark follows theme (your ef-themes will override ns-appearance)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist '(use-title-bar . t)))

  (provide 'ui/ui-macos)
  ;;; ui/ui-macos.el ends here
#+end_src

*** completion/completion-core.el
:PROPERTIES:
:CUSTOM_ID: completion-core
:header-args:emacs-lisp: :tangle lisp/completion/completion-core.el
:END:

#+begin_src emacs-lisp
  ;;; completion-core.el --- Completion core settings -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf orderless
    :straight t
    :custom
    ((completion-styles . '(orderless basic))
     (completion-category-overrides
      . '((file (styles . (partial-completion)))
          (symbol (styles . (orderless)))
          (command (styles . (orderless)))))))

  (provide 'completion/completion-core)
#+end_src

*** completion/completion-vertico.el
:PROPERTIES:
:CUSTOM_ID: completion-vertico
:header-args:emacs-lisp: :tangle lisp/completion/completion-vertico.el
:END:

#+begin_src emacs-lisp
  ;;; completion-vertico.el --- Vertico minibuffer UI -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf vertico :straight t
    :global-minor-mode vertico-mode
    :custom ((vertico-count . 15)))

  (leaf vertico-posframe :straight t
    :if (display-graphic-p)
    :after vertico
    :custom ((vertico-posframe-border-width . 2))
    :config (vertico-posframe-mode 1))

  (leaf marginalia :straight t
    :global-minor-mode marginalia-mode)

  (provide 'completion/completion-vertico)
#+end_src

*** completion/completion-consult.el
:PROPERTIES:
:CUSTOM_ID: completion-consult
:header-args:emacs-lisp: :tangle lisp/completion/completion-consult.el
:END:

#+begin_src emacs-lisp
  ;;; completion-consult.el --- Consult search/navigation -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf consult :straight t
    :custom
    ((xref-show-xrefs-function . #'consult-xref)
     (xref-show-definitions-function . #'consult-xref)))

  (provide 'completion/completion-consult)
#+end_src

*** completion/completion-embark.el
:PROPERTIES:
:CUSTOM_ID: completion-embark
:header-args:emacs-lisp: :tangle lisp/completion/completion-embark.el
:END:

#+begin_src emacs-lisp
  ;;; completion-embark.el --- Embark actions -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf embark :straight t
    :custom ((prefix-help-command . #'embark-prefix-help-command)))

  (leaf embark-consult :straight t
    :after (embark consult)
    :hook (embark-collect-mode . consult-preview-at-point-mode))

  (provide 'completion/completion-embark)
#+end_src

*** completion/completion-corfu.el
:PROPERTIES:
:CUSTOM_ID: completion-corfu
:header-args:emacs-lisp: :tangle lisp/completion/completion-corfu.el
:END:

#+begin_src emacs-lisp
  ;;; completion/completion-corfu.el --- Corfu popup completion module -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: completion
  ;;
  ;;; Commentary:
  ;; Corfu-based in-buffer completion with sensible defaults.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf corfu :straight t
    :init
    (setq tab-always-indent 'complete)
    (global-corfu-mode)
    :custom ((corfu-auto . t)
             (corfu-cycle . t)))

  (leaf kind-icon :straight t
    :after corfu
    :require t
    :custom ((kind-icon-default-face . 'corfu-default))
    :config (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (leaf cape :straight t
    :after corfu
    :config
    (mapc (lambda (fn) (add-to-list 'completion-at-point-functions fn))
          '(cape-file cape-dabbrev cape-keyword cape-symbol)))

  (provide 'completion/completion-corfu)
  ;;; completion/completion-corfu.el ends here
#+end_src

*** completion/completion-icons.el
:PROPERTIES:
:CUSTOM_ID: completion-corfu
:header-args:emacs-lisp: :tangle lisp/completion/completion-icons.el
:END:

#+begin_src emacs-lisp
  ;;; completion-icons.el --- Nerd icons for completion -*- lexical-binding: t; -*-
  ;;
  ;; Category: completion
  ;;
  (eval-when-compile (require 'leaf))

  (leaf nerd-icons-ibuffer :straight t
    :hook (ibuffer-mode-hook . nerd-icons-ibuffer-mode))

  (leaf nerd-icons-completion :straight t
    :hook (marginalia-mode-hook . nerd-icons-completion-marginalia-setup)
    :config (nerd-icons-completion-mode))

  (setq marginalia-align 'right)

  (provide 'completion/completion-icons)
#+end_src

*** orgx/org-core.el
:PROPERTIES:
:CUSTOM_ID: orgx-core
:header-args:emacs-lisp: :tangle lisp/orgx/org-core.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-core.el --- Org Mode core configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'cl-lib))

  (defvar my:d:org (expand-file-name "org" my:d:var))
  (defvar my:d:org-journal (expand-file-name "journal" my:d:org))
  (defvar my:d:org-roam (expand-file-name "org-roam" my:d:org))
  (defvar my:d:org-pictures (expand-file-name "pictures" my:d:org))
  (defvar my:f:capture-blog-file (expand-file-name "blog.org" my:d:org))

  (my/ensure-directory-exists my:d:org)
  (my/ensure-directory-exists my:d:org-journal)
  (my/ensure-directory-exists my:d:org-roam)
  (my/ensure-directory-exists my:d:org-pictures)

  (defun my/org-buffer-files ()
    "Return a list of *.org files currently visited in live buffers."
    (cl-loop for buf in (buffer-list)
             for file = (buffer-file-name buf)
             when (and file (string-match-p "\\.org\\'" file))
             collect file))

  (leaf org
    :straight nil
    :custom
    ((org-directory . my:d:org)
     (org-default-notes-file . "notes.org")
     (org-log-done . 'time)
     (org-support-shift-select . t)
     (org-return-follows-link . t))
    :config
    (setq org-agenda-files
          (seq-filter (lambda (file)
                        (and (string-match-p "\\.org$" file)
                             (not (string-match-p "archives" file))))
                      (directory-files-recursively org-directory "\\.org$")))
    (unless org-agenda-files
      (setq org-agenda-files (list (expand-file-name "inbox.org" org-directory))))
    (setq org-todo-keywords
          '((sequence "TODO(t)" "SOMEDAY(s)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c@)")))
    (setq org-refile-targets
          '((nil :maxlevel . 3)
            (my/org-buffer-files :maxlevel . 1)
            (org-agenda-files :maxlevel . 3)))
    (setq org-capture-templates
          `(("t" "Todo" entry (file+headline ,(expand-file-name "gtd.org" org-directory) "Inbox")
             "* TODO %?\n %i\n %a")
            ("n" "Note" entry (file+headline ,(expand-file-name "notes.org" org-directory) "Notes")
             "* %?\nEntered on %U\n %i\n %a")
            ("j" "Journal" entry (function org-journal-find-location)
             "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
            ("m" "Meeting" entry (file ,(expand-file-name "meetings.org" org-directory))
             "* MEETING with %? :meeting:\n  %U\n  %a"))))

  (with-eval-after-load 'org
    (let* ((central (expand-file-name "archive.org" (or (bound-and-true-p org-directory)
                                                       (expand-file-name "~/org")))))
      (setopt org-archive-location (concat central "::"))))

  (provide 'orgx/org-core)
  ;;; orgx/org-core.el ends here
#+end_src

*** orgx/org-visual.el
:PROPERTIES:
:CUSTOM_ID: orgx-visual
:header-args:emacs-lisp: :tangle lisp/orgx/org-visual.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-visual.el --- Org Mode visual enhancements -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf org-modern
    :straight t
    :hook (org-mode . org-modern-mode)
    :custom
    ((org-startup-indented . t)
     (org-hide-leading-stars . t)
     (org-auto-align-tags . nil)
     (org-tags-column . 0)
     (org-catch-invisible-edits . 'show-and-error)
     (org-special-ctrl-a/e . t)
     (org-insert-heading-respect-content . t)
     (org-hide-emphasis-markers . t)
     (org-pretty-entities . t)
     ;; TODO faces (variable, not face)
     (org-modern-todo-faces
      . '(("TODO"    :background "#673AB7" :foreground "#f8f8f2")
  	("SOMEDAY" :background "#6b7280" :foreground "#f8f8f2")
  	("WAITING" :background "#6272a4" :foreground "#f8f8f2")
  	("DONE"    :background "#373844" :foreground "#b0b8d1")
  	("CANCELED":background "#4b5563" :foreground "#e5e7eb")))
     ;; Nerd Font icons
     (org-modern-list          . '((?+ . "‚ó¶") (?- . "‚Äì") (?* . "‚Ä¢")))
     (org-modern-checkbox      . '((?X . "Ôò´") (?- . "ÔÑÅ") (?\s . "Ôò∞")))
     (org-modern-priority      . '((?A . "Ôö§") (?B . "ÔÑÇ") (?C . "ÔÑÜ")))
     (org-modern-replace-stars . "ÔàôÔ¢§Ô¢ßÔ¢™Ô¢≠Ô¢∞Ô¢≥Ô¢∂Ô¢πÔ¢º")
     ;; Agenda
     (org-agenda-tags-column . 0)
     (org-agenda-block-separator . ?‚îÄ)
     (org-agenda-time-grid
      . '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ " " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ "))
     (org-agenda-current-time-string
      . "‚≠† now ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")))

  (provide 'orgx/org-visual)
  ;;; org-visual.el ends here
#+end_src

*** orgx/org-extensions.el
:PROPERTIES:
:CUSTOM_ID: orgx-extensions
:header-args:emacs-lisp: :tangle lisp/orgx/org-extensions.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-extensions.el --- Org Mode extensions -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf org-journal :straight t
    :custom ((org-journal-dir . my:d:org-journal)))

  (leaf org-roam :straight t
    :custom ((org-roam-directory . my:d:org-roam))
    :config
    (setq org-roam-db-location (expand-file-name "org-roam.db" my:d:org-roam))
    (org-roam-db-autosync-mode))

  (leaf org-download :straight t
    :custom ((org-download-image-dir . my:d:org-pictures)))

  (leaf toc-org :straight t
    :hook ((org-mode . toc-org-enable)
           (markdown-mode . toc-org-mode)))

  (leaf org-cliplink :straight t)

  (provide 'orgx/org-extensions)
  ;;; orgx/org-extensions.el ends here
#+end_src

*** orgx/org-export.el
:PROPERTIES:
:CUSTOM_ID: orgx-export
:header-args:emacs-lisp: :tangle lisp/orgx/org-export.el
:END:

#+begin_src emacs-lisp
  ;;; orgx/org-export.el --- Org export configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: org
  ;;
  ;; Commentary:
  ;; Org export configuration: LaTeX, Hugo, Markdown.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf ox-hugo :straight t
    :after ox
    :custom ((org-hugo-front-matter-format . "toml")))

  (leaf *ox-hugo--capture
    :require (org-capture org-id)   ;; ensure both are available
    :preface
    ;; Pure Emacs Lisp, newline-free, portable
    (defun my/ox-hugo-generate-safe-filename ()
      "Return a safe Hugo filename like \"YYYYMMDD-xxxxxxxx\".
  It uses `org-id-uuid' and trims to 8 hex chars for stability."
      (let ((date (format-time-string "%Y%m%d"))
            (short (substring (org-id-uuid) 0 8))) ; no newline, pure Elisp
        (format "%s-%s" date short)))

    ;; Optional: where to capture (declare your path elsewhere if you prefer)
    ;; (defvar my:f:capture-blog-file "~/notes/blog.org")

    :config
    (defvar org-capture-templates) ; silence byte-compiler if needed

    ;; Insert (or replace) the "b" template
    (add-to-list
     'org-capture-templates
     `("b" "Blog (Hugo) - new post" entry
       (file+olp ,(or (bound-and-true-p my:f:capture-blog-file)
                      (user-error "Set `my:f:capture-blog-file' to your blog Org file"))
                 "blog")
       ,(concat
         "** TODO %^{Title}\n"
         ":PROPERTIES:\n"
         "  :EXPORT_FILE_NAME: %(my/ox-hugo-generate-safe-filename)\n"
         "  :EXPORT_DATE: %(format-time-string \"%Y-%m-%dT%T%z\")\n"
         "  :EXPORT_HUGO_TAGS: %^{Tags|emacs}\n"
         "  :EXPORT_HUGO_CATEGORIES: %^{Category|blog}\n"
         "  :EXPORT_HUGO_LASTMOD: %(format-time-string \"%Y-%m-%dT%T%z\")\n"
         "  :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :pin false\n"
         "  :END:\n\n"
         "%?\n")
       :empty-lines 1 :prepend t)))

  (leaf markdown-mode :straight t)
  (leaf markdown-preview-mode :straight t)
  (leaf edit-indirect :straight t)

  ;; Mermaid
  (leaf ob-mermaid
    :straight t
    :after org
    :config
    ;; Explicitly set the mmdc path (unnecessary if it's already on PATH).
    (when (executable-find "mmdc")
      (setq ob-mermaid-cli-path (executable-find "mmdc")))
    ;; Register Mermaid with Org Babel.
    (org-babel-do-load-languages
     'org-babel-load-languages
     (append org-babel-load-languages '((mermaid . t)))))

  ;; Graphviz (dot) is built into Org.
  (leaf ob-dot
    :straight nil
    :after org
    :config
    ;; Register Graphviz (dot) with Org Babel.
    (org-babel-do-load-languages
     'org-babel-load-languages
     (append org-babel-load-languages '((dot . t)))))

  (provide 'orgx/org-export)
  ;;; org-export.el ends here
#+end_src

*** orgx/org-typography.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle lisp/orgx/org-typography.el
:END:
#+begin_src emacs-lisp
  ;;; orgx/org-typography.el --- Org modern typography extras -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Complements your existing orgx/org-visual.el (org-modern) without overlap.

  (eval-when-compile (require 'leaf))

  ;; ;; Use variable-pitch for prose buffers (keeps code blocks monospaced)
  ;; (leaf org :straight nil
  ;;   :hook (org-mode-hook . variable-pitch-mode))

  ;; Align tables & inline images nicely
  (leaf valign
    :straight t
    :hook (org-mode-hook . valign-mode))

  ;; Smoothly reveal emphasis markers, links, etc.
  (leaf org-appear
    :straight t
    :hook (org-mode-hook . org-appear-mode)
    :init (setq org-appear-autoemphasis t
                org-appear-autolinks t
                org-appear-autosubmarkers t))

  (provide 'orgx/org-typography)
  ;;; orgx/org-typography.el ends here
#+end_src

*** vcs/vcs-magit.el
:PROPERTIES:
:CUSTOM_ID: vcs-magit
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-magit.el
:END:

#+begin_src emacs-lisp
  ;;; vcs/vcs-magit.el --- Git integration with Magit -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: vcs
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf magit
    :straight t
    ;; Lazy-load: bind entry points only
    :commands (magit-status magit-dispatch)
    :init
    ;; Keep Magit's auto-revert behavior opt-in; avoid eager side effects at load time
    (setq magit-auto-revert-mode nil)
    :config
    ;; Small quality-of-life tweaks (safe defaults)
    (setq magit-refresh-status-buffer nil     ; avoid extra refresh churn
          magit-diff-refine-hunk 'all))      ; inline word-diff for clarity

  (provide 'vcs/vcs-magit)
  ;;; vcs/vcs-magit.el ends here
#+end_src

*** vcs/vcs-gutter.el
:PROPERTIES:
:CUSTOM_ID: vcs-gutter
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-gutter.el
:END:

#+begin_src emacs-lisp
  ;;; vcs/vcs-gutter.el --- Show Git changes in fringe -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: vcs
  ;;
  ;;; Commentary:
  ;; Use `diff-hl` as the sole fringe indicator. Integrates with Magit refresh.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf diff-hl
    :straight t
    :commands (diff-hl-mode diff-hl-dired-mode diff-hl-magit-post-refresh)
    :hook
    ;; Enable indicators only when entering relevant modes
    ((prog-mode . diff-hl-mode)
     (text-mode . diff-hl-mode)
     (dired-mode . diff-hl-dired-mode))
    :config
    ;; Integrate with Magit after it's available (no hard require)
    (with-eval-after-load 'magit
      (add-hook 'magit-post-refresh #'diff-hl-magit-post-refresh))
    (customize-set-variable 'diff-hl-draw-borders nil))

  (provide 'vcs/vcs-gutter)
  ;;; vcs/vcs-gutter.el ends here
#+end_src

*** vcs/vcs-forge.el
:PROPERTIES:
:CUSTOM_ID: vcs-forge
:header-args:emacs-lisp: :tangle lisp/vcs/vcs-forge.el
:END:

#+begin_src emacs-lisp
  ;;; vcs/vcs-forge.el --- GitHub/GitLab integration via Forge -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: vcs
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  ;; Fallbacks when no-littering/utility helpers are not present
  (defvar no-littering-var-directory
    (expand-file-name ".var/" user-emacs-directory)
    "Fallback var directory used when no-littering is not loaded.")
  (unless (file-directory-p no-littering-var-directory)
    (make-directory no-littering-var-directory t))

  (unless (fboundp 'my/ensure-directory-exists)
    (defun my/ensure-directory-exists (dir)
      "Create DIR recursively if it does not exist."
      (unless (file-directory-p dir) (make-directory dir t))))

  (leaf forge
    :straight t
    :after magit
    :init
    ;; Prefer built-in SQLite in Emacs 29+ to avoid external deps
    (with-eval-after-load 'emacsql
      (when (boundp 'emacsql-sqlite3-executable)
        (setq emacsql-sqlite3-executable nil))) ; force builtin backend when available
    :config
    ;; Place Forge DB under var dir; ensure parent exists
    (let* ((db-dir (expand-file-name "forge" no-littering-var-directory))
           (db     (expand-file-name "forge-database.sqlite" db-dir)))
      (my/ensure-directory-exists db-dir)
      (setq forge-database-file db)))

  (provide 'vcs/vcs-forge)
  ;;; vcs/vcs-forge.el ends here
#+end_src

*** dev/dev-lsp-eglot.el
:PROPERTIES:
:CUSTOM_ID: dev-lsp-eglot
:header-args:emacs-lisp: :tangle lisp/dev/dev-lsp-eglot.el
:END:

#+begin_src emacs-lisp
  ;;; dev-lsp-eglot.el --- Eglot setup -*- lexical-binding: t; -*-
  ;;
  ;; Category: dev
  ;;
  ;;; Commentary:
  ;; Eglot baseline with safe auto-enable. Tries to detect a contact *if the
  ;; installed Eglot exposes the helper*, but does not hard-depend on
  ;; private/internal symbols.

  (eval-when-compile (require 'leaf))

  (defun my/eglot-guessable-p ()
    "Return non-nil if current buffer seems to have an LSP server we can start.
  This does **not** error even if Eglot changed its private API."
    (cond
     ;; When the current/older Eglot exposes the internal helper.
     ((fboundp 'eglot--guess-contact)
      (ignore-errors (eglot--guess-contact)))
     ;; When a future Eglot exposes a public \"guess\" helper.
     ((fboundp 'eglot-guess-contact)
      (ignore-errors (eglot-guess-contact)))
     ;; Otherwise, let the caller decide whether to start Eglot anyway.
     (t nil)))

  (leaf eglot
    :straight t
    :commands (eglot eglot-ensure)
    :custom ((eglot-autoreconnect . t))
    :hook ((prog-mode . (lambda ()
                          (when (my/eglot-guessable-p)
                            (eglot-ensure))))))

  ;;;###autoload
  (defun my/lsp-enable-eglot ()
    "Enable Eglot-based LSP setup."
    (interactive)
    (add-hook 'prog-mode-hook
              (lambda ()
                (when (my/eglot-guessable-p)
                  (eglot-ensure))))
    (message "[lsp] Eglot enabled."))

  (provide 'dev/dev-lsp-eglot)
  ;;; dev-lsp-eglot.el ends here
#+end_src

*** dev/dev-lsp-mode.el
:PROPERTIES:
:CUSTOM_ID: dev-lsp-mode
:header-args:emacs-lisp: :tangle lisp/dev/dev-lsp-mode.el
:END:

#+begin_src emacs-lisp
;;; dev-lsp-mode.el --- lsp-mode setup -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2021-2025
;; Author: YAMASHITA, Takao
;; License: GNU GPL v3 or later
;;
;; Category: dev
;;
;;; Commentary:
;; lsp-mode baseline + lsp-ui. Completion is delegated to Corfu.
;;
;;; Code:

(eval-when-compile (require 'leaf))

(leaf lsp-mode
  :straight t
  :commands (lsp lsp-deferred)
  :custom ((lsp-keymap-prefix . "C-c l")
           (lsp-enable-file-watchers . t)
           (lsp-file-watch-threshold . 5000)
           (lsp-response-timeout . 5)
           (lsp-diagnostics-provider . :auto)
           (lsp-completion-provider . :none))
  :hook ((prog-mode . lsp-deferred)))

(leaf lsp-ui
  :straight t
  :after lsp-mode
  :custom ((lsp-ui-doc-enable . t)
           (lsp-ui-doc-delay . 0.2)
           (lsp-ui-sideline-enable . t)))

;;;###autoload
(defun my/lsp-enable-lspmode ()
  "Enable lsp-mode-based LSP setup."
  (interactive)
  (add-hook 'prog-mode-hook #'lsp-deferred)
  (message "[lsp] lsp-mode enabled."))

(provide 'dev/dev-lsp-mode)
;;; dev-lsp-mode.el ends here
#+end_src

*** dev/dev-ai.el
:PROPERTIES:
:CUSTOM_ID: dev-ai
:header-args:emacs-lisp: :tangle lisp/dev/dev-ai.el
:END:

#+begin_src emacs-lisp
  ;;; dev/dev-ai.el --- AI-assisted development -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; AI-assisted coding via Aidermacs.
  ;;
  ;; Purpose: Centralize aider/Aidermacs runtime files into ~/.var/aideremacs
  ;; Notes:
  ;; - Uses official AIDER_* env vars so both CLI and Aidermacs obey.
  ;; - Safe to load early (e.g. in personal/user.el or core/general.el).
  ;; - pip3 install aider-ce
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf)
  		   (require 'subr-x))

  ;; 1) Decide base directory: ~/.var/aideremacs
  (defvar my:d:aider
    (expand-file-name "aideremacs/" (or (bound-and-true-p my:d:var)
                                        (expand-file-name "~/.var/")))
    "Base directory to store aider runtime files.")

  ;; 2) Ensure directory exists
  (my/ensure-directory-exists my:d:aider)

  ;; 3) Point aider history files to this directory via env vars
  ;;    (aider recognizes these officially)
  (setenv "AIDER_INPUT_HISTORY_FILE" (expand-file-name "input.history" my:d:aider))
  (setenv "AIDER_CHAT_HISTORY_FILE"  (expand-file-name "chat.history.md" my:d:aider))
  (setenv "AIDER_LLM_HISTORY_FILE"   (expand-file-name "llm.history" my:d:aider))
  ;; Optional: analytics log location if you enable analytics logging
  (setenv "AIDER_ANALYTICS_LOG"      (expand-file-name "analytics.log" my:d:aider))

  ;; 4) [Optional] Keep a per-user .env here and make aider load it.
  ;;    You can create ~/.var/aideremacs/.env and put API keys / options there.
  ;;    If you use Aidermacs, pass --env-file via its extra args.
  (with-eval-after-load 'aidermacs
    ;; Aidermacs exposes an extra-args variable in recent builds
    ;; (see NonGNU ELPA diffs mentioning `aidermacs-extra-args`).
    ;; If your installed version still uses `aidermacs-args`, switch the name.
    (defvar aidermacs-extra-args nil)
    (let ((env-file (expand-file-name ".env" my:d:aider)))
      (when (file-exists-p env-file)
        (setq aidermacs-extra-args
              (append aidermacs-extra-args
                      (list "--env-file" env-file)))))

    ;; Redundancy is harmless: also force the same files via CLI flags,
    ;; in case your shell environment overrides Emacs' setenv.
    (setq aidermacs-extra-args
          (append aidermacs-extra-args
                  (list "--input-history-file" (getenv "AIDER_INPUT_HISTORY_FILE")
                        "--chat-history-file"  (getenv "AIDER_CHAT_HISTORY_FILE")
                        "--llm-history-file"   (getenv "AIDER_LLM_HISTORY_FILE")))))

  (leaf aidermacs :straight t
    :init
    (cond
     ((getenv "OPENROUTER_API_KEY")
      (setenv "OPENAI_API_BASE" "https://openrouter.ai/api/v1")
      (setenv "OPENAI_API_KEY"  (getenv "OPENROUTER_API_KEY"))
      (setopt aidermacs-default-model "openrouter/anthropic/claude-3.5-sonnet"))
     ((getenv "OPENAI_API_KEY")
      (setenv "OPENAI_API_BASE" "https://api.openai.com/v1")
      (setopt aidermacs-default-model "gpt-4o-mini"))
     (t
      (display-warning 'aidermacs
                       "No API keys set. Set OPENROUTER_API_KEY or OPENAI_API_KEY.")))
    (setopt aidermacs-retry-attempts 3
            aidermacs-retry-delay   2.0
            aidermacs-backend       'vterm))

  (provide 'dev/dev-ai)
  ;;; dev/dev-ai.el ends here
#+end_src

*** dev/dev-term.el
:PROPERTIES:
:CUSTOM_ID: dev-term
:header-args:emacs-lisp: :tangle lisp/dev/dev-term.el
:END:

#+begin_src emacs-lisp
  ;;; dev/dev-term.el --- Terminal integration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Uses ui/ui-nano-palette as the single source of truth for colors.
  ;; Avoid :custom-face (can trigger ‚ÄúAttempt modify constant ‚Ä¶‚Äù with leaf).
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'cl-lib))

  ;; Palette is provided by the caller's load-path setup.
  (require 'ui/ui-nano-palette)

  (defun my/vterm-apply-palette ()
    "Apply nano-style palette to vterm faces safely and compatibly.
  Some vterm builds don't define `vterm-color-default`; use `vterm` face instead."
    ;; Fallbacks (in case palette wasn't set yet)
    (defvar nano-color-foreground "#374151")
    (defvar nano-color-background "#fafafa")
    (defvar nano-color-salient    "#2563eb")
    (defvar nano-color-popout     "#6b7280")
    (defvar nano-color-critical   "#dc2626")
    (defvar nano-color-strong     "#111827")
    (defvar nano-color-faded      "#9ca3af")
    (defvar nano-color-subtle     "#e5e7eb")

    (cl-labels
        ((safe-face-set (face &rest props)
           (when (facep face)
             (apply #'set-face-attribute face nil props))))

      ;; Default fg/bg: prefer vterm-color-default; fall back to vterm
      (if (facep 'vterm-color-default)
          (safe-face-set 'vterm-color-default
                         :foreground nano-color-foreground
                         :background nano-color-background)
        (safe-face-set 'vterm
                       :foreground nano-color-foreground
                       :background nano-color-background))

      ;; 8-color palette (keep backgrounds unobtrusive)
      (safe-face-set 'vterm-color-black   :foreground nano-color-strong   :background 'unspecified)
      (safe-face-set 'vterm-color-red     :foreground nano-color-critical :background 'unspecified)
      (safe-face-set 'vterm-color-green   :foreground "#10b981"           :background 'unspecified) ; emerald-500
      (safe-face-set 'vterm-color-yellow  :foreground nano-color-popout   :background 'unspecified)
      (safe-face-set 'vterm-color-blue    :foreground nano-color-salient  :background 'unspecified)
      (safe-face-set 'vterm-color-magenta :foreground "#a21caf"           :background 'unspecified) ; fuchsia-700
      (safe-face-set 'vterm-color-cyan    :foreground "#0891b2"           :background 'unspecified) ; cyan-600
      (safe-face-set 'vterm-color-white   :foreground nano-color-subtle   :background 'unspecified)))

  (defun my/vterm-buffer-p (buf)
    "Return non-nil if BUF is a vterm buffer."
    (with-current-buffer buf
      (or (eq major-mode 'vterm-mode)
          (string-prefix-p "*vterm" (buffer-name buf)))))

  (leaf vterm
    :doc  "Emacs libvterm integration"
    :url  "https://github.com/akermu/emacs-libvterm"
    :straight t
    :config
    ;; Apply once vterm is loaded
    (my/vterm-apply-palette)
    ;; Re-apply after theme activation to keep colors consistent
    (with-eval-after-load 'cus-theme
      (if (boundp 'enable-theme-functions)
          (add-hook 'enable-theme-functions #'my/vterm-apply-palette)
        (advice-add 'enable-theme :after (lambda (&rest _) (my/vterm-apply-palette))))))

  (leaf vterm-toggle
    :doc  "Toggle between vterm and the current buffer"
    :url  "https://github.com/jixiuf/vterm-toggle"
    :straight t
    :custom
    (vterm-toggle-cd-auto-create-buffer . t)
    (vterm-toggle-fullscreen-p          . nil)
    (vterm-toggle-scope                 . 'project))

  ;; Buffer display rule must be set after vterm is available
  (with-eval-after-load 'vterm
    (add-to-list 'display-buffer-alist
                 `(my/vterm-buffer-p
                   (display-buffer-reuse-window display-buffer-in-direction)
                   (direction       . bottom)
                   (dedicated       . t)
                   (reusable-frames . visible)
                   (window-height   . 0.3))))

  (provide 'dev/dev-term)
  ;;; dev/dev-term.el ends here
#+end_src

*** dev/dev-build.el
:PROPERTIES:
:CUSTOM_ID: dev-build
:header-args:emacs-lisp: :tangle lisp/dev/dev-build.el
:END:

#+begin_src emacs-lisp
  ;;; dev/dev-build.el --- Build & Makefile tools -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Build system integration.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf make-mode :straight nil
    :mode (("\\`Makefile\\'"    . makefile-gmake-mode)
           ("\\`GNUmakefile\\'" . makefile-gmake-mode)
           ("\\`makefile\\'"    . makefile-gmake-mode))
    :hook ((makefile-mode . (lambda ()
                              (setq-local indent-tabs-mode t
                                          tab-width 8
                                          show-trailing-whitespace t))))
    :config
    (leaf compile :straight nil
      :custom ((compilation-scroll-output . t)
               (compilation-skip-threshold . 2))
      :init
      (defun my/set-make-compile-command ()
        "Use `make -k` when Makefile is present."
        (when (or (derived-mode-p 'makefile-mode)
                  (locate-dominating-file default-directory "Makefile")
                  (locate-dominating-file default-directory "GNUmakefile"))
          (setq-local compile-command "make -k")))
      (add-hook 'after-change-major-mode-hook #'my/set-make-compile-command))
    (leaf ansi-color :straight nil
      :hook (compilation-filter . (lambda ()
                                    (let ((inhibit-read-only t))
                                      (ansi-color-apply-on-region compilation-filter-start (point-max)))))))

  (provide 'dev/dev-build)
  ;;; dev/dev-build.el ends here
#+end_src

*** dev/dev-docker.el
:PROPERTIES:
:CUSTOM_ID: dev-docker
:header-args:emacs-lisp: :tangle lisp/dev/dev-docker.el
:END:

#+begin_src emacs-lisp
  ;;; dev/dev-docker.el --- Docker integration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Docker development support.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf dockerfile-mode :straight t
    :mode (("Dockerfile\\(\\..*\\)?\\'" . dockerfile-mode)
           ("\\.dockerfile\\'"         . dockerfile-mode))
    :custom ((dockerfile-mode-command . "docker")))

  (leaf yaml-mode :straight t
    :mode (("\\`docker-compose.*\\.ya?ml\\'" . yaml-mode)
           ("\\.ya?ml\\'"                   . yaml-mode)))

  (leaf docker :straight t
    :commands (docker docker-containers docker-images docker-volumes docker-networks))

  (leaf tramp-container :straight nil
    :after tramp
    :init
    (setq tramp-container-method "docker"))

  (leaf tempel :straight t
    :commands (tempel-insert)
    :init
    (with-eval-after-load 'tempel
      (defvar my:tempel-docker-templates
        '((dockerfile "FROM " p n
                      "WORKDIR /app" n
                      "COPY . /app" n
                      "RUN " p n
                      "CMD [" p "]" n)))
      (add-to-list 'tempel-user-elements my:tempel-docker-templates)))

  (provide 'dev/dev-docker)
  ;;; dev/dev-docker.el ends here
#+end_src

*** dev/web-core.el
:PROPERTIES:
:CUSTOM_ID: dev-web-core
:header-args:emacs-lisp: :tangle lisp/dev/web-core.el
:END:

#+begin_src emacs-lisp
  ;;; web-core.el --- Treesit & project core -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Core configuration for project management and modern syntax highlighting.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf project :straight nil)
  (leaf files   :straight nil
    :custom ((require-final-newline . t)
             (delete-trailing-lines . t))
    :hook ((before-save-hook . delete-trailing-whitespace)))

  (leaf editorconfig
    :straight t
    :global-minor-mode t)

  (leaf treesit
    :straight nil
    :custom ((major-mode-remap-alist
              . '((typescript-mode . typescript-ts-mode)
                  (js-mode         . js-ts-mode)
                  (json-mode       . json-ts-mode)
                  (css-mode        . css-ts-mode)
                  (yaml-mode       . yaml-ts-mode)
                  (sh-mode         . bash-ts-mode)))))

  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'"  . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))

  (provide 'dev/web-core)
  ;;; web-core.el ends here
#+end_src

*** dev/format.el
:PROPERTIES:
:CUSTOM_ID: dev-format
:header-args:emacs-lisp: :tangle lisp/dev/format.el
:END:

#+begin_src emacs-lisp
  ;;; format.el --- Prettier/ESLint via Apheleia -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf apheleia
    :straight t
    :require t
    :config
    (setf (alist-get 'prettierd apheleia-formatters)
          '("prettierd" filepath))
    (setf (alist-get 'prettier apheleia-formatters)
          '("npx" "prettier" "--stdin-filepath" filepath))
    (dolist (pair '((typescript-ts-mode . prettierd)
                    (tsx-ts-mode        . prettierd)
                    (json-ts-mode       . prettierd)
                    (css-ts-mode        . prettierd)
                    (markdown-mode      . prettierd)))
      (add-to-list 'apheleia-mode-alist pair))
    (apheleia-global-mode +1))

  (provide 'dev/format)
  ;;; format.el ends here
#+end_src

*** dev/infra-modes.el
:PROPERTIES:
:CUSTOM_ID: dev-infra-modes
:header-args:emacs-lisp: :tangle lisp/dev/infra-modes.el
:END:

#+begin_src emacs-lisp
  ;;; infra-modes.el --- Infra modes (.env / Compose / TOML / Make) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; Syntax support for infra files such as Docker Compose, .env, TOML, and Makefiles.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf docker-compose-mode :straight t :mode ("docker-compose\\.*ya?ml\\'"))
  (leaf dotenv-mode :straight t
    :mode (("\\.env\\..*\\'" . dotenv-mode)
           ("\\.env\\'"     . dotenv-mode)))
  (leaf toml-mode :straight t :mode ("\\.toml\\'" . toml-mode))

  (provide 'dev/infra-modes)
  ;;; infra-modes.el ends here
#+end_src

*** dev/sql.el
:PROPERTIES:
:CUSTOM_ID: dev-sql
:header-args:emacs-lisp: :tangle lisp/dev/sql.el
:END:

#+begin_src emacs-lisp
  ;;; lisp/dev/sql.el --- SQL/PostgreSQL helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  (eval-when-compile (require 'leaf))

  (leaf sql :straight nil
    :custom ((sql-product . 'postgres)))

  (leaf sql-indent :straight t
    :hook (sql-mode . sqlind-minor-mode))

  (leaf sqlformat
    :straight t
    :custom ((sqlformat-command . 'pgformatter)
             (sqlformat-args . '("--nostyle")))
    :hook (sql-mode . sqlformat-on-save-mode)
    :hook (sql-ts-mode . sqlformat-on-save-mode))

  (provide 'dev/sql)
  ;;; sql.el ends here
#+end_src

*** dev/rest.el
:PROPERTIES:
:CUSTOM_ID: dev-rest
:header-args:emacs-lisp: :tangle lisp/dev/rest.el
:END:

#+begin_src emacs-lisp
  ;;; rest.el --- REST client helpers (Next.js / Ollama / Qdrant) -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: dev
  ;;
  ;; Commentary:
  ;; REST client integration for testing HTTP requests inside Emacs.
  ;; Supports JSON parsing with jq.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf restclient :straight t :mode ("\\.http\\'" . restclient-mode))
  (leaf restclient-jq :straight t :after restclient)

  (provide 'dev/rest)
  ;;; dev/rest.el ends here
#+end_src

*** utils/utils-functions.el
:PROPERTIES:
:CUSTOM_ID: utils-functions
:header-args:emacs-lisp: :tangle lisp/utils/utils-functions.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-functions.el --- General utility functions -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Small, safe utilities loaded across the configuration.
  ;; - Org helpers: indirect subtree view, quick sidebar (imenu-list)
  ;; - Editing helpers: smart buffer/window killing
  ;; Notes:
  ;; - Avoid compile warnings by declaring optional deps and vars.
  ;; - Prefer modern Org APIs when available.
  ;;
  ;;; Code:

  ;;;; Built-ins ------------------------------------------------------------------

  (require 'imenu) ;; built-in

  ;;;; Optional deps & vars (for byte-compiler) -----------------------------------

  (eval-when-compile
    (declare-function imenu-list-minor-mode  "imenu-list")
    (declare-function imenu-list-stop-timer  "imenu-list")
    (declare-function imenu-list-display-dwim "imenu-list")
    (declare-function nano-modeline-render   "nano-modeline"))

  ;; Define imenu-list variables to avoid "free variable" warnings when the
  ;; package is not loaded at compile time.
  (defvar imenu-list-after-jump-hook nil
    "Hook run in the source buffer after a jump from imenu-list.")
  (defvar imenu-list-position 'left
    "Window side for imenu-list. Either 'left or 'right.")
  (defvar imenu-list-size 30
    "Width of the imenu-list window.")
  (defvar imenu-list-focus-after-activation t
    "If non-nil, focus imenu-list window after it appears.")
  (defvar imenu-list--displayed-buffer nil
    "The buffer currently displayed by imenu-list.")

  ;;;; Editing helpers -------------------------------------------------------------

  (defun my/kill-buffer-smart ()
    "Kill buffer and window when there are multiple windows; otherwise kill buffer."
    (interactive)
    (if (one-window-p)
        (kill-buffer)
      (kill-buffer-and-window)))

  ;; Backward-compatible alias used elsewhere in the config.
  (defalias 'my/smart-kill-buffer #'my/kill-buffer-smart)

  ;;;; Nano/Modeline helper --------------------------------------------------------

  (defun my/nano-headerline (buf subtitle)
    "Return a header-line string; prefer nano-modeline when available.
  BUF is the buffer whose name to show. SUBTITLE is a short label."
    (let* ((name (if (and buf (buffer-live-p buf))
                     (buffer-name buf)
                   (buffer-name)))
           (extra ""))
      (if (fboundp 'nano-modeline-render)
          (nano-modeline-render nil name subtitle extra)
        (concat "  "
                (propertize name 'face 'mode-line-buffer-id)
                "  " subtitle))))

  ;;;; Org helpers ----------------------------------------------------------------

  (defun my/org-tree-to-indirect-buffer ()
    "Show current Org subtree in an indirect buffer and reveal its content."
    (interactive)
    (when (derived-mode-p 'org-mode)
      (cond
       ((fboundp 'org-fold-show-all) (org-fold-show-all)) ;; Org ‚â• 9.6
       ((fboundp 'org-show-all)      (org-show-all))))    ;; older Org (obsolete)
    (org-tree-to-indirect-buffer))

  (defun my/org-sidebar ()
    "Open an imenu-list sidebar with safe fallbacks and a minimal header-line."
    (interactive)
    (unless (locate-library "imenu-list")
      (user-error
       "imenu-list is not installed. Use M-x package-install RET imenu-list RET"))
    ;; Autoload key entry points to keep startup light.
    (autoload 'imenu-list-minor-mode  "imenu-list" nil t)
    (autoload 'imenu-list-stop-timer  "imenu-list" nil t)
    (autoload 'imenu-list-display-dwim "imenu-list" nil t)

    ;; Reasonable defaults; set the jump hook to something useful.
    (setq imenu-list-after-jump-hook #'recenter
          imenu-list-position 'left
          imenu-list-size 36
          imenu-list-focus-after-activation t)

    ;; If called from an indirect buffer, go back to the base buffer.
    (when (buffer-base-buffer)
      (switch-to-buffer (buffer-base-buffer)))

    ;; Start sidebar and tame timers to avoid unnecessary refresh churn.
    (imenu-list-minor-mode 1)
    (when (fboundp 'imenu-list-stop-timer) (imenu-list-stop-timer))

    ;; Subtle highlight line if a nano face exists.
    (hl-line-mode 1)
    (when (facep 'nano-subtle)
      (face-remap-add-relative 'hl-line :inherit 'nano-subtle))

    ;; Render a safe header-line; avoid calling nano function directly in hl format.
    (setq header-line-format
          `(:eval
            (my/nano-headerline
             ,(when (boundp 'imenu-list--displayed-buffer)
                'imenu-list--displayed-buffer)
             "(outline)")))
    (setq-local cursor-type nil)

    ;; Best-effort display of items.
    (when (fboundp 'imenu-list-display-dwim)
      (imenu-list-display-dwim)))

  (defun my/org-sidebar-toggle ()
    "Toggle the imenu-list sidebar."
    (interactive)
    (let ((win (get-buffer-window "*Ilist*")))
      (if win
          (progn
            (quit-window nil win)
            (when (buffer-base-buffer)
              (switch-to-buffer (buffer-base-buffer))))
        (my/org-sidebar))))

  (provide 'utils/utils-functions)
  ;;; utils/utils-functions.el ends here
#+end_src

*** utils/utils-scratch.el
:PROPERTIES:
:CUSTOM_ID: utils-scratch
:header-args:emacs-lisp: :tangle lisp/utils/utils-scratch.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-scratch.el --- Scratch buffer helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Automatically recreates *scratch* after it is killed.
  ;; The recreated buffer uses `lisp-interaction-mode` and starts with a small header.
  ;;
  ;;; Code:

  (eval-when-compile (require 'leaf))

  (leaf my:scratch-auto-recreate
    :straight nil
    :init
    (defun my/create-scratch-buffer ()
      "Create or reset a `*scratch*` buffer with `lisp-interaction-mode` and a header."
      (let ((buf (get-buffer-create "*scratch*")))
        (with-current-buffer buf
          (lisp-interaction-mode)
          (erase-buffer)
          (insert ";; This is a new *scratch* buffer\n\n"))
        buf))

    (defun my/kill-scratch-buffer-advice (buf)
      "If BUF is *scratch*, recreate it shortly after kill."
      (when (string= (buffer-name buf) "*scratch*")
        ;; Recreate asynchronously to avoid interfering with the kill flow.
        (run-at-time 0 nil #'my/create-scratch-buffer)))

    ;; When any buffer is killed, if it's *scratch*, recreate it.
    (add-hook 'kill-buffer-hook
              (lambda ()
                (my/kill-scratch-buffer-advice (current-buffer)))))

  (provide 'utils/utils-scratch)
  ;;; utils/utils-scratch.el ends here
#+end_src

*** utils/utils-backup.el
:PROPERTIES:
:CUSTOM_ID: utils-backup
:header-args:emacs-lisp: :tangle lisp/utils/utils-backup.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-backup.el --- Backup and auto-save helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Code:

  (defun my/delete-old-backups ()
    "Delete backup files older than 7 days."
    (interactive)
    (let ((backup-dir (concat no-littering-var-directory "backup/"))
          (threshold (- (float-time (current-time)) (* 7 24 60 60))))
      (when (file-directory-p backup-dir)
        (dolist (file (directory-files backup-dir t))
          (when (and (file-regular-p file)
                     (< (float-time (file-attribute-modification-time
                                     (file-attributes file)))
                        threshold))
            (delete-file file))))))

  (add-hook 'emacs-startup-hook #'my/delete-old-backups)

  (provide 'utils/utils-backup)
  ;;; utils/utils-backup.el ends here
#+end_src

*** utils/utils-async.el
:PROPERTIES:
:CUSTOM_ID: utils-async
:header-args:emacs-lisp: :tangle lisp/utils/utils-async.el
:END:

#+begin_src emacs-lisp
  ;;; utils/utils-async.el --- Async helpers -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Code:

  (defun my/safe-run-async (task)
    "Run TASK asynchronously, catching and reporting any errors."
    (run-at-time 0 nil
                 (lambda ()
                   (condition-case err
                       (funcall task)
                     (error (message "[async] error: %s" err))))))

  (provide 'utils/utils-async)
  ;;; utils/utils-async.el ends here
#+end_src

*** utils/search-nav.el
:PROPERTIES:
:CUSTOM_ID: search-nav
:header-args:emacs-lisp: :tangle lisp/utils/search-nav.el
:END:

#+begin_src emacs-lisp
  ;;; utils/search-nav.el --- Project search & navigation -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; Author: YAMASHITA, Takao
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: utils
  ;;
  ;;; Commentary:
  ;; Modern search/navigation helpers using ripgrep (via consult) and dumb-jump fallback.
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x))

  (leaf dumb-jump :straight t
    :hook (xref-backend-functions . dumb-jump-xref-activate)
    :custom ((dumb-jump-force-searcher  . 'rg)
             (dumb-jump-prefer-searcher . 'rg)))

  (leaf multiple-cursors :straight t)

  (leaf eww :straight nil
    :custom ((eww-search-prefix . "https://duckduckgo.com/html/?kl=jp-jp&k1=-1&kc=1&kf=-1&q=")
             (eww-download-directory . "~/Downloads"))
    :init
    (setopt eww-bookmarks-file (expand-file-name "eww-bookmarks" my:d:eww)
  	  eww-cache-directory (expand-file-name "cache/" my:d:eww))
    (my/ensure-directory-exists eww-cache-directory)
    (setq eww-history-limit 200)
    (defvar eww-hl-search-word nil "Word to highlight with isearch after EWW loads.")
    (defun my/eww-search (term)
      "Search TERM with EWW and start isearch."
      (interactive "sSearch terms: ")
      (setq eww-hl-search-word term)
      (eww-browse-url (concat eww-search-prefix term)))
    (add-hook 'eww-after-render-hook
              (lambda ()
                (when eww-hl-search-word
                  (isearch-mode t)
                  (isearch-yank-string eww-hl-search-word)
                  (setq eww-hl-search-word nil))))
    (defun my/eww-toggle-images () (interactive)
      (setq shr-inhibit-images (not shr-inhibit-images))
      (eww-reload)))

  (provide 'utils/search-nav)
  ;;; utils-search-nav.el ends here
#+end_src

** Personal Profile & Device Integrations ‚Äî `user.el`
:PROPERTIES:
:CUSTOM_ID: personal-profile-and-device-integrations
:END:

*** Overview

**** Purpose
Provide *personal, device-specific overlays* on top of the core configuration:
- Identity (name/email) and safe editor defaults.
- Preferred *fonts/size*, and *global switches* for UI (`nano`) and LSP (`eglot`).
- A portable *Org directory layout* under your cloud path, plus agenda discovery.
- macOS conveniences: *input-method auto-switching* (English‚áÑJapanese) with `sis`, and *Apple Music* control (Hydra).
- Pointer/scroll tuning for the *Logitech MX Ergo* profile.
- Small QoL touches (cursor color normalization after theme changes, load-path exclusions).

**** What this configuration does
- *Identity & safety*
  - Sets `user-full-name`, `user-mail-address`.
  - Disables compacting font caches on macOS; enables passphrase caching for `plstore`.
- *Look & feel*
  - Declares personal font choices (`my:font-*`) and default size.
  - Chooses UI bundle and LSP backend via `my:use-ui` / `my:use-lsp`.
- *Directories / Org*
  - Defines cloud base at `~/Documents` and derives `my:d:org`, `my:d:blog`.
  - Ensures directories exist; points `org-directory` there.
  - Builds `org-agenda-files` by recursively scanning `.org` files (skips ‚Äúarchives‚Äù).
  - Excludes sensitive paths from `load-path`.
- *macOS input method (`sis`)*
  - On startup, configures ABC ‚áÑ Kotoeri (Romaji) via `macism`.
  - Enables cursor-color, respect, and inline modes globally (when available).
- *Cursor color*
  - After any theme load, re-applies frame cursor color to the `cursor` face.
- *MX Ergo S profile*
  - Smooth wheel, conservative scrolling, margin preservation, tilt scrolling; binds:
    - `mouse-2` ‚Üí `yank`, `mouse-4/5` ‚Üí previous/next buffer.
- *Apple Music integration (macOS)*
  - Async/sync `osascript` helpers; commands for play/pause/next/prev.
  - Query current track info; list & play playlists.
  - A *Hydra* with quick keys; wired into *Meow* leader (`SPC M`).

**** Module map (where things live)
| Module file | Role |
|-------------+------|
| =user.el=   | Personal overlay: identity, fonts/UI/LSP switches, Org locations, macOS `sis`, device scroll/mouse, Apple Music Hydra |

**** How it works (flow)
1. *Bootstrap personals*: set identity, fonts, UI/LSP switches; define cloud/Org/blog paths; ensure dirs exist.
2. *Org wiring*: set `org-directory`; compute `org-agenda-files` by filtering non-archive `.org` files.
3. *Hygiene*: remove `my:d:excluded-directories` from `load-path`.
4. *macOS only*:
   - Configure `sis` (ABC ‚Üî Kotoeri) and enable global modes if functions exist.
   - Hook `after-load-theme` to keep the `cursor` face background in sync with the frame cursor color.
5. *Device profile*: apply scroll & mouse bindings tailored for MX Ergo S.
6. *Apple Music*:
   - Define async/sync `osascript` runners.
   - Provide commands (`play-pause`, `next`, `previous`, `current-track-info`, `play-playlist`).
   - Define `my/hydra-apple-music` and bind it to `C-c M`

**** Key settings (reference)
- =my:font-default= :: `"JetBrains Mono NL"`
- =my:font-alt= :: `"Noto Sans JP"`
- =my:emoji-font= :: `"Apple Color Emoji"`
- =my:font-size= :: `18`
- =my:use-ui= :: `'nano`
- =my:use-lsp= :: `'eglot`
- =org-directory= :: `~/Documents/org` (derived from `my:d:cloud`)
- =org-agenda-files= :: All `*.org` under `org-directory`, excluding paths matching `archives`.
- =MX Ergo wheel/scroll= :: `mouse-wheel-scroll-amount='(1 ((shift) . 5) ((control) . 10))`, `scroll-conservatively=10000`, `scroll-margin=2`, `scroll-preserve-screen-position=t`, tilt scroll on.
- =Cursor color keep-alive= :: Re-sets `(set-face-background 'cursor (frame-parameter nil 'cursor-color))` on `after-load-theme`.

**** Usage tips
- *Switch UI or LSP quickly*: set `my:use-ui` to `'nano`/`'doom`/`'none`, `my:use-lsp` to `'eglot`/`'lsp`.
- *Change fonts*: adjust `my:font-*` and `my:font-size` here; your existing `ui/ui-font.el` will pick them up.
- *Apple Music control*:
  - `C-c M` opens the Hydra
  - Keys: `p` (play/pause), `n` (next), `b` (back), `l` (choose playlist), `i` (track info).
- *Agenda scope*: drop an `archives/` folder or use ‚Äúarchives‚Äù in filenames to exclude from `org-agenda-files`.

**** Troubleshooting
- *`sis` not switching on macOS* ‚Üí Ensure the bundle is installed and input source IDs match:
  `"com.apple.keylayout.ABC"` and `"com.apple.inputmethod.Kotoeri.RomajiTyping.Japanese"`. The code guards with `(fboundp ...)`, so missing functions won‚Äôt error.
- *Cursor color looks wrong after theme change* ‚Üí The `after-load-theme` hook reapplies it; ensure your theme sets the frame‚Äôs `'cursor-color` parameter.
- *Hydra key not found* ‚Üí Confirm `hydra` is installed/loaded; the Hydra is wrapped in `with-eval-after-load 'hydra`.
- *Meow leader binding missing* ‚Üí Requires both `meow` and `hydra` loaded; binding occurs inside nested `with-eval-after-load`.

**** Related source blocks (already provided as =.el= file)

#+begin_src emacs-lisp :tangle no
;; See:
;; - user.el  (personal overlay: fonts/UI/LSP, Org locations, macOS sis, MX Ergo, Apple Music Hydra)
#+end_src

*** user.el
:PROPERTIES:
:CUSTOM_ID: user
:header-args:emacs-lisp: :tangle (eval (format "personal/%s.el" (user-login-name)))
:END:

#+begin_src emacs-lisp
  ;;; user.el --- Personal configuration -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (c) 2021-2025
  ;; License: GNU GPL v3 or later
  ;;
  ;; Category: personal
  ;;
  ;;; Commentary:
  ;; Personal settings and device-specific configurations.
  ;;
  ;;; Code:

  (eval-when-compile
    (require 'leaf)
    (require 'subr-x))

  ;;; Personal Information
  (leaf *personals
    :straight nil
    :init
    (setq user-full-name "YAMASHITA, Takao"
          user-mail-address "tjy1965@gmail.com"
          inhibit-compacting-font-caches t
          plstore-cache-passphrase-for-symmetric-encryption t)

    (setq my:font-default "JetBrains Mono" ;; "JetBrainsMono Nerd Font"
          my:font-alt     "Noto Sans JP"
          my:emoji-font   "Apple Color Emoji"
          my:font-size    18)

    (setq my:use-ui 'nano
          my:use-lsp 'eglot)

    (defvar my:d:cloud
      (expand-file-name "Documents" (getenv "HOME"))
      "Cloud storage base directory.")
    (defvar my:d:org
      (expand-file-name "org" my:d:cloud)
      "Org directory.")
    (defvar my:d:blog
      (expand-file-name "devel/repos/mysite" my:d:cloud)
      "Blog directory.")
    (defvar my:f:capture-blog-file
      (expand-file-name "all-posts.org" my:d:blog)
      "Default Org file for blog captures.")
    (defvar my:d:excluded-directories
      (list (expand-file-name "Library/Accounts" (getenv "HOME")))
      "Directories excluded from `load-path` for safety.")

    (mapc #'my/ensure-directory-exists (list my:d:cloud my:d:org my:d:blog))

    (setq org-directory my:d:org)
    (setq org-agenda-files
          (seq-filter (lambda (file)
                        (and (string-match-p "\\.org\\'" file)
                             (not (string-match-p "archives" file))))
                      (directory-files-recursively org-directory "\\.org\\'")))

    (setq load-path
          (seq-remove (lambda (dir)
                        (member dir my:d:excluded-directories))
                      load-path)))

  ;;; SIS
  (leaf sis
    :if (eq system-type 'darwin)
    :straight t
    :commands (sis-ism-lazyman-config
               sis-global-cursor-color-mode
               sis-global-respect-mode
               sis-global-inline-mode)
    :hook (emacs-startup .
           (lambda ()
             (when (fboundp 'sis-ism-lazyman-config)
               (sis-ism-lazyman-config
                "com.apple.keylayout.ABC"
                "com.apple.inputmethod.Kotoeri.RomajiTyping.Japanese"
                'macism))
             (when (fboundp 'sis-global-cursor-color-mode)
               (sis-global-cursor-color-mode t))
             (when (fboundp 'sis-global-respect-mode)
               (sis-global-respect-mode t))
             (when (fboundp 'sis-global-inline-mode)
               (sis-global-inline-mode t)))))

  (add-hook 'after-load-theme-hook
            (lambda ()
              (set-face-background 'cursor (frame-parameter nil 'cursor-color))))

  ;;; Device: MX_ErgoS
  (leaf *device/MX_ErgoS
    :straight nil
    :init
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control) . 10))
          mouse-wheel-progressive-speed nil
          scroll-conservatively 10000
          scroll-margin 2
          scroll-preserve-screen-position t
          mac-mouse-wheel-smooth-scroll t
          mouse-wheel-tilt-scroll t
          mouse-wheel-flip-direction nil)
    (global-set-key [mouse-2] #'yank)
    (global-set-key [mouse-4] #'previous-buffer)
    (global-set-key [mouse-5] #'next-buffer))

  ;;; Apple Music
  (when (eq system-type 'darwin)
    (defun my/apple-music-osascript-async (script &optional callback)
      "Run AppleScript SCRIPT asynchronously.
  If CALLBACK is non-nil, call it with the trimmed output."
      (let* ((proc-name "apple-music-async")
             (buffer-name "*Apple Music Async*")
             (osascript-cmd (list "osascript" "-e" script))
             (proc (apply #'start-process proc-name buffer-name osascript-cmd)))
        (when callback
          (set-process-sentinel
           proc
           (lambda (process event)
             (when (string= event "finished\n")
               (with-current-buffer (process-buffer process)
                 (let ((output (string-trim (buffer-string))))
                   (funcall callback output)))
               (kill-buffer (process-buffer process))))))))

    (defun my/apple-music-osascript-sync (script)
      "Run AppleScript SCRIPT synchronously and return trimmed output."
      (string-trim
       (shell-command-to-string
        (format "osascript -e '%s'" script))))

    ;;;###autoload
    (defun my/apple-music-play-pause ()
      "Toggle play/pause in Apple Music."
      (interactive)
      (my/apple-music-osascript-async
       "tell application \"Music\" to playpause"))

    ;;;###autoload
    (defun my/apple-music-next-track ()
      "Skip to the next track in Apple Music."
      (interactive)
      (my/apple-music-osascript-async
       "tell application \"Music\" to next track"))

    ;;;###autoload
    (defun my/apple-music-previous-track ()
      "Return to the previous track in Apple Music."
      (interactive)
      (my/apple-music-osascript-async
       "tell application \"Music\" to previous track"))

    ;;;###autoload
    (defun my/apple-music-current-track-info ()
      "Show current track info as: Title ‚Äî Artist [Album]."
      (interactive)
      (let ((info
             (my/apple-music-osascript-sync
              "tell application \"Music\" \
  to (get name of current track) & \" ‚Äî \" & (get artist of current track) \
  & \" [\" & (get album of current track) & \"]\"")))
        (message "%s" info)
        info))

    (defun my/apple-music-get-playlists ()
      "Return a list of playlist names from Apple Music."
      (split-string
       (my/apple-music-osascript-sync
        "tell application \"Music\" to get name of playlists")
       ", "))

    ;;;###autoload
    (defun my/apple-music-play-playlist (playlist)
      "Prompt for PLAYLIST and play it in Apple Music."
      (interactive
       (list (completing-read "Playlist: " (my/apple-music-get-playlists))))
      (my/apple-music-osascript-async
       (format "tell application \"Music\" to play playlist \"%s\"" playlist)))

    (with-eval-after-load 'hydra
      (defhydra my/hydra-apple-music (:hint nil)
        "
  Apple Music
  -----------
  _p_: Play/Pause   _n_: Next   _b_: Back
  _l_: Playlist     _i_: Info   _q_: Quit
  "
        ("p" my/apple-music-play-pause)
        ("n" my/apple-music-next-track)
        ("b" my/apple-music-previous-track)
        ("l" my/apple-music-play-playlist)
        ("i" my/apple-music-current-track-info)
        ("q" nil "quit"))
      (global-set-key (kbd "C-c M") #'my/hydra-apple-music/body)))

  ;; Meow leader: <leader> m -> Apple Music hydra
  (with-eval-after-load 'meow
    (with-eval-after-load 'hydra
      (when (fboundp 'meow-leader-define-key)
        (meow-leader-define-key
         '("M" . my/hydra-apple-music/body)))))

  (provide 'user)
  ;;; user.el ends here
#+end_src
